<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#4F46E5">
    <meta name="description" content="Sprach-Tagebuch mit KI-Zusammenfassungen">
    <title>Sprach-Tagebuch Pro</title>
    <link rel="manifest" href="manifest.webmanifest">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        /* AKTUELLE ABSCHNITTE MIT ANPASSUNG DES ABSTANDES */
        .header,
        .record-section,
        /* .transcript-section, .summary-section sind jetzt unten in ihrer eigenen Regel */
        .entries-section {
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            /* NEU: Einheitlicher, reduzierter Abstand von 12px zwischen den Sektionen */
            margin-bottom: 12px; 
            padding: 20px; /* Standard-Padding für Header, Einträge, etc. */
        }
        
        /* Spezifisches Padding für Record Section, da sie den großen Button hat */
        .record-section {
            padding: 30px;
            text-align: center;
        }
        
        /* Spezifisches Padding für Header */
        .header {
             padding: 20px;
        }
        
        /* Spezifisches Padding für Einträge Section */
        .entries-section {
             padding: 20px;
        }

        h1 {
            color: #4F46E5;
            font-size: 28px;
            margin-bottom: 15px;
            overflow-wrap: break-word;
            cursor: pointer; 
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .settings-icon {
            font-size: 20px;
            color: #4F46E5;
            transition: transform 0.3s;
        }

        /* NEU: Icon ist beim Start eingeklappt (rotiert) */
        .header:not(.expanded) .settings-icon {
            transform: rotate(-90deg); /* Zeigt den Pfeil nach unten/rechts */
        }
        /* Wenn aufgeklappt (expanded), zeigt der Pfeil nach oben/links */
        .header.expanded .settings-icon {
            transform: rotate(0deg); /* Zeigt das Zahnrad aufrecht im aufgeklappten Zustand */
        }


        .api-setup {
            /* Hintergrundfarbe entfernt, da sie nicht benötigt wird, wenn die äußere Karte weiß ist und die inneren Elemente ihren eigenen Hintergrund haben */
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            transition: max-height 0.5s ease-out, opacity 0.5s ease-out, padding 0.5s ease-out, margin-bottom 0.5s ease-out;
            overflow: hidden;
            max-height: 500px; 
            opacity: 1;
        }
        
        /* NEU: Hintergrund für die API-Eingabefelder */
        .api-setup .input-group input,
        .api-setup .input-group select {
             /* Helle, neutrale Farbe, die vorher fälschlicherweise knallpink war */
            background-color: #F3F4F6;
        }


        .api-setup.collapsed {
            max-height: 0 !important;
            opacity: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            margin-bottom: 0 !important;
        }

        .input-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            font-size: 14px;
            color: #374151;
            margin-bottom: 5px;
            font-weight: 500;
        }

        input[type="text"], input[type="password"], select, textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #E5E7EB;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #4F46E5;
        }
        
        /* ALTE REGELN ENTFERNT UND ZUSAMMENGEFASST OBEN */
        
        .record-button {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            font-size: 48px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px auto;
        }

        .record-button:hover {
            transform: scale(1.05);
        }

        .record-button:focus {
            outline: 3px solid #818CF8;
            outline-offset: 3px;
        }

        .record-button.recording {
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .status {
            font-size: 16px;
            color: #6B7280;
            margin-top: 10px;
        }
        
        /* Neuer Status für laufende KI-Verarbeitung */
        .processing {
            color: #4F46E5;
            font-weight: 601;
        }


        /* NEUE REGEL: Standardmäßig komplett kollabiert, KEIN Margin/Padding */
        .transcript-section, .summary-section {
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            opacity: 0;
            height: 0;
            overflow: hidden;
            pointer-events: none;
            /* NEU: margin und padding im kollabierten Zustand entfernen */
            margin: 0;          
            padding: 0;
            transition: opacity 0.5s ease-in-out, height 0.5s ease-in-out, padding 0.5s ease-in-out, margin-bottom 0.5s ease-in-out;
        }

        /* NEUE REGEL: Im .show-Zustand wieder Margin/Padding/Höhe geben */
        .transcript-section.show, .summary-section.show {
            opacity: 1;
            height: auto;
            pointer-events: all;
            margin-bottom: 12px; 
            padding: 20px;
        }

        .section-title {
            font-size: 18px;
            color: #4F46E5;
            margin-bottom: 15px;
            font-weight: 600;
        }

        textarea {
            min-height: 150px;
            resize: vertical;
            font-family: inherit;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        button:focus {
            outline: 2px solid #4F46E5;
            outline-offset: 2px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex: 1;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #F3F4F6;
            color: #374151;
            flex: 1;
        }

        .btn-secondary:hover {
            background: #E5E7EB;
        }

        .btn-icon {
            background: #F3F4F6;
            color: #374151;
            padding: 10px 15px;
            flex: 1;
        }

        .btn-icon:hover {
            background: #E5E7EB;
        }

        .tags-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #F3F4F6;
        }
        
        /* Neuer Stil für Tag-Vorschläge */
        .available-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: #F9FAFB;
            border-radius: 8px;
        }
        
        .tag-suggestion {
            background: #E0E7FF;
            color: #4F46E5;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .tag-suggestion:hover {
            background: #C7D2FE;
        }
        
        .tag-suggestion.active {
            background: #4F46E5;
            color: white;
            border-color: #4F46E5;
        }


        .tags-input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .tags-input-group input {
            flex: 1;
        }

        .tags-input-group button {
            flex: 0 0 auto;
        }

        .tag-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .tag {
            background: #EEF2FF;
            color: #4F46E5;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tag-remove {
            background: none;
            border: none;
            color: #4F46E5;
            cursor: pointer;
            padding: 0;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-size: 12px;
        }

        .tag-remove:hover {
            background: #4F46E5;
            color: white;
        }

        .reformulate-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #F3F4F6;
        }

        .reformulate-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .entries-section {
            /* Das margin-bottom von 12px wird bereits oben im Sammelselektor angewendet */
        }

        .entries-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .tag-filter {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        /* NEUE STILE FÜR AKTIVEN FILTER TAG */
        .filter-tag {
            background: #F3F4F6;
            color: #374151;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .filter-tag:hover {
            background: #E5E7EB;
        }

        .filter-tag.active {
            background: #4F46E5;
            color: white;
            border-color: #4F46E5;
        }

        .selection-mode-btn {
            background: #4F46E5;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
        }

        .batch-actions {
            display: none;
            background: #FEF3C7;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            gap: 10px;
            flex-wrap: wrap;
        }

        .batch-actions.show {
            display: flex;
        }

        .batch-actions button {
            flex: 0 0 auto;
            padding: 8px 16px;
            font-size: 13px;
        }

        .entry {
            background: #F9FAFB;
            padding: 15px;
            border-left: 4px solid #4F46E5;
            position: relative;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .entry.selection-mode {
            padding-left: 50px;
        }

        .entry-checkbox {
            position: absolute;
            left: 15px;
            top: 20px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .entry-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
            gap: 10px;
        }

        .entry-date {
            font-size: 14px;
            color: #4F46E5;
            font-weight: 600;
        }

        .entry-location {
            font-size: 12px;
            color: #6B7280;
            margin-top: 2px;
        }

        .entry-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 8px 0;
        }

        .entry-text {
            color: #374151;
            line-height: 1.6;
            white-space: pre-wrap;
            margin-bottom: 10px;
        }

        .entry-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .entry-actions button {
            padding: 6px 12px;
            font-size: 12px;
        }

        .delete-btn {
            background: #EF4444;
            color: white;
        }

        .delete-btn:hover {
            background: #DC2626;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #9CA3AF;
        }

        .loading {
            display: none;
            text-align: center;
            color: #6B7280;
            padding: 10px;
        }

        .loading.show {
            display: block;
        }

        .error {
            background: #FEE2E2;
            color: #991B1B;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            display: none;
        }

        .error.show {
            display: block;
        }

        .success {
            background: #D1FAE5;
            color: #065F46;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            display: none;
        }

        .success.show {
            display: block;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-close {
            background: #F3F4F6;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
        }

        @media (max-width: 640px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 22px;
            }
            
            .button-group, .reformulate-buttons {
                flex-direction: column;
            }
            
            .btn-icon {
                flex: 1 1 100%;
            }

            .tags-input-group {
                flex-direction: column;
            }

            .tags-input-group button {
                flex: 1 1 100%;
            }
        }
    </style>

<style id="diag-styles">
  /* Diagnostik Styles (Collapsible) */
  .diag-card { 
      margin: 16px auto; 
      max-width: 900px; 
      background: rgba(255,255,255,0.9); 
      border-radius: 16px; 
      padding: 16px; 
      box-shadow: 0 6px 24px rgba(0,0,0,0.08); 
      /* NEU: Auch hier einen kleinen margin-bottom nutzen */
      margin-bottom: 12px !important; 
  }
  .diag-card h3 {
      cursor: pointer;
      margin-top: 0;
      margin-bottom: 0; 
      display: flex;
      align-items: center;
      justify-content: space-between;
  }
  .diag-card h3 .toggle-icon {
      font-size: 14px;
      transition: transform 0.3s;
      margin-left: 8px;
      transform: rotate(0deg);
  }
  .diag-card.collapsed h3 .toggle-icon {
      transform: rotate(-90deg);
  }

  .diag-content {
      transition: max-height 0.5s ease-in-out, opacity 0.5s ease-in-out, padding-top 0.5s ease-in-out;
      max-height: 1000px; 
      overflow: hidden;
      opacity: 1;
      padding-top: 16px;
  }
  .diag-card.collapsed .diag-content {
      max-height: 0;
      opacity: 0;
      padding-top: 0;
  }
    
  .diag-grid { display: grid; grid-template-columns: 160px 1fr; gap: 8px 16px; align-items: center; }
  .state-badge { display:inline-block; padding:4px 10px; border-radius:999px; font-size:12px; font-weight:600; }
  .state-ok { background:#e6f7ef; color:#0a7f4f; }
  .state-warn { background:#fff4e6; color:#a15a00; }
  .state-err { background:#ffe8e6; color:#b50000; }
  .level-wrap { width:100%; height:10px; background:#eee; border-radius:6px; overflow:hidden; }
  .level-bar.anim { background: linear-gradient(90deg, #a78bfa, #7c3aed); }
  #diag-log { max-height: 140px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:12px; background:#fafafa; border:1px solid #eee; border-radius:8px; padding:8px; }
  #diag-log .line { padding:2px 0; border-bottom:1px dashed #eee;}
  #diag-last-error { color:#b50000; font-weight:600; }
</style>


    <link rel="apple-touch-icon" href="icon-192.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
</head>
<body>
    <div class="container">
        <!-- NEU: Header-Div erhält die Klasse 'expanded' beim Laden, wenn kein API-Schlüssel hinterlegt ist -->
        <div class="header collapsed" id="header"> <!-- HIER IST DIE WICHTIGE ÄNDERUNG: collapsed ist jetzt standardmäßig gesetzt -->
            <!-- NEU: Klickbares H1 für Toggle -->
            <h1 id="headerTitle">
                Sprach-Tagebuch Pro
                <span class="settings-icon" id="settingsIcon">⚙️</span>
            </h1>
            
            <div class="api-setup collapsed" id="apiSetup"> <!-- HIER IST DIE WICHTIGE ÄNDERUNG: collapsed ist standardmäßig gesetzt -->
                <div class="input-group">
                    <label for="apiProvider">KI-Anbieter:</label>
                    <select id="apiProvider">
                        <option value="anthropic">Anthropic (Claude)</option>
                        <option value="openai">OpenAI (GPT)</option>
                        <option value="gemini">Google (Gemini)</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="apiKey">API-Schlüssel:</label>
                    <input type="password" id="apiKey" placeholder="Dein API-Schlüssel">
                </div>
                <div class="input-group">
                    <label>
                        <input type="checkbox" id="locationPermission">
                        Standort-Freigabe (optional)
                    </label>
                </div>
            </div>
        </div>

        <div class="record-section">
            <h2 class="section-title">Neue Notiz aufnehmen</h2>
            <button class="record-button" id="recordBtn" aria-label="Aufnahme starten">🎤</button>

<div style="margin-top:10px;">
    <!-- Nur noch ein verstecktes Input-Feld für den Audio-Upload-Fallback -->
    <input type="file" id="audioInput" accept="audio/*" capture="microphone" style="display:none;">
    <div id="iosHint" class="status" style="display:none;">Mobile Geräte erkannt: Tippe auf das Mikrofon-Symbol, um die Aufnahme zu starten oder eine Audiodatei auszuwählen.</div>
</div>
            
            <!-- NEU: NFC-Button (nur sichtbar, wenn Web NFC API unterstützt wird) -->
            <div style="margin-top:15px; display:flex; justify-content:center;">
                <button class="btn-secondary" id="nfcBtn" style="display:none;">NFC-Tag lesen 📲</button>
            </div>

            <div class="status" id="status" role="status" aria-live="polite">Bereit zur Aufnahme</div>
        </div>

        <div class="transcript-section" id="transcriptSection">
            <h2 class="section-title">Transkription (Wird automatisch verarbeitet...)</h2>
            <textarea id="transcript" readonly aria-label="Transkribierter Text"></textarea>
            <!-- Buttons entfernt, da der Prozess jetzt automatisch in die Zusammenfassung übergeht -->
            <div class="loading" id="loading" role="status">KI erstellt Zusammenfassung...</div>
            <div class="error" id="error" role="alert"></div>
        </div>

        <div class="summary-section" id="summarySection">
            <h2 class="section-title">Zusammenfassung</h2>
            <textarea id="summary" aria-label="Zusammenfassung bearbeiten"></textarea>
            
            <div class="tags-section">
                <label>Verfügbare Tags:</label>
                <div class="available-tags" id="availableTags">
                    <!-- Hier werden die Tags per JavaScript eingefügt -->
                </div>

                <label>Tags hinzufügen:</label>
                <div class="tags-input-group">
                    <input type="text" id="newTag" placeholder="z.B. Arbeit, Einkauf, Idee...">
                    <button class="btn-secondary" id="addTagBtn">+ Tag</button>
                </div>
                <div class="tag-list" id="currentTags"></div>
            </div>

            <div class="reformulate-section">
                <label>Neu formulieren:</label>
                <div class="reformulate-buttons">
                    <button class="btn-icon" id="reformulateShorter">Kürzer</button>
                    <button class="btn-icon" id="reformulateFormal">Formeller</button>
                    <button class="btn-icon" id="reformulateCasual">Lockerer</button>
                </div>
                <div class="loading" id="reformulateLoading" role="status">KI formuliert um...</div>
            </div>

            <div class="button-group">
                <button class="btn-primary" id="saveBtn">Speichern</button>
                <button class="btn-icon" id="copyBtn">Kopieren</button>
                <button class="btn-icon" id="shareBtn">Teilen</button>
                <button class="btn-secondary" id="editCancelBtn">Abbrechen</button>
            </div>
            <div class="success" id="success" role="status"></div>
        </div>

        <div class="entries-section">
            <div class="entries-header">
                <h2 class="section-title">Meine Einträge</h2>
                <button class="selection-mode-btn" id="toggleSelectionBtn">Auswählen</button>
            </div>

            <div class="batch-actions" id="batchActions">
                <button class="btn-primary" id="summarizeSelectedBtn">Gesamt-Zusammenfassung</button>
                <button class="btn-primary" id="mergeSelectedBtn">Zusammenführen</button>
                <button class="btn-secondary" id="tagSelectedBtn">Tags setzen</button>
                <button class="btn-secondary" id="exportSelectedBtn">Exportieren</button>
                <button class="btn-secondary" id="shareSelectedBtn">Teilen</button>
                <button class="delete-btn" id="deleteSelectedBtn">Löschen</button>
            </div>

            <div class="tag-filter" id="tagFilter"></div>
            <div id="entries"></div>
        </div>
    </div>

    <!-- Edit Modal -->
    <div class="modal" id="editModal" role="dialog" aria-labelledby="editModalTitle">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="section-title" id="editModalTitle">Notiz bearbeiten</h2>
                <button class="modal-close" id="closeEditModal" aria-label="Schließen">✕</button>
            </div>
            <textarea id="editText" aria-label="Text bearbeiten"></textarea>
            <div class="tags-section">
                <label>Verfügbare Tags:</label>
                <div class="available-tags" id="editAvailableTags">
                    <!-- Hier werden die Tags per JavaScript eingefügt -->
                </div>
                <label>Tags:</label>
                <div class="tags-input-group">
                    <input type="text" id="editNewTag" placeholder="Neuer Tag...">
                    <button class="btn-secondary" id="addEditTagBtn">+ Tag</button>
                </div>
                <div class="tag-list" id="editTags"></div>
            </div>
            <div class="button-group">
                <button class="btn-primary" id="saveEditBtn">Speichern</button>
                <button class="btn-secondary" id="cancelEditBtn">Abbrechen</button>
            </div>
            <div class="error" id="editError" role="alert"></div>
            <div class="success" id="editSuccess" role="status"></div>
        </div>
    </div>

    <!-- Batch Summary Modal -->
    <div class="modal" id="batchSummaryModal" role="dialog" aria-labelledby="batchSummaryTitle">
        <div class="modal-content">
            <div class="modal-header">
                <!-- Titel wird dynamisch in JS gesetzt (Zusammenfassung vs. Zusammenführung) -->
                <h2 class="section-title" id="batchSummaryTitle">Ergebnis der Stapelaktion</h2>
                <button class="modal-close" id="closeBatchSummaryModal" aria-label="Schließen">✕</button>
            </div>
            <div class="loading show" id="batchSummaryLoading" role="status">KI erstellt Gesamt-Zusammenfassung...</div>
            <textarea id="batchSummaryText" style="display:none;" aria-label="Gesamt-Zusammenfassung"></textarea>
            <div class="button-group" id="batchSummaryActions" style="display:none;">
                <button class="btn-primary" id="saveBatchSummaryBtn">Als neue Notiz speichern</button>
                <button class="btn-icon" id="copyBatchSummaryBtn">Kopieren</button>
                <button class="btn-secondary" id="closeBatchSummaryBtn">Schließen</button>
            </div>
            <div class="success" id="batchSummarySuccess" role="status"></div>
        </div>
    </div>
    
    <!-- Confirmation Modal -->
    <div class="modal" id="confirmModal" role="dialog" aria-labelledby="confirmTitle">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="section-title" id="confirmTitle">Bestätigung</h2>
                <button class="modal-close" id="closeConfirmModal" aria-label="Schließen">✕</button>
            </div>
            <p id="confirmMessage" style="margin-bottom: 20px;">Sind Sie sicher?</p>
            <div class="button-group">
                <button class="btn-primary" id="confirmYesBtn">Ja</button>
                <button class="btn-secondary" id="confirmNoBtn">Nein</button>
            </div>
        </div>
    </div>

    <script>
        // MediaRecorder State
        let __mr, __mrStream, __mrChunks = [], __mrRecording = false;

        let recognition; // recognition bleibt, aber wird nicht mehr primär genutzt
        let isRecording = false;
        let currentTranscript = '';
        let currentLocation = null;
        let currentTags = [];
        let selectionMode = false;
        let selectedEntries = new Set();
        let editingEntryId = null;
        let activeTagFilter = null;
        let confirmCallback = null;
        let isApiSetupExpanded = false; // Standardmäßig auf FALSE gesetzt!

        const DIARY_KEY = 'diary_entries_v2';

        document.addEventListener('DOMContentLoaded', () => {
            loadAPIKey(); // <--- API Key und Provider werden geladen
            loadLocationPermission(); // NEU: Standort-Präferenz wird geladen
            loadEntries();
            // initSpeechRecognition(); // Entfernt, da Live-SR wegfällt
            setupEventListeners();
            updateAvailableTags(); 
            
            // Wichtiger Aufruf, um die MediaRecorder-Logik zu initialisieren
            initMediaRecorderFallback();
            initIOSFallback(); // Behält das Audio-Upload-Handling
            
            // NEU: NFC Button nur zeigen, wenn API da ist
            updateNFCButton();

            // NEU: Diagnose beim Start einklappen
            document.getElementById('diagnostics').classList.add('collapsed');
            
            // Die Logik zum Aufklappen wird jetzt von loadAPIKey aufgerufen, 
            // damit der DOM-Wert des Keys gelesen werden kann.
        });

        function getEntries() {
            const stored = localStorage.getItem(DIARY_KEY);
            let entries = stored ? JSON.parse(stored) : [];
            entries.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            return entries;
        }

        function saveEntries(entries) {
            localStorage.setItem(DIARY_KEY, JSON.stringify(entries));
            loadEntries();
            updateAvailableTags(); 
        }
        
        // NEU: Logik zum Ein-/Ausklappen der API-Einstellungen
        function toggleApiSetup() {
            isApiSetupExpanded = !isApiSetupExpanded;
            const setupEl = document.getElementById('apiSetup');
            const headerEl = document.getElementById('header');
            
            if (isApiSetupExpanded) {
                setupEl.classList.remove('collapsed');
                headerEl.classList.add('expanded');
                headerEl.classList.remove('collapsed'); // Klasse entfernen, falls sie noch da ist
            } else {
                setupEl.classList.add('collapsed');
                headerEl.classList.remove('expanded');
                headerEl.classList.add('collapsed'); // Klasse hinzufügen
            }
        }
        
        // NEU: Prüft beim Laden, ob API-Schlüssel vorhanden und passt den Zustand an
        function checkAndSetApiSetupState() {
            const apiKey = document.getElementById('apiKey').value.trim(); // <-- Liest den aktuellen (wiederhergestellten) Wert
            const setupEl = document.getElementById('apiSetup');
            const headerEl = document.getElementById('header');
            
            // Logik: Nur aufklappen, wenn KEIN Schlüssel vorhanden ist
            if (apiKey && apiKey.length > 0) {
                // Schlüssel vorhanden -> Zustand bleibt geschlossen (durch HTML-Klasse)
                isApiSetupExpanded = false; 
                // Klassen explizit setzen (beim Start: collapsed)
                setupEl.classList.add('collapsed');
                headerEl.classList.add('collapsed'); // Füge collapsed zur Header-Box hinzu
                headerEl.classList.remove('expanded'); 
            } else {
                // KEIN Schlüssel vorhanden -> geöffnet starten (Klasse entfernen)
                isApiSetupExpanded = true; 
                setupEl.classList.remove('collapsed');
                headerEl.classList.remove('collapsed'); // Entferne collapsed von Header-Box
                headerEl.classList.add('expanded');
            }
        }
        
        // NEU: Logik zum Ein-/Ausklappen der Diagnose
        function toggleDiagnostics() {
            const diag = document.getElementById('diagnostics');
            diag.classList.toggle('collapsed');
        }


        function setupEventListeners() {
            // NEU: Event-Listener für den Header-Titel
            document.getElementById('headerTitle').addEventListener('click', toggleApiSetup);
            // NEU: Event-Listener für den Diagnose-Header
            document.getElementById('diagHeader').addEventListener('click', toggleDiagnostics);
            
            document.getElementById('apiKey').addEventListener('change', saveAPIKey);
            document.getElementById('apiProvider').addEventListener('change', saveAPIKey);
            document.getElementById('recordBtn').addEventListener('click', toggleRecording);
            
            document.getElementById('saveBtn').addEventListener('click', saveEntry);
            document.getElementById('editCancelBtn').addEventListener('click', resetForm); // Zurücksetzen, nicht nur Abbrechen
            
            // NEU: Listener speichert Präferenz beim Ändern
            document.getElementById('locationPermission').addEventListener('change', handleLocationPermission);
            
            document.getElementById('addTagBtn').addEventListener('click', addCurrentTag);
            document.getElementById('newTag').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addCurrentTag();
            });

            document.getElementById('copyBtn').addEventListener('click', copyToClipboard);
            document.getElementById('shareBtn').addEventListener('click', shareContent);

            document.getElementById('reformulateShorter').addEventListener('click', () => reformulate('kürzer'));
            document.getElementById('reformulateFormal').addEventListener('click', () => reformulate('formeller'));
            document.getElementById('reformulateCasual').addEventListener('click', () => reformulate('lockerer'));

            document.getElementById('toggleSelectionBtn').addEventListener('click', toggleSelectionMode);
            
            document.getElementById('summarizeSelectedBtn').addEventListener('click', summarizeSelected);
            document.getElementById('mergeSelectedBtn').addEventListener('click', mergeSelected); // NEU: Event-Listener für Zusammenführen
            document.getElementById('tagSelectedBtn').addEventListener('click', tagSelected);
            document.getElementById('exportSelectedBtn').addEventListener('click', exportSelected);
            document.getElementById('shareSelectedBtn').addEventListener('click', shareSelected);
            document.getElementById('deleteSelectedBtn').addEventListener('click', deleteSelected);

            document.getElementById('closeEditModal').addEventListener('click', closeEditModal);
            document.getElementById('cancelEditBtn').addEventListener('click', closeEditModal);
            document.getElementById('saveEditBtn').addEventListener('click', saveEditedEntry);
            document.getElementById('addEditTagBtn').addEventListener('click', addEditTag);
            document.getElementById('editNewTag').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addEditTag();
            });

            document.getElementById('closeBatchSummaryModal').addEventListener('click', closeBatchSummaryModal);
            document.getElementById('closeBatchSummaryBtn').addEventListener('click', closeBatchSummaryModal);
            document.getElementById('saveBatchSummaryBtn').addEventListener('click', saveBatchSummary);
            document.getElementById('copyBatchSummaryBtn').addEventListener('click', copyBatchSummary);
            
            document.getElementById('confirmYesBtn').addEventListener('click', () => {
                if (confirmCallback) {
                    const cb = confirmCallback;
                    closeConfirmModal();
                    cb();
                } else {
                    closeConfirmModal();
                }
            });
            document.getElementById('confirmNoBtn').addEventListener('click', closeConfirmModal);
            document.getElementById('closeConfirmModal').addEventListener('click', closeConfirmModal);

            // Audio Input Listener muss hier bleiben, da er Fallback für Mobile ist
            const audioInput = document.getElementById('audioInput');
            audioInput.addEventListener('change', handleAudioFileSelection);
            
            // NEU: NFC Listener
            const nfcBtn = document.getElementById('nfcBtn');
            if (nfcBtn) nfcBtn.addEventListener('click', readNFC);
        }

        // Dummy-Funktion für SpeechRecognition (wird nicht mehr primär genutzt, aber zur Sicherheit behalten)
        function initSpeechRecognition() {} 
        
        // NEU: NFC Button Logik (Anzeige)
        function updateNFCButton() {
            const nfcBtn = document.getElementById('nfcBtn');
            // Web NFC ist primär auf Android/Chrome verfügbar und sollte auf iOS/Safari ausgeblendet werden
            if (nfcBtn && ('NDEFReader' in window)) {
                nfcBtn.style.display = 'inline-flex';
            } else if (nfcBtn) {
                nfcBtn.style.display = 'none';
            }
        }
        
        // NEU: NFC Lese Logik
        async function readNFC() {
            if (!('NDEFReader' in window)) {
                showError('NFC-Lesen wird von diesem Gerät/Browser nicht unterstützt (Web NFC API fehlt).');
                return;
            }
            
            resetForm();
            updateRecordButton('NFC: Warte auf Tag-Scan...', 'processing');
            
            try {
                const ndef = new NDEFReader();
                
                // Der Scan-Vorgang beginnt hier.
                await ndef.scan();
                
                // Listener für den Lese-Fehler
                ndef.onreadingerror = (e) => {
                    // Stellt sicher, dass wir nur Fehler behandeln, wenn wir aktiv scannen
                    if (document.getElementById('status').textContent.includes('NFC')) {
                        showError('NFC Lese-Fehler: Tag ungültig, leer, oder Scan abgebrochen.');
                        try { if(window.__memotag?.diag) __memotag.diag.diagError('NFC Lese-Fehler: ' + (e.message || 'Unknown error')); } catch(_) {}
                        updateRecordButton('Bereit zur Aufnahme');
                    }
                };

                // Listener für erfolgreiches Lesen
                ndef.onreading = (e) => {
                    // NFC-Reader stoppen, um Mehrfachlesungen zu vermeiden
                    try { ndef.cancelScan(); } catch (_) {}
                    
                    const record = e.message.records.find(r => r.recordType === 'text');
                    
                    if (record) {
                        const decoder = new TextDecoder(record.encoding);
                        const text = decoder.decode(record.data);
                        processNFCReadout(text);
                    } else {
                        showError('NFC-Tag enthält keinen lesbaren Text-Eintrag (NDEF-Text-Record fehlt).');
                        try { if(window.__memotag?.diag) __memotag.diag.diagError('NFC: Kein Text-Record gefunden.'); } catch(_) {}
                        updateRecordButton('Bereit zur Aufnahme');
                    }
                };
                
                // Setze einen Timeout, falls der Nutzer den Vorgang nicht abschließt
                setTimeout(() => {
                    if (document.getElementById('status').textContent.includes('Warte auf Tag-Scan')) {
                        showError('NFC-Scan-Timeout: Tag nicht innerhalb von 20 Sekunden erkannt.');
                        updateRecordButton('Bereit zur Aufnahme');
                        try { ndef.cancelScan(); } catch (_) {}
                    }
                }, 20000); 

            } catch (error) {
                const errMsg = error.name === 'NotAllowedError' 
                    ? 'NFC-Zugriff verweigert. Bitte prüfen Sie die Browser- und Systemberechtigungen.' 
                    : error.message.includes('No such device') 
                        ? 'NFC ist möglicherweise deaktiviert oder nicht verfügbar.'
                        : `NFC-Fehler: ${error.message}`;
                        
                showError(errMsg);
                try { if(window.__memotag?.diag) __memotag.diag.diagError(`NFC Scan Fehler: ${error.message}`); } catch(_) {}
                updateRecordButton('Bereit zur Aufnahme');
            }
        }
        
        // NEU: Verarbeitet den gelesenen Text
        async function processNFCReadout(text) {
             currentTranscript = text;
             const t = document.getElementById('transcript');
             if (t) t.value = currentTranscript;
             const ts = document.getElementById('transcriptSection');
             if (ts) ts.classList.add('show');
             
             document.getElementById('status').textContent = 'NFC-Inhalt erfasst. Erstelle Zusammenfassung...';
             await summarize(currentTranscript);
        }


        // NEU: Zentrale Umschaltfunktion für die Aufnahme
        function toggleRecording() {
            const hasMediaRecorder = !!(navigator.mediaDevices && window.MediaRecorder);

            if (isRecording) {
                // Aufnahme stoppen (MediaRecorder)
                if (hasMediaRecorder && __mrRecording) {
                    stopMediaRecorder();
                }
                // Wenn MediaRecorder nicht aktiv, aber isRecording true (Sicherheits-Reset)
                else {
                    resetForm();
                }

            } else {
                resetForm();
                // Wenn MediaRecorder verfügbar (PC/Android), starte MediaRecorder
                if (hasMediaRecorder) {
                    startMediaRecorder();
                } 
                // Wenn MediaRecorder NICHT verfügbar (z.B. iOS Safari), nutze den Audio-Upload-Fallback
                else {
                    // Startet den nativen Dialog zur Aufnahme/Auswahl
                    const audioInput = document.getElementById('audioInput');
                    if (audioInput) {
                        try {
                            // Diagnose-Log hinzufügen
                            if(window.__memotag?.diag) __memotag.diag.diagLog('Klick: Mobile Fallback (Audio Upload)'); 
                            audioInput.click();
                        } catch (e) {
                            showError('Mikrofonzugriff nicht möglich. Bitte Audio direkt hochladen.');
                        }
                    }
                }
            }
        }
        
        // NEU: MediaRecorder Start/Stop Logik
        async function startMediaRecorder() {
            try{
                const btn = document.getElementById('recordBtn');
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                __mrStream = stream;
                
                // Wähle den besten MIME-Type
                const mime = MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' :
                             (MediaRecorder.isTypeSupported('audio/ogg') ? 'audio/ogg' : 
                             (MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4' : ''));

                if (!mime) {
                    showError('Ihr Browser unterstützt keine MediaRecorder-Formate für Audio.');
                    stopStream(__mrStream);
                    return;
                }

                __mr = new MediaRecorder(stream, { mimeType: mime });
                __mrChunks = [];
                __mr.ondataavailable = e => { 
                    if(e.data && e.data.size > 0) {
                        __mrChunks.push(e.data); 
                        try { if(window.__memotag?.diag) __memotag.diag.diagLog(`Recorder: Chunk (${e.data.size} Bytes)`); } catch(_) {}
                    }
                };
                
                __mr.onerror = (e) => {
                    showError('Aufnahmefehler: ' + e.error.name);
                    try { if(window.__memotag?.diag) __memotag.diag.diagError('MediaRecorder Fehler: ' + e.error.name); } catch(_) {}
                    stopStream(__mrStream);
                    __mrRecording = false;
                    isRecording = false;
                    updateRecordButton('Fehler.');
                };

                __mr.onstop = processAudioRecording;

                __mr.start(500); 
                __mrRecording = true;
                isRecording = true;
                updateRecordButton('Aufnahme läuft...');
                
                if (document.getElementById('locationPermission')?.checked) {
                    getCurrentLocation();
                }

                try { if(window.__memotag?.diag) __memotag.diag.diagLog('Recorder gestartet: ' + mime); } catch(_) {}
                
                // Starte Mic Meter für Diagnose
                try { if(window.__memotag?.diag) __memotag.diag.startMicMeter(); } catch(_) {}


            }catch(err){
                const errMsg = err.name === 'NotAllowedError' ? 'Mikrofonzugriff verweigert.' : (err.message || err);
                showError('Zugriff auf Mikrofon fehlgeschlagen: ' + errMsg);
                try { if(window.__memotag?.diag) window.__memotag.diag.diagError('Mic-Zugriff Fehler: ' + errMsg); } catch(_) {}
                updateRecordButton('Bereit zur Aufnahme');
            }
        }
        
        function stopMediaRecorder() {
            try{ 
                __mr.stop(); 
                try { if(window.__memotag?.diag) __memotag.diag.diagLog('Recorder Stopp-Kommando gesendet. Warte auf onstop Event...'); } catch(_) {}
                try { if(window.__memotag?.diag) __memotag.diag.stopMicMeter(); } catch(_) {} // Mic Meter stoppen
                updateRecordButton('Verarbeite...');
            }catch(_){}
            stopStream(__mrStream);
            isRecording = false;
        }

        async function processAudioRecording() {
            try{
                const btn = document.getElementById('recordBtn');
                const blobType = __mr && __mr.mimeType ? __mr.mimeType : 'audio/webm';
                const blob = new Blob(__mrChunks, { type: blobType });
                const file = new File([blob], 'aufnahme.' + (blobType.includes('ogg') ? 'ogg' : 'webm'), { type: blobType });
                
                try { if(window.__memotag?.diag) __memotag.diag.diagLog(`Recorder Stopp: Datei (${file.name}) bereit. Größe: ${(file.size / 1024 / 1024).toFixed(2)} MB`); } catch(_) {}

                await processAudioFile(file);

            }catch(err){
                const errorMessage = 'Verarbeitung fehlgeschlagen: ' + (err.message || err);
                showError(errorMessage);
                try { if(window.__memotag?.diag) window.__memotag.diag.diagError(errorMessage); } catch(_) {}
                resetForm();
            } finally {
                __mrRecording = false;
            }
        }
        
        // NEU: Allgemeine Funktion zum Verarbeiten der Audio-Datei (Upload oder MediaRecorder)
        async function processAudioFile(file) {
             // 1. Transkription starten
            document.getElementById('status').textContent = 'Audio-Datei gesendet. Warte auf KI-Transkription...';
            document.getElementById('status').classList.add('processing');
            
            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            if(!apiKey){ 
                showError('Bitte gib einen API-Schlüssel ein.'); 
                resetForm();
                return; 
            }
            
            let transcript;
            try {
                transcript = await transcribeAudio(file, apiKey, provider);
                currentTranscript = transcript || '';
                
                try { if(window.__memotag?.diag) __memotag.diag.diagLog('Transkription erfolgreich abgeschlossen.'); } catch(_) {}

                const t = document.getElementById('transcript');
                if (t) t.value = currentTranscript;
                const ts = document.getElementById('transcriptSection');
                if (ts) ts.classList.add('show');

            } catch(err) {
                 const errorMessage = 'Transkription fehlgeschlagen: ' + (err.message || err);
                showError(errorMessage);
                try { if(window.__memotag?.diag) window.__memotag.diag.diagError(errorMessage); } catch(_) {}
                resetForm();
                return;
            }

            // 2. Transkription fertig - Automatische Zusammenfassung starten
            document.getElementById('status').textContent = 'Transkription abgeschlossen. Erstelle Zusammenfassung...';
            await summarize(currentTranscript);
            document.getElementById('status').classList.remove('processing');
        }


        // NEU: Transkriptions-Logik für Upload-Fallback
        async function handleAudioFileSelection(e) {
            const file = e.target.files && e.target.files[0];
            if (!file) return;

            try { if(window.__memotag?.diag) __memotag.diag.diagLog('Audio-Datei ausgewählt (' + file.name + ')'); } catch(_) {}

            await processAudioFile(file);

        }

        // HILFSFUNKTION: MediaRecorder Fallback Logik (Initialisierung)
        function initMediaRecorderFallback(){
             try { if(window.__memotag?.diag) window.__memotag.diag.diagLog('Init: MediaRecorder Fallback'); } catch(_) {}
            // Der Haupt-Button-Klick-Handler ist jetzt toggleRecording
        }

        // HILFSFUNKTION: iOS Fallback Logik (Initialisierung)
        function initIOSFallback() {
             try { if(window.__memotag?.diag) __memotag.diag.diagLog('Init: iOS Fallback (Status-Hinweis)'); } catch(_) {}
            // Zeige Hinweis für mobile Geräte
            const iosHint = document.getElementById('iosHint');
            if (iosHint) {
                // Wir nutzen die Tatsache aus, dass MediaRecorder auf iOS Safari nicht geht
                const hasMediaRecorder = !!(navigator.mediaDevices && window.MediaRecorder);
                if (!hasMediaRecorder) {
                    iosHint.style.display = 'block';
                }
            }
        }
        
        function stopStream(stream){ 
            try{ if(stream) stream.getTracks().forEach(t=>t.stop()); }catch(_){} 
        }
        
        function updateRecordButton(statusText) {
            const btn = document.getElementById('recordBtn');
            const status = document.getElementById('status');

            if (status) status.textContent = statusText;

            if (statusText.includes('Aufnahme läuft')) {
                if (btn) {
                    btn.classList.add('recording');
                    btn.textContent = '⏹️';
                    btn.setAttribute('aria-label', 'Aufnahme stoppen');
                }
            } else {
                 if (btn) {
                    btn.classList.remove('recording');
                    btn.textContent = '🎤';
                    btn.setAttribute('aria-label', 'Aufnahme starten');
                }
            }

            if (statusText.includes('Warte auf KI') || statusText.includes('Erstelle Zusammenfassung') || statusText.includes('Verarbeite') || statusText.includes('NFC')) {
                 if (status) status.classList.add('processing');
                 if (btn) btn.disabled = true;

            } else {
                 if (status) status.classList.remove('processing');
                 if (btn) btn.disabled = false;
            }

        }


        function getCurrentLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        currentLocation = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude
                        };
                    },
                    (error) => {
                        console.error('Location error:', error);
                        currentLocation = null;
                    }
                );
            }
        }

        function saveLocationPermission(isChecked) {
            localStorage.setItem('location_permission', isChecked ? 'true' : 'false');
        }

        function loadLocationPermission() {
            const permissionCheckbox = document.getElementById('locationPermission');
            const storedValue = localStorage.getItem('location_permission');
            
            // Standardmäßig ist es nicht gesetzt (null) oder 'false'
            if (storedValue === 'true') {
                permissionCheckbox.checked = true;
                // Optional: Hier könnte man direkt die Berechtigung anfordern, 
                // aber der Browser macht das wahrscheinlich automatisch, sobald man die Checkbox anklickt.
            } else {
                permissionCheckbox.checked = false;
            }
        }
        
        function handleLocationPermission() {
            const permissionCheckbox = document.getElementById('locationPermission');
            const isChecked = permissionCheckbox.checked;

            // 1. Speichere die Präferenz
            saveLocationPermission(isChecked);

            // 2. Frage die Berechtigung an, wenn sie aktiviert wurde
            if (isChecked) {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        () => {
                            console.log('Location permission granted');
                            // Keine Fehlermeldung, da die Berechtigung erfolgreich ist.
                        },
                        (error) => {
                            console.error('Location permission denied:', error);
                            // Wenn der Nutzer die Berechtigung verweigert hat, setzen wir die Checkbox zurück
                            // und zeigen eine Meldung, speichern aber die Präferenz, dass er es wollte.
                            permissionCheckbox.checked = false;
                            saveLocationPermission(false);
                            showError('Standort-Berechtigung wurde verweigert oder ist nicht verfügbar.');
                        }
                    );
                } else {
                    showError('Geolocation wird von diesem Browser nicht unterstützt.');
                    permissionCheckbox.checked = false;
                    saveLocationPermission(false);
                }
            }
            // Wenn es deaktiviert wird, muss nichts weiter passieren, außer der Speicherung
        }

        // NEU: Summarize-Funktion nimmt jetzt Transkript als Argument und wird automatisch aufgerufen
        async function summarize(transcript) {
            if (!transcript) { 
                showError('Keine Transkription vorhanden, kann nicht zusammenfassen.'); 
                resetForm();
                return; 
            }

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { 
                showError('Bitte gib einen API-Schlüssel ein.'); 
                resetForm();
                return; 
            }

            document.getElementById('loading').classList.add('show');
            document.getElementById('error').classList.remove('show');
            document.getElementById('summarySection').classList.add('show');

            try {
                let summary = await callLLMAPI(transcript, apiKey, provider);
                document.getElementById('summary').value = summary;
                document.getElementById('loading').classList.remove('show');
                
                // setze Status zurück, damit der Button wieder klickbar ist
                updateRecordButton('Zusammenfassung fertig!');
                
                currentTags = [];
                updateCurrentTags();
            } catch (error) {
                showError('Fehler beim Erstellen der Zusammenfassung: ' + error.message);
                document.getElementById('loading').classList.remove('show');
                resetForm();
            }
        }

        async function reformulate(style) {
            const summary = document.getElementById('summary').value.trim();
            if (!summary) { showError('Keine Zusammenfassung vorhanden.'); return; }

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { showError('Bitte gib einen API-Schlüssel ein.'); return; }

            document.getElementById('reformulateLoading').classList.add('show');
            document.getElementById('success').classList.remove('show');

            try {
                let prompt = '';
                if (style === 'kürzer') {
                    prompt = `Formuliere den folgenden Text deutlich kürzer (max. 50% der Originallänge), aber behalte alle wichtigen Informationen:\n\n${summary}`;
                } else if (style === 'formeller') {
                    prompt = `Formuliere den folgenden Text formeller und professioneller:\n\n${summary}`;
                } else if (style === 'lockerer') {
                    prompt = `Formuliere den folgenden Text lockerer und umgangssprachlicher:\n\n${summary}`;
                }

                let reformulated = await callLLMAPI(prompt, apiKey, provider);
                document.getElementById('summary').value = reformulated;
                document.getElementById('reformulateLoading').classList.remove('show');
                showSuccess('Erfolgreich neu formuliert!');
            } catch (error) {
                showError('Fehler beim Neu-Formulieren: ' + error.message);
                document.getElementById('reformulateLoading').classList.remove('show');
            }
        }

        function addCurrentTag() {
            const tagInput = document.getElementById('newTag');
            const tag = tagInput.value.trim();
            if (tag && !currentTags.includes(tag)) {
                currentTags.push(tag);
                updateCurrentTags();
                tagInput.value = '';
            }
        }

        function updateCurrentTags() {
            const container = document.getElementById('currentTags');
            container.innerHTML = '';
            currentTags.forEach(tag => {
                const wrap = document.createElement('div');
                wrap.className = 'tag';
                const txt = document.createElement('span');
                txt.textContent = tag;
                const btn = document.createElement('button');
                btn.className = 'tag-remove';
                btn.textContent = '×';
                btn.setAttribute('aria-label', `Tag ${tag} entfernen`);
                btn.addEventListener('click', () => removeCurrentTag(tag));
                wrap.appendChild(txt);
                wrap.appendChild(btn);
                container.appendChild(wrap);
            });
            updateAvailableTags();
        }

        function removeCurrentTag(tag) {
            currentTags = currentTags.filter(t => t !== tag);
            updateCurrentTags();
        }
        
        // NEUE FUNKTION: Tags sammeln und anzeigen
        function updateAvailableTags() {
            const allEntries = getEntries();
            const allTags = new Set();
            allEntries.forEach(entry => {
                if (entry.tags) entry.tags.forEach(tag => allTags.add(tag));
            });

            // Tags für den Haupt-Tag-Bereich (Neue Notiz)
            const container = document.getElementById('availableTags');
            renderTagSuggestions(container, allTags, tag => {
                if (!currentTags.includes(tag)) {
                    currentTags.push(tag);
                } else {
                    currentTags = currentTags.filter(t => t !== tag);
                }
                updateCurrentTags();
            }, currentTags);
            
            // Tags für den Edit-Modal-Bereich
            const editContainer = document.getElementById('editAvailableTags');
            // Stelle sicher, dass `currentTags` im Edit Modal die Tags des Eintrags reflektieren, wenn es offen ist
            const tagsForEditModal = editingEntryId ? getEntries().find(e => e.id === editingEntryId)?.tags || [] : currentTags;
            renderTagSuggestions(editContainer, allTags, tag => {
                if (!currentTags.includes(tag)) {
                    currentTags.push(tag);
                } else {
                    currentTags = currentTags.filter(t => t !== tag);
                }
                updateEditTags();
            }, tagsForEditModal);

            // Tags für den Filter-Bereich
            updateTagFilter(allEntries);
        }

        // Hilfsfunktion zum Rendern der klickbaren Tag-Vorschläge
        function renderTagSuggestions(container, tags, clickHandler, activeTags) {
            container.innerHTML = '';
            Array.from(tags).sort().forEach(tag => {
                const tagEl = document.createElement('div');
                tagEl.className = `tag-suggestion ${activeTags.includes(tag) ? 'active' : ''}`;
                tagEl.textContent = tag;
                tagEl.addEventListener('click', () => clickHandler(tag));
                container.appendChild(tagEl);
            });
        }


        function addEditTag() {
            const tagInput = document.getElementById('editNewTag');
            const tag = tagInput.value.trim();
            if (tag && !currentTags.includes(tag)) {
                currentTags.push(tag);
                updateEditTags();
                tagInput.value = '';
            }
        }

        function updateEditTags() {
            const container = document.getElementById('editTags');
            container.innerHTML = '';
            currentTags.forEach(tag => {
                const wrap = document.createElement('div');
                wrap.className = 'tag';
                const txt = document.createElement('span');
                txt.textContent = tag;
                const btn = document.createElement('button');
                btn.className = 'tag-remove';
                btn.textContent = '×';
                btn.setAttribute('aria-label', `Tag ${tag} entfernen`);
                btn.addEventListener('click', () => removeEditTag(tag));
                wrap.appendChild(txt);
                wrap.appendChild(btn);
                container.appendChild(wrap);
            });
            updateAvailableTags(); // Tags im Modal nach dem Editieren aktualisieren
        }

        function removeEditTag(tag) {
            currentTags = currentTags.filter(t => t !== tag);
            updateEditTags();
        }

        function saveEntry() {
            const summary = document.getElementById('summary').value.trim();
            if (!summary) { showError('Keine Zusammenfassung vorhanden.'); return; }

            const entry = {
                id: Date.now().toString(),
                text: summary,
                timestamp: new Date().toISOString(),
                location: currentLocation || null,
                tags: [...currentTags],
                transcript: currentTranscript || ''
            };

            const entries = getEntries();
            entries.unshift(entry);
            saveEntries(entries);

            showSuccess('Notiz gespeichert!');
            setTimeout(() => { resetForm(); }, 1000);
        }

        function deleteEntry(id) {
            showConfirmModal('Eintrag wirklich löschen?', () => {
                const entries = getEntries().filter(e => e.id !== id);
                saveEntries(entries);
                showSuccess('Eintrag gelöscht!');
            });
        }

        function editEntry(id) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry) return;

            editingEntryId = id;
            document.getElementById('editText').value = entry.text;
            document.getElementById('editModal').classList.add('show');
            document.getElementById('editError').classList.remove('show');
            document.getElementById('editSuccess').classList.remove('show');
            
            currentTags = entry.tags ? [...entry.tags] : [];
            updateEditTags();
            updateAvailableTags(); // Wichtig, um die Tags im Modal neu zu rendern
        }

        function saveEditedEntry() {
            const text = document.getElementById('editText').value.trim();
            if (!text) { showError('Text darf nicht leer sein.', 'editError'); return; }

            const entries = getEntries();
            const entryIndex = entries.findIndex(e => e.id === editingEntryId);

            if (entryIndex > -1) {
                entries[entryIndex].text = text;
                entries[entryIndex].tags = [...currentTags];
                saveEntries(entries);
                
                showSuccess('Eintrag aktualisiert!', 'editSuccess');
                setTimeout(() => closeEditModal(), 1000);
            }
        }

        function closeEditModal() {
            document.getElementById('editModal').classList.remove('show');
            editingEntryId = null;
            currentTags = [];
        }

        async function reformulateEntry(id) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry) return;

            const style = prompt('Wie soll neu formuliert werden? (kürzer/formeller/lockerer)');
            if (!style || !['kürzer', 'formeller', 'lockerer'].includes(style.toLowerCase())) return;

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { showError('Bitte gib einen API-Schlüssel ein.'); return; }

            showSuccess('Formuliere um...');

            try {
                let prompt = '';
                if (style.toLowerCase() === 'kürzer') {
                    prompt = `Formuliere den folgenden Text deutlich kürzer (max. 50% der Originallänge), aber behalte alle wichtigen Informationen:\n\n${entry.text}`;
                } else if (style.toLowerCase() === 'formeller') {
                    prompt = `Formuliere den folgenden Text formeller und professioneller:\n\n${entry.text}`;
                } else if (style.toLowerCase() === 'lockerer') {
                    prompt = `Formuliere den folgenden Text lockerer und umgangssprachlicher:\n\n${entry.text}`;
                }

                let reformulated = await callLLMAPI(prompt, apiKey, provider);

                const entries = getEntries();
                const entryIndex = entries.findIndex(e => e.id === id);
                if (entryIndex > -1) {
                    entries[entryIndex].text = reformulated;
                    saveEntries(entries);
                    showSuccess('Erfolgreich neu formuliert!');
                }
            } catch (error) {
                showError('Fehler beim Neu-Formulieren: ' + error.message);
            }
        }

        async function copyEntry(id) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry) return;

            try {
                await navigator.clipboard.writeText(entry.text);
                showSuccess('In Zwischenablage kopiert!');
            } catch (error) {
                showError('Fehler beim Kopieren: ' + error.message);
            }
        }

        async function shareEntry(id) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry) return;

            if (navigator.share) {
                try {
                    await navigator.share({ title: 'Sprach-Tagebuch Notiz', text: entry.text });
                } catch (error) {
                    console.log('Sharing cancelled');
                }
            } else {
                showError('Teilen wird in diesem Browser nicht unterstützt.');
            }
        }

        function loadEntries() {
            let entries = getEntries();
            
            if (activeTagFilter) {
                entries = entries.filter(e => e.tags && e.tags.includes(activeTagFilter));
            }

            renderEntries(entries);
            // updateTagFilter wird in updateAvailableTags aufgerufen.
        }

        function renderEntries(entries) {
            const container = document.getElementById('entries');
            container.innerHTML = '';
            
            if (entries.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'empty-state';
                empty.textContent = 'Noch keine Einträge vorhanden.\nNimm deine erste Notiz auf!';
                container.appendChild(empty);
                return;
            }

            entries.forEach(entry => {
                const entryDiv = document.createElement('div');
                entryDiv.className = `entry ${selectionMode ? 'selection-mode' : ''}`;

                if (selectionMode) {
                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.className = 'entry-checkbox';
                    cb.checked = selectedEntries.has(entry.id);
                    cb.setAttribute('aria-label', `Notiz vom ${new Date(entry.timestamp).toLocaleDateString('de-DE')} auswählen`);
                    cb.addEventListener('change', e => {
                        if (e.target.checked) selectedEntries.add(entry.id);
                        else selectedEntries.delete(e.target.id);
                        updateBatchActionsVisibility();
                    });
                    entryDiv.appendChild(cb);
                }

                const header = document.createElement('div');
                header.className = 'entry-header';
                const dateDiv = document.createElement('div');
                const dateEl = document.createElement('div');
                dateEl.className = 'entry-date';
                dateEl.textContent = new Date(entry.timestamp).toLocaleDateString('de-DE', {
                    day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit'
                });
                dateDiv.appendChild(dateEl);

                if (entry.location) {
                    const locEl = document.createElement('div');
                    locEl.className = 'entry-location';
                    locEl.textContent = `📍 ${entry.location.latitude.toFixed(4)}, ${entry.location.longitude.toFixed(4)}`;
                    dateDiv.appendChild(locEl);
                }
                header.appendChild(dateDiv);
                entryDiv.appendChild(header);

                if (entry.tags && entry.tags.length > 0) {
                    const tagsDiv = document.createElement('div');
                    tagsDiv.className = 'entry-tags';
                    entry.tags.forEach(tag => {
                        const tagEl = document.createElement('div');
                        tagEl.className = 'tag';
                        tagEl.textContent = tag;
                        tagsDiv.appendChild(tagEl);
                    });
                    entryDiv.appendChild(tagsDiv);
                }

                const textEl = document.createElement('div');
                textEl.className = 'entry-text';
                textEl.textContent = entry.text;
                entryDiv.appendChild(textEl);

                const actions = document.createElement('div');
                actions.className = 'entry-actions';
                
                const btnConfigs = [
                    ['Bearbeiten', 'btn-icon', () => editEntry(entry.id)],
                    ['Neu formulieren', 'btn-icon', () => reformulateEntry(entry.id)],
                    ['Kopieren', 'btn-icon', () => copyEntry(entry.id)],
                    ['Teilen', 'btn-icon', () => shareEntry(entry.id)],
                    ['Löschen', 'delete-btn', () => deleteEntry(entry.id)]
                ];

                btnConfigs.forEach(([label, className, handler]) => {
                    const btn = document.createElement('button');
                    btn.className = className;
                    btn.textContent = label;
                    btn.addEventListener('click', handler);
                    actions.appendChild(btn);
                });

                entryDiv.appendChild(actions);
                container.appendChild(entryDiv);
            });
        }

        function updateTagFilter(allEntries) {
            const allTags = new Set();
            allEntries.forEach(entry => {
                if (entry.tags) entry.tags.forEach(tag => allTags.add(tag));
            });

            const container = document.getElementById('tagFilter');
            container.innerHTML = '';
            
            if (allTags.size === 0 && !activeTagFilter) return;

            const allBtn = document.createElement('div');
            // NEU: Aktive Klasse basierend auf activeTagFilter
            allBtn.className = `filter-tag ${!activeTagFilter ? 'active' : ''}`;
            allBtn.textContent = 'Alle';
            allBtn.addEventListener('click', () => filterByTag(null));
            container.appendChild(allBtn);

            Array.from(allTags).forEach(tag => {
                const tagBtn = document.createElement('div');
                // NEU: Aktive Klasse basierend auf activeTagFilter
            tagBtn.className = `filter-tag ${activeTagFilter === tag ? 'active' : ''}`;
                tagBtn.textContent = tag;
                tagBtn.addEventListener('click', () => filterByTag(tag));
                container.appendChild(tagBtn);
            });
        }

        function filterByTag(tag) {
            // NEU: activeTagFilter setzen/zurücksetzen und dann Einträge neu laden
            activeTagFilter = tag;
            loadEntries();
            updateTagFilter(getEntries()); // Wichtig: Filter-Buttons aktualisieren
        }

        function toggleSelectionMode() {
            selectionMode = !selectionMode;
            selectedEntries.clear();
            
            const btn = document.getElementById('toggleSelectionBtn');
            btn.textContent = selectionMode ? 'Fertig' : 'Auswählen';
            
            loadEntries();
            updateBatchActionsVisibility();
        }

        function updateBatchActionsVisibility() {
            const batchActions = document.getElementById('batchActions');
            if (selectionMode && selectedEntries.size > 0) {
                batchActions.classList.add('show');
            } else {
                batchActions.classList.remove('show');
            }
        }

        async function summarizeSelected() {
            const allEntries = getEntries();
            const entries = allEntries.filter(e => selectedEntries.has(e.id));
            if (entries.length === 0) return;

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { showError('Bitte gib einen API-Schlüssel ein.'); return; }
            
            document.getElementById('batchSummaryTitle').textContent = 'Gesamt-Zusammenfassung';
            document.getElementById('batchSummaryModal').classList.add('show');
            document.getElementById('batchSummaryText').style.display = 'none';
            document.getElementById('batchSummaryActions').style.display = 'none';
            document.getElementById('batchSummaryLoading').classList.add('show');
            document.getElementById('batchSummarySuccess').classList.remove('show');

            try {
                const combinedText = entries.map((e, i) => `Notiz ${i + 1} (${new Date(e.timestamp).toLocaleDateString('de-DE')}):\n${e.text}`).join('\n\n---\n\n');
                
                const prompt = `Erstelle eine prägnante Gesamt-Zusammenfassung der folgenden ${entries.length} Notizen. Identifiziere gemeinsame Themen und wichtige Erkenntnisse:\n\n${combinedText}`;

                let summary = await callLLMAPI(prompt, apiKey, provider);

                document.getElementById('batchSummaryLoading').classList.remove('show');
                document.getElementById('batchSummaryText').value = summary;
                document.getElementById('batchSummaryText').style.display = 'block';
                document.getElementById('batchSummaryActions').style.display = 'flex';
            } catch (error) {
                document.getElementById('batchSummaryLoading').classList.remove('show');
                showError('Fehler beim Zusammenfassen: ' + error.message, 'batchSummarySuccess');
            }
        }
        
        // NEU: Funktion zum Zusammenführen von Einträgen ohne Informationsverlust
        async function mergeSelected() {
            const allEntries = getEntries();
            const entries = allEntries.filter(e => selectedEntries.has(e.id));
            if (entries.length === 0) return;

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { showError('Bitte gib einen API-Schlüssel ein.'); return; }
            
            document.getElementById('batchSummaryTitle').textContent = 'Zusammenführung (Daten-Kompilation)';
            document.getElementById('batchSummaryModal').classList.add('show');
            document.getElementById('batchSummaryText').style.display = 'none';
            document.getElementById('batchSummaryActions').style.display = 'none';
            document.getElementById('batchSummaryLoading').classList.add('show');
            document.getElementById('batchSummarySuccess').classList.remove('show');
            document.getElementById('batchSummaryLoading').textContent = 'KI führt Einträge zusammen...';


            try {
                const combinedText = entries.map((e, i) => `--- Eintrag ${i + 1} ---\n${e.text}`).join('\n\n');
                
                // Strenger Prompt zur Kompilation von Daten und Listen
                const prompt = `Führe die folgenden ${entries.length} Notizen zusammen, ohne Informationen zu verlieren oder zu verallgemeinern. Deine Aufgabe ist die detailgetreue Kompilation.
                
                Wichtige Regeln:
                1. KEINE Zusammenfassung, KEINE Verallgemeinerung.
                2. Wenn es sich um Listen (z.B. Einkaufslisten, To-Do-Listen) handelt, kompiliere diese direkt in EINE EINZIGE, VOLLSTÄNDIGE Liste.
                3. Erhalte alle spezifischen Details (z.B. genaue Produktnamen, Zahlen, Adressen).
                
                Texte zum Zusammenführen:
                
                ${combinedText}`;

                let result = await callLLMAPI(prompt, apiKey, provider);

                document.getElementById('batchSummaryLoading').classList.remove('show');
                document.getElementById('batchSummaryText').value = result;
                document.getElementById('batchSummaryText').style.display = 'block';
                document.getElementById('batchSummaryActions').style.display = 'flex';
            } catch (error) {
                document.getElementById('batchSummaryLoading').classList.remove('show');
                showError('Fehler beim Zusammenführen: ' + error.message, 'batchSummarySuccess');
            }
        }


        function saveBatchSummary() {
            const summary = document.getElementById('batchSummaryText').value.trim();
            if (!summary) return;

            const entry = {
                id: Date.now().toString(),
                text: summary,
                timestamp: new Date().toISOString(),
                location: null,
                // Tag anpassen, je nachdem, welche Aktion zuletzt ausgeführt wurde
                tags: [document.getElementById('batchSummaryTitle').textContent.includes('Zusammenfassung') ? 'Zusammenfassung' : 'Kompilation'],
                transcript: `${document.getElementById('batchSummaryTitle').textContent} von ${selectedEntries.size} Notizen`
            };

            const entries = getEntries();
            entries.unshift(entry);
            saveEntries(entries);

            showSuccess('Ergebnis gespeichert!', 'batchSummarySuccess');
            setTimeout(() => closeBatchSummaryModal(), 1000);
        }

        function closeBatchSummaryModal() {
            document.getElementById('batchSummaryModal').classList.remove('show');
            document.getElementById('batchSummaryText').value = '';
            document.getElementById('batchSummaryText').style.display = 'none';
            document.getElementById('batchSummaryActions').style.display = 'none';
            document.getElementById('batchSummaryLoading').classList.add('show');
            // Titel für das nächste Mal zurücksetzen
            document.getElementById('batchSummaryTitle').textContent = 'Ergebnis der Stapelaktion';
            document.getElementById('batchSummaryLoading').textContent = 'KI erstellt Gesamt-Zusammenfassung...';
        }

        function copyBatchSummary() {
            const text = document.getElementById('batchSummaryText').value;
            if (!text) return;
            navigator.clipboard.writeText(text).then(() => {
                showSuccess('In Zwischenablage kopiert!', 'batchSummarySuccess');
            }).catch(() => {
                showError('Fehler beim Kopieren.', 'batchSummarySuccess');
            });
        }

        function deleteSelected() {
            if (selectedEntries.size === 0) return;

            showConfirmModal(`${selectedEntries.size} Einträge wirklich löschen?`, () => {
                const entries = getEntries().filter(e => !selectedEntries.has(e.id));
                saveEntries(entries);
                
                selectedEntries.clear();
                toggleSelectionMode();
                showSuccess('Ausgewählte Einträge gelöscht!');
            });
        }

        function tagSelected() {
            const tag = prompt('Tag für ausgewählte Einträge:');
            if (!tag || selectedEntries.size === 0) return;

            const entries = getEntries();
            let changed = false;
            entries.forEach(entry => {
                if (selectedEntries.has(entry.id)) {
                    if (!entry.tags) entry.tags = [];
                    if (!entry.tags.includes(tag)) {
                        entry.tags.push(tag);
                        changed = true;
                    }
                }
            });
            
            if (changed) {
                saveEntries(entries);
                showSuccess('Tags hinzugefügt!');
            }
        }

        function exportSelected() {
            const allEntries = getEntries();
            const entries = allEntries.filter(e => selectedEntries.has(e.id));
            if (entries.length === 0) return;

            const text = entries.map(e => {
                const date = new Date(e.timestamp).toLocaleString('de-DE');
                const tags = e.tags ? `\nTags: ${e.tags.join(', ')}` : '';
                const location = e.location ? `\nStandort: ${e.location.latitude}, ${e.location.longitude}` : '';
                return `=== ${date} ===${tags}${location}\n\n${e.text}`;
            }).join('\n\n' + '='.repeat(50) + '\n\n');

            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `notizen_${new Date().toISOString().split('T')[0]}.txt`;
            a.click();
            URL.revokeObjectURL(url);

            showSuccess('Exportiert!');
        }

        async function shareSelected() {
            const allEntries = getEntries();
            const entries = allEntries.filter(e => selectedEntries.has(e.id));
            if (entries.length === 0) return;

            const text = entries.map(e => {
                const date = new Date(e.timestamp).toLocaleDateString('de-DE');
                return `${date}:\n${e.text}`;
            }).join('\n\n---\n\n');

            if (navigator.share) {
                try {
                    await navigator.share({ title: 'Meine Notizen', text: text });
                } catch (error) {
                    console.log('Sharing cancelled');
                }
            } else {
                showError('Teilen wird in diesem Browser nicht unterstützt.');
            }
        }

        function saveAPIKey() {
            localStorage.setItem('api_key', document.getElementById('apiKey').value);
            localStorage.setItem('api_provider', document.getElementById('apiProvider').value);
            // NEU: Status nach dem Speichern der API-Schlüssel überprüfen und zuklappen
            checkAndSetApiSetupState();
        }

        function loadAPIKey() {
            const apiKey = localStorage.getItem('api_key');
            const provider = localStorage.getItem('api_provider');
            if (apiKey) document.getElementById('apiKey').value = apiKey;
            if (provider) document.getElementById('apiProvider').value = provider;
            
            // WICHTIG: API Setup Zustand erst NACHDEM die Werte geladen sind prüfen!
            checkAndSetApiSetupState();
        }

        function showError(message, targetId = 'error') {
            const errorEl = document.getElementById(targetId);
            errorEl.textContent = message;
            errorEl.classList.add('show');
            setTimeout(() => errorEl.classList.remove('show'), 5000);
        }

        function showSuccess(message, targetId = 'success') {
            const successEl = document.getElementById(targetId);
            successEl.textContent = message;
            successEl.classList.add('show');
            setTimeout(() => successEl.classList.remove('show'), 3000);
        }

        function showConfirmModal(message, callback) {
            document.getElementById('confirmMessage').textContent = message;
            document.getElementById('confirmModal').classList.add('show');
            confirmCallback = callback;
        }

        function closeConfirmModal() {
            document.getElementById('confirmModal').classList.remove('show');
            confirmCallback = null;
        }

        async function copyToClipboard() {
            const text = document.getElementById('summary').value;
            try {
                await navigator.clipboard.writeText(text);
                showSuccess('In Zwischenablage kopiert!');
            } catch (error) {
                showError('Fehler beim Kopieren: ' + error.message);
            }
        }

        async function shareContent() {
            const text = document.getElementById('summary').value;
            if (navigator.share) {
                try {
                    await navigator.share({ title: 'Sprach-Tagebuch Notiz', text: text });
                } catch (error) {
                    console.log('Sharing cancelled');
                }
            } else {
                showError('Teilen wird in diesem Browser nicht unterstützt.');
            }
        }

        function resetForm() {
            currentTranscript = '';
            currentLocation = null;
            currentTags = [];
            document.getElementById('transcript').value = '';
            document.getElementById('summary').value = '';
            document.getElementById('newTag').value = '';
            document.getElementById('transcriptSection').classList.remove('show');
            document.getElementById('summarySection').classList.remove('show');
            
            // Setze den Status zurück
            updateRecordButton('Bereit zur Aufnahme');
            
            updateCurrentTags();
            document.getElementById('error').classList.remove('show');
            document.getElementById('success').classList.remove('show');
        }

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                
navigator.serviceWorker.register('./sw.js').then(reg => {
    console.log('Service Worker registriert', reg);
    // Wenn bereits ein wartender Worker existiert: sofort aktivieren
    if (reg.waiting) { reg.waiting.postMessage('SKIP_WAITING'); }
    // Bei Updates
    reg.addEventListener('updatefound', () => {
        const nw = reg.installing;
        if (nw) {
            nw.addEventListener('statechange', () => {
                if (nw.state === 'installed' && reg.waiting) {
                    reg.waiting.postMessage('SKIP_WAITING');
                }
            });
        }
    });
}).catch(err => console.log('SW registration failed:', err));

// Neu laden, wenn der Controller wechselt (App-Update)
navigator.serviceWorker.addEventListener('controllerchange', () => {
    console.log('Neue Version aktiv – Seite wird aktualisiert…');
    window.location.reload();
});

            });
        }
    </script>

    <!-- KI API Logik -->
    <script>
        // Funktion zum Extrahieren der KI-Antwort basierend auf dem Anbieter
        function handleAPIResponse(provider, data) {
            if (provider === 'anthropic') {
                // Anthropic (Claude) Antwortstruktur
                const textBlock = data.content?.find(block => block.type === 'text');
                return textBlock?.text || 'Fehler beim Parsen der Anthropic-Antwort.';
            } else if (provider === 'openai') {
                // OpenAI (GPT) Antwortstruktur
                return data.choices?.[0]?.message?.content || 'Fehler beim Parsen der OpenAI-Antwort.';
            } else if (provider === 'gemini') {
                // Google (Gemini) Antwortstruktur
                return data.candidates?.[0]?.content?.parts?.[0]?.text || 'Fehler beim Parsen der Gemini-Antwort.';
            }
            return 'Unbekannter KI-Anbieter.';
        }

        // Hauptfunktion für den KI-API-Aufruf
        async function callLLMAPI(userPrompt, apiKey, provider, retryCount = 0) {
            let url = '';
            let headers = {};
            let body = {};
            let model = '';
            let systemInstruction = 'Du bist ein freundlicher, prägnanter Assistent, der Sprachnotizen zusammenfasst und umformuliert. Deine Antwort soll nur die gewünschte Ausgabe enthalten, ohne einleitenden Text wie "Hier ist die Zusammenfassung". Antworte auf Deutsch.';

            // API Konfiguration basierend auf Anbieter
            if (provider === 'anthropic') {
                url = 'https://api.anthropic.com/v1/messages';
                model = 'claude-3-haiku-20240307';
                headers = {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01'
                };
                body = {
                    model: model,
                    max_tokens: 2000,
                    system: systemInstruction,
                    messages: [
                        { role: 'user', content: userPrompt }
                    ]
                };
            } else if (provider === 'openai') {
                url = 'https://api.openai.com/v1/chat/completions';
                model = 'gpt-3.5-turbo';
                headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                };
                body = {
                    model: model,
                    messages: [
                        { role: 'system', content: systemInstruction },
                        { role: 'user', content: userPrompt }
                    ],
                    max_tokens: 2000
                };
            } else if (provider === 'gemini') {
                // Gemini verwendet den Canvas-Proxy, daher kein API-Key im Header, sondern in der URL
                url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                headers = {
                    'Content-Type': 'application/json'
                };
                // Korrigierte Struktur: generationConfig statt config und maxOutputTokens direkt darin
                body = {
                    contents: [{ parts: [{ text: userPrompt }] }],
                    systemInstruction: { parts: [{ text: systemInstruction }] },
                    generationConfig: { maxOutputTokens: 2000 }
                };
            } else {
                throw new Error('Unbekannter KI-Anbieter ausgewählt.');
            }

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(body)
                });

                const data = await response.json();

                if (!response.ok) {
                    const errorMsg = data.error?.message || data.error?.type || 'Unbekannter Fehler';
                    throw new Error(`API-Fehler (${response.status}): ${errorMsg}`);
                }

                // Fehlerbehandlung für unvollständige Antworten
                const resultText = handleAPIResponse(provider, data);
                if (resultText.startsWith('Fehler beim Parsen')) {
                     throw new Error(resultText);
                }
                
                return resultText;

            } catch (error) {
                // Exponential Backoff für Netzwerkfehler oder Timeout
                if (retryCount < 3 && (error.message.includes('Failed to fetch') || error.message.includes('Timeout'))) {
                    const delay = Math.pow(2, retryCount) * 1000;
                    console.warn(`API-Aufruf fehlgeschlagen. Versuche es in ${delay}ms erneut...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return callLLMAPI(userPrompt, apiKey, provider, retryCount + 1);
                }
                throw error;
            }
        }
    </script>
    
<section class="diag-card collapsed" id="diagnostics"> <!-- NEU: 'collapsed' als Standard -->
  <h3 style="margin-top:0" id="diagHeader">Diagnose <span class="toggle-icon">▼</span></h3> <!-- NEU: ID und Icon -->
  <div class="diag-content" id="diagContent"> <!-- NEU: Content Wrapper -->
      <div class="diag-grid">
        <div>Zustand</div>
        <div><span id="diag-state" class="state-badge state-warn">bereit</span></div>

        <div>Mikrofon-Pegel</div>
        <div class="level-wrap"><div id="diag-level" class="level-bar anim"></div></div>

        <div>Letzter Fehler</div>
        <div id="diag-last-error">–</div>

        <div>Ereignis-Log</div>
        <div id="diag-log" aria-live="polite"></div>
        <div style="grid-column:1 / span 2; display:flex; gap:8px; margin-top:8px;"><button id="diagStart" type="button">Diagnose starten</button><button id="diagStop" type="button">Diagnose stoppen</button></div>
      </div>
  </div>
</section>


<script id="diag-script">
  (function(){
    const $state = () => document.getElementById('diag-state');
    const $log = () => document.getElementById('diag-log');
    const $err = () => document.getElementById('diag-last-error');
    const $lvl = () => document.getElementById('diag-level');

    window.__memotag = window.__memotag || {};
    let audioCtx, analyser, micStream, rafId;
    let lowLevelStart = null;

    function ts(){
      const d = new Date();
      return d.toLocaleTimeString();
    }

    window.diagSetState = function(text, cls){
      const el = $state();
      if(!el) return;
      el.textContent = text;
      el.classList.remove('state-ok','state-warn','state-err');
      el.classList.add(cls || 'state-warn');
    }

    window.diagLog = function(msg){
      const el = $log();
      if(!el) return;
      const line = document.createElement('div');
      line.className = 'line';
      line.textContent = `[${ts()}] ${msg}`;
      el.prepend(line);
      const nodes = el.querySelectorAll('.line');
      if(nodes.length > 60) el.removeChild(nodes[nodes.length-1]);
    }

    window.diagError = function(msg){
      const el = $err();
      if(el) el.textContent = msg || '–';
      diagSetState('Fehler', 'state-err');
      diagLog('ERROR: ' + msg);
    }

    window.startMicMeter = async function(){
      try{
        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
          diagLog('getUserMedia nicht verfügbar');
          return;
        }
        micStream = await navigator.mediaDevices.getUserMedia({audio:true});
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        const source = audioCtx.createMediaStreamSource(micStream);
        source.connect(analyser);
        const data = new Uint8Array(analyser.fftSize);

        function tick(){
          analyser.getByteTimeDomainData(data);
          let sum = 0;
          for(let i=0;i<data.length;i++){ const v = (data[i]-128)/128; sum += v*v; }
          const rms = Math.sqrt(sum/data.length);
          const pct = Math.min(100, Math.max(0, Math.round(rms*180)));
          const bar = $lvl();
          if(bar){ bar.style.width = pct + '%'; }
          if(pct < 5){
            if(!lowLevelStart) lowLevelStart = performance.now();
            else if(performance.now() - lowLevelStart > 3000){
              diagLog('Hinweis: Sehr niedriger Pegel erkannt (Mikro weit weg? stumm?)');
              lowLevelStart = null;
            }
          } else {
            lowLevelStart = null;
          }
          rafId = requestAnimationFrame(tick);
        }
        tick();
        diagLog('Mic-Meter gestartet');
      }catch(e){
        diagError('Mic-Meter Fehler: ' + e.message);
      }
    }

    window.stopMicMeter = function(){
      if(rafId) cancelAnimationFrame(rafId);
      rafId = null;
      try { if(micStream){ micStream.getTracks().forEach(t=>t.stop()); } } catch(e){}
      try { if(audioCtx){ audioCtx.close(); } } catch(e){}
      const bar = $lvl();
      if(bar){ bar.style.width = '0%'; }
      diagLog('Mic-Meter gestoppt');
    }

    const _origInit = window.initSpeechRecognition;
    window.initSpeechRecognition = function(){
      if(typeof _origInit === 'function'){
        _origInit();
      }
      try{
        if(window.recognition){
          const r = window.recognition;
          r.onstart = ()=>{ diagSetState('läuft', 'state-ok'); diagLog('onstart'); };
          r.onaudiostart = ()=>{ diagLog('onaudiostart'); };
          r.onsoundstart = ()=>{ diagLog('onsoundstart'); };
          r.onspeechstart = ()=>{ diagSetState('Sprache erkannt', 'state-ok'); diagLog('onspeechstart'); };
          r.onspeechend = ()=>{ diagLog('onspeechend'); };
          r.onsoundend = ()=>{ diagLog('onsoundend'); };
          r.onaudioend = ()=>{ diagLog('onaudioend'); };
          const prevOnResult = r.onresult;
          r.onresult = (ev)=>{ diagLog('onresult (' + ev.results.length + ' Segmente)'); if(prevOnResult) prevOnResult(ev); };
          r.onerror = (ev)=>{ diagError(ev.error || 'Unbekannter Fehler'); try{ if(window.stopRecording) window.stopRecording(); }catch(e){} };
          r.onend = ()=>{
            diagLog('onend');
            if(window.isRecording){
              diagSetState('automatischer Neustart...', 'state-warn');
              try { r.start(); } catch(e) { diagLog('Restart Fehler: ' + e.message); }
            } else {
              diagSetState('beendet', 'state-warn');
            }
          };
        }
      }catch(e){
        diagError('Init-Hook Fehler: ' + e.message);
      }
    }

    window.__memotag.diag = { diagSetState, diagLog, diagError, startMicMeter, stopMicMeter };
  })();
</script>


<script id="override-start-stop">
// --- Override start/stop for Mic-Meter (wird jetzt nur von MediaRecorder benutzt) ---
// Die Logik in dieser Sektion wurde in die main-script Blöcke verschoben, um sie zu vereinfachen.
// Die ursprünglichen Funktionen 'startRecording' und 'stopRecording' im Haupt-Script wurden 
// durch die neuen MediaRecorder-Funktionen ersetzt. Diese Sektion wird nun entfernt, um 
// Redundanz zu vermeiden.
</script>

<script>

document.addEventListener('DOMContentLoaded', () => {
    const hash = location.hash;
    if (hash === '#new') {
        const b = document.getElementById('recordBtn');
        if (b) { b.scrollIntoView({behavior:'smooth', block:'center'}); b.focus(); }
    } else if (hash === '#entries') {
        const e = document.querySelector('.entries-section');
        if (e) e.scrollIntoView({behavior:'smooth', block:'start'});
    }
});

</script>
<script>

// ---- iOS Fallback: Audioaufnahme/-Upload + Transkription ----
function isIOS() {
    return /iPhone|iPad|iPod/i.test(navigator.userAgent);
}

function initIOSFallback() {
    // Diagnose-Log hinzufügen, um zu sehen, ob die Funktion aufgerufen wird
    try { if(window.__memotag?.diag) __memotag.diag.diagLog('Init: iOS Fallback (Status-Hinweis)'); } catch(_) {}
    // Zeige Hinweis für mobile Geräte
    const iosHint = document.getElementById('iosHint');
    if (iosHint) {
        // Wir nutzen die Tatsache aus, dass MediaRecorder auf iOS Safari nicht geht
        const hasMediaRecorder = !!(navigator.mediaDevices && window.MediaRecorder);
        if (!hasMediaRecorder) {
            iosHint.style.display = 'block';
        }
    }
}


async function fileToBase64(file) {
    const buf = await file.arrayBuffer();
    let binary = '';
    const bytes = new Uint8Array(buf);
    const chunkSize = 0x8000;
    for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.subarray(i, i + chunkSize);
        // String.fromCharCode.apply(null, chunk) ist langsam und kann zu Stack Overflow führen.
        // Besser: TextDecoder verwenden
        binary += String.fromCharCode.apply(null, chunk);
    }
    return btoa(binary);
}


function normalizeMime(file) {
    const t = (file.type || '').toLowerCase();
    if (t) return t;
    const name = (file.name || '').toLowerCase();
    if (name.endsWith('.m4a')) return 'audio/mp4';
    if (name.endsWith('.mp3')) return 'audio/mpeg';
    if (name.endsWith('.wav')) return 'audio/wav';
    if (name.endsWith('.ogg')) return 'audio/ogg';
    if (name.endsWith('.webm')) return 'audio/webm';
    return 'application/octet-stream';
}


async function transcribeAudio(file, apiKey, provider) {
    // Size guard (most APIs support at least ~20-25MB; keep it conservative)
    const maxMB = 20;
    if (file.size > maxMB * 1024 * 1024) {
        throw new Error(`Audiodatei ist größer als ${maxMB} MB.`);
    }

    if (provider === 'openai') {
        const url = 'https://api.openai.com/v1/audio/transcriptions';
        const form = new FormData();
        form.append('file', file, file.name || 'audio.m4a');
        form.append('model', 'whisper-1');
        form.append('language', 'de');
        const resp = await fetch(url, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${apiKey}` },
            body: form
        });
        const data = await resp.json();
        if (!resp.ok) {
            const msg = data.error?.message || 'Unbekannter Fehler';
            throw new Error(`OpenAI-Fehler (${resp.status}): ${msg}`);
        }
        return data.text || '';
    }

    if (provider === 'anthropic') {
        // Claude Messages API mit input_audio Block
        const url = 'https://api.anthropic.com/v1/messages';
        const b64 = await fileToBase64(file);
        const mime = normalizeMime(file);
        const body = {
            model: 'claude-3-5-haiku-latest',
            max_tokens: 2000,
            system: 'Du bist ein präziser Transkriptionsassistent. Transkribiere nur den gesprochenen deutschen Text, ohne Zusatz.',
            messages: [{
                role: 'user',
                content: [
                    { type: 'text', text: 'Transkribiere dieses Audio auf Deutsch.' },
                    { type: 'input_audio', audio: { type: 'base64', data: b64, media_type: mime } }
                ]
            }]
        };
        const resp = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': apiKey,
                'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify(body)
        });
        const data = await resp.json();
        if (!resp.ok) {
            const msg = data.error?.message || data.error?.type || 'Unbekannter Fehler';
            throw new Error(`Anthropic-Fehler (${resp.status}): ${msg}`);
        }
        // Response: content is an array of blocks; find text
        const block = (data.content || []).find(b => b.type === 'text');
        return (block && block.text) || '';
    }

    if (provider === 'gemini') {
        // Gemini: generateContent mit inlineData
        const mime = normalizeMime(file);
        const b64 = await fileToBase64(file);
        // Modell auf ein unterstütztes Multimodal-Modell aktualisiert (gemini-2.5-flash)
        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
        const body = {
            contents: [{
                parts: [
                    { text: 'Transkribiere dieses Audio auf Deutsch. Antworte nur mit dem reinen Transkript.' },
                    { inlineData: { mimeType: mime, data: b64 } }
                ]
            }],
            generationConfig: { maxOutputTokens: 2000 }
        };
        const resp = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });
        const data = await resp.json();
        if (!resp.ok) {
            const msg = data.error?.message || 'Unbekannter Fehler';
            throw new Error(`Gemini-Fehler (${resp.status}): ${msg}`);
        }
        const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
        return text;
    }

    throw new Error('Unbekannter KI-Anbieter für Audio-Transkription.');
}
// 
// 


// Hook in nach DOMContentLoaded (wurde in main-script verschoben)
// document.addEventListener('DOMContentLoaded', initIOSFallback);

</script>
<script>

// ---- MediaRecorder Fallback (Desktop): Direktaufnahme am PC ----
// Entfernte die Deklaration von __mr, __mrStream, __mrChunks, __mrRecording, da sie im Hauptskript deklariert sind.
function stopStream(stream){ try{ if(stream) stream.getTracks().forEach(t=>t.stop()); }catch(_){} }

function initMediaRecorderFallback(){
    // Diagnose-Log hinzufügen, um zu sehen, ob die Funktion aufgerufen wird
    try { if(window.__memotag?.diag) window.__memotag.diag.diagLog('Init: MediaRecorder Fallback (PC Aufnahme)'); } catch(_) {}

    // Die Logik für den Klick wird jetzt direkt in toggleRecording behandelt
}

// Hook in nach DOMContentLoaded (wurde in main-script verschoben)
// document.addEventListener('DOMContentLoaded', initMediaRecorderFallback);

</script>
</body>
</html>
