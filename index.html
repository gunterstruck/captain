<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="manifest" href="/captain/manifest.webmanifest">
    <meta name="theme-color" content="#4F46E5">

    <meta name="description" content="Sprach-Tagebuch mit KI-Zusammenfassungen und Bild-Notizen">
    <title>Synaptic Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        .header,
        .record-section,
        .entries-section {
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 12px; 
            padding: 20px;
        }
        
        .record-section {
            padding: 30px;
            text-align: center;
        }
        
        .header {
             padding: 20px;
        }
        
        .entries-section {
             padding: 20px;
        }

        h1 {
            color: #4F46E5;
            font-size: 28px;
            margin-bottom: 15px;
            overflow-wrap: break-word;
            cursor: pointer; 
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .settings-icon {
            font-size: 20px;
            color: #4F46E5;
            transition: transform 0.3s;
        }

        .header:not(.expanded) .settings-icon {
            transform: rotate(-90deg);
        }
        .header.expanded .settings-icon {
            transform: rotate(0deg);
        }


        .api-setup {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            transition: max-height 0.5s ease-out, opacity 0.5s ease-out, padding 0.5s ease-out, margin-bottom 0.5s ease-out;
            overflow: hidden;
            max-height: 500px; 
            opacity: 1;
        }
        
        .api-setup .input-group input,
        .api-setup .input-group select {
            background-color: #F3F4F6;
        }


        .api-setup.collapsed {
            max-height: 0 !important;
            opacity: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            margin-bottom: 0 !important;
        }

        .input-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            font-size: 14px;
            color: #374151;
            margin-bottom: 5px;
            font-weight: 500;
        }

        input[type="text"], input[type="password"], select, textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #E5E7EB;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #4F46E5;
        }
        
        .record-button {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            font-size: 48px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px auto 10px;
        }

        .record-button:hover {
            transform: scale(1.05);
        }

        .record-button:focus {
            outline: 3px solid #818CF8;
            outline-offset: 3px;
        }

        .record-button.recording {
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
            animation: pulse 1.5s infinite;
        }
        
        #dictateEditBtn.recording {
            background: #EF4444;
            color: white;
            animation: pulse 1.5s infinite;
        }


        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .status {
            font-size: 16px;
            color: #6B7280;
            margin-top: 10px;
        }
        
        .processing {
            color: #4F46E5;
            font-weight: 601;
        }


        .transcript-section, .summary-section {
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            opacity: 0;
            height: 0;
            overflow: hidden;
            pointer-events: none;
            margin: 0;          
            padding: 0;
            transition: opacity 0.5s ease-in-out, height 0.5s ease-in-out, padding 0.5s ease-in-out, margin-bottom 0.5s ease-in-out;
        }

        .transcript-section.show, .summary-section.show {
            opacity: 1;
            height: auto;
            pointer-events: all;
            margin-bottom: 12px; 
            padding: 20px;
        }

        .section-title {
            font-size: 18px;
            color: #4F46E5;
            margin-bottom: 15px;
            font-weight: 600;
        }

        textarea {
            min-height: 150px;
            resize: vertical;
            font-family: inherit;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        button:focus {
            outline: 2px solid #4F46E5;
            outline-offset: 2px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex: 1;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-action {
            background: #4F46E5;
            color: white;
            flex: 1;
        }
        
        .btn-action:hover {
            background: #4338CA;
            box-shadow: 0 3px 10px rgba(79, 70, 229, 0.4);
        }


        .btn-secondary {
            background: #F3F4F6;
            color: #374151;
            flex: 1;
        }

        .btn-secondary:hover {
            background: #E5E7EB;
        }

        .btn-icon {
            background: #F3F4F6;
            color: #374151;
            padding: 10px 15px;
            flex: 1;
        }

        .btn-icon:hover {
            background: #E5E7EB;
        }
        
        .record-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 10px;
        }
        
        .record-actions button {
            padding: 8px 15px;
            font-size: 14px;
            flex: 0 0 auto;
        }

        .tags-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #F3F4F6;
        }
        
        .available-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: #F9FAFB;
            border-radius: 8px;
        }
        
        .tag-suggestion {
            background: #E0E7FF;
            color: #4F46E5;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .tag-suggestion:hover {
            background: #C7D2FE;
        }
        
        .tag-suggestion.active {
            background: #4F46E5;
            color: white;
            border-color: #4F46E5;
        }


        .tags-input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .tags-input-group input {
            flex: 1;
        }

        .tags-input-group button {
            flex: 0 0 auto;
        }

        .tag-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .tag {
            background: #EEF2FF;
            color: #4F46E5;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tag-remove {
            background: none;
            border: none;
            color: #4F46E5;
            cursor: pointer;
            padding: 0;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-size: 12px;
        }

        .tag-remove:hover {
            background: #4F46E5;
            color: white;
        }

        .entries-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .tag-filter {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .filter-tag {
            background: #F3F4F6;
            color: #374151;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .filter-tag:hover {
            background: #E5E7EB;
        }

        .filter-tag.active {
            background: #4F46E5;
            color: white;
            border-color: #4F46E5;
        }

        .selection-mode-btn {
            background: #4F46E5;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
        }

        .batch-actions {
            display: none;
            background: #FEF3C7;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            gap: 10px;
            flex-wrap: wrap;
        }

        .batch-actions.show {
            display: flex;
        }

        .batch-actions button {
            flex: 0 0 auto;
            padding: 8px 16px;
            font-size: 13px;
        }

        .entry {
            background: #F9FAFB;
            padding: 15px;
            border-left: 4px solid #4F46E5;
            position: relative;
            border-radius: 10px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .entry:hover {
            background-color: #F3F4F6;
        }
        
        .entry-actions button, .entry-checkbox, .entry-tags .tag {
            cursor: pointer;
        }


        .entry.selection-mode {
            padding-left: 50px;
        }

        .entry-checkbox {
            position: absolute;
            left: 15px;
            top: 20px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .entry-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
            gap: 10px;
        }

        .entry-date {
            font-size: 14px;
            color: #4F46E5;
            font-weight: 600;
        }

        .entry-location {
            font-size: 12px;
            color: #6B7280;
            margin-top: 2px;
        }

        .entry-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 8px 0;
        }

        .entry-text {
            color: #374151;
            line-height: 1.6;
            white-space: pre-wrap;
            margin-bottom: 10px;
        }

        .entry-text-wrapper {
            position: relative;
        }
        .entry-text.collapsed {
            max-height: 110px;
            overflow: hidden;
            transition: max-height 0.4s ease-out;
        }
        .entry-text-wrapper .expand-overlay {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: linear-gradient(to bottom, transparent, #F9FAFB);
            pointer-events: none;
            opacity: 1;
            transition: opacity 0.4s ease-out;
        }
        
        .entry.expanded .entry-text.collapsed {
            max-height: 1500px;
        }
        .entry.expanded .expand-overlay {
            opacity: 0;
        }
        
        .entry-image {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 10px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .entry-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            margin-top: 0;
            transition: max-height 0.4s ease-out, opacity 0.4s ease-out, margin-top 0.4s ease-out;
            pointer-events: none;
        }
        
        .entry.expanded .entry-actions {
            max-height: 200px;
            opacity: 1;
            margin-top: 15px;
            pointer-events: auto;
        }

        .entry-actions button {
            padding: 6px 12px;
            font-size: 12px;
        }
        
        .entry-text table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 14px;
        }
        .entry-text th, .entry-text td {
            border: 1px solid #E5E7EB;
            padding: 8px 12px;
            text-align: left;
        }
        .entry-text th {
            background-color: #F3F4F6;
            font-weight: 600;
        }
        .entry-text tr:nth-child(even) {
            background-color: #F9FAFB;
        }


        .delete-btn {
            background: #EF4444;
            color: white;
        }

        .delete-btn:hover {
            background: #DC2626;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #9CA3AF;
        }

        .loading {
            display: none;
            text-align: center;
            color: #6B7280;
            padding: 10px;
        }

        .loading.show {
            display: block;
        }

        .error {
            background: #FEE2E2;
            color: #991B1B;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            display: none;
        }

        .error.show {
            display: block;
        }

        .success {
            background: #D1FAE5;
            color: #065F46;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            display: none;
        }

        .success.show {
            display: block;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-close {
            background: #F3F4F6;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
        }
        
        #imagePreview {
            max-width: 100%;
            max-height: 200px; 
            margin: 15px auto 5px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            display: none;
        }


        @media (max-width: 640px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 22px;
            }
            
            .button-group, .reformulate-buttons {
                flex-direction: column;
            }
            
            .btn-icon {
                flex: 1 1 100%;
            }

            .tags-input-group {
                flex-direction: column;
            }

            .tags-input-group button {
                flex: 1 1 100%;
            }
            
            .record-actions {
                flex-direction: column;
            }
        }
    </style>

<style id="diag-styles">
  /* Diagnostik Styles (Collapsible) */
  .diag-card { 
      margin: 16px auto; 
      max-width: 900px; 
      background: rgba(255,255,255,0.9); 
      border-radius: 16px; 
      padding: 16px; 
      box-shadow: 0 6px 24px rgba(0,0,0,0.08); 
      margin-bottom: 12px !important; 
  }
  .diag-card h3 {
      cursor: pointer;
      margin-top: 0;
      margin-bottom: 0; 
      display: flex;
      align-items: center;
      justify-content: space-between;
  }
  .diag-card h3 .toggle-icon {
      font-size: 14px;
      transition: transform 0.3s;
      margin-left: 8px;
      transform: rotate(0deg);
  }
  .diag-card.collapsed h3 .toggle-icon {
      transform: rotate(-90deg);
  }

  .diag-content {
      transition: max-height 0.5s ease-in-out, opacity 0.5s ease-in-out, padding-top 0.5s ease-in-out;
      max-height: 1000px; 
      overflow: hidden;
      opacity: 1;
      padding-top: 16px;
  }
  .diag-card.collapsed .diag-content {
      max-height: 0;
      opacity: 0;
      padding-top: 0;
  }
    
  .diag-grid { display: grid; grid-template-columns: 160px 1fr; gap: 8px 16px; align-items: center; }
  .state-badge { display:inline-block; padding:4px 10px; border-radius:999px; font-size:12px; font-weight:600; }
  .state-ok { background:#e6f7ef; color:#0a7f4f; }
  .state-warn { background:#fff4e6; color:#a15a00; }
  .state-err { background:#ffe8e6; color:#b50000; }
  .level-wrap { width:100%; height:10px; background:#eee; border-radius:6px; overflow:hidden; }
  .level-bar.anim { background: linear-gradient(90deg, #a78bfa, #7c3aed); }
  #diag-log { max-height: 140px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:12px; background:#fafafa; border:1px solid #eee; border-radius:8px; padding:8px; }
  #diag-log .line { padding:2px 0; border-bottom:1px dashed #eee;}
  #diag-last-error { color:#b50000; font-weight:600; }
</style>

    <link rel="apple-touch-icon" href="/captain/icon-192-v2.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
</head>
<body>
    <div class="container">
        <div class="header collapsed" id="header">
            <h1 id="headerTitle">
                Synaptic Pro
                <span class="settings-icon" id="settingsIcon">⚙️</span>
            </h1>
            
            <div class="api-setup collapsed" id="apiSetup">
                <div class="input-group">
                    <label for="apiProvider">KI-Anbieter:</label>
                    <select id="apiProvider">
                        <option value="anthropic">Anthropic (Claude)</option>
                        <option value="openai">OpenAI (GPT)</option>
                        <option value="gemini">Google (Gemini)</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="apiKey">API-Schlüssel:</label>
                    <input type="password" id="apiKey" placeholder="Dein API-Schlüssel">
                </div>
                <div class="input-group">
                    <label>
                        <input type="checkbox" id="locationPermission">
                        Standort-Freigabe (optional)
                    </label>
                </div>
            </div>
        </div>

        <div class="record-section">
            <h2 class="section-title">Neue Notiz aufnehmen</h2>
            <button class="record-button" id="recordBtn" aria-label="Aufnahme starten">🎤</button>
            
            <img id="imagePreview" src="" alt="Hochgeladenes Bild" />

            <div class="record-actions">
                <button class="btn-secondary" id="imageUploadBtn">🖼️ Bild hochladen</button>
                <button class="btn-action" id="photoToNfcBtn">📷 Foto zu NFC</button>
                <input type="file" id="audioInput" accept="audio/*" capture="microphone" style="display:none;">
                <input type="file" id="imageInput" accept="image/*" style="display:none;">
                <input type="file" id="photoToNfcInput" accept="image/*" capture="camera" style="display:none;">
                
                <button class="btn-secondary" id="nfcBtn" style="display:none;">NFC-Tag lesen 📲</button>
            </div>


            <div id="iosHint" class="status" style="display:none;">Mobile Geräte erkannt: Tippe auf das Mikrofon-Symbol, um die Aufnahme zu starten oder eine Audiodatei auszuwählen.</div>
            
            <div class="status" id="status" role="status" aria-live="polite">Bereit zur Aufnahme</div>
        </div>

        <div class="transcript-section" id="transcriptSection">
            <h2 class="section-title" id="transcriptTitle">Transkription (Wird automatisch verarbeitet...)</h2>
            <textarea id="transcript" readonly aria-label="Transkribierter Text"></textarea>
            <div class="loading" id="loading" role="status">KI erstellt Zusammenfassung...</div>
            <div class="error" id="error" role="alert"></div>
        </div>

        <div class="summary-section" id="summarySection">
            <h2 class="section-title">Zusammenfassung</h2>
            <textarea id="summary" aria-label="Zusammenfassung bearbeiten"></textarea>
            
            <div class="tags-section">
                <label>Verfügbare Tags:</label>
                <div class="available-tags" id="availableTags">
                </div>

                <label>Tags hinzufügen:</label>
                <div class="tags-input-group">
                    <input type="text" id="newTag" placeholder="z.B. Arbeit, Einkauf, Idee...">
                    <button class="btn-secondary" id="addTagBtn">+ Tag</button>
                </div>
                <div class="tag-list" id="currentTags"></div>
            </div>

            <div class="button-group">
                <button class="btn-primary" id="saveBtn">Speichern</button>
                <button class="btn-action" id="writeNFCBtn" style="display:none;">Auf NFC-Tag speichern 📲</button>
                <button class="btn-icon" id="copyBtn">Kopieren</button>
                <button class="btn-icon" id="shareBtn">Teilen</button>
                <button class="btn-secondary" id="editCancelBtn">Abbrechen</button>
            </div>
            <div class="success" id="success" role="status"></div>
        </div>

        <div class="entries-section">
            <div class="entries-header">
                <h2 class="section-title">Meine Einträge</h2>
                <button class="selection-mode-btn" id="toggleSelectionBtn">Auswählen</button>
            </div>

            <div class="batch-actions" id="batchActions">
                <button class="btn-primary" id="summarizeSelectedBtn">Gesamt-Zusammenfassung</button>
                <button class="btn-primary" id="mergeSelectedBtn">Zusammenführen</button>
                <button class="btn-secondary" id="tagSelectedBtn">Tags setzen</button>
                <button class="btn-secondary" id="exportSelectedBtn">Exportieren</button>
                <button class="btn-secondary" id="shareSelectedBtn">Teilen</button>
                <button class="delete-btn" id="deleteSelectedBtn">Löschen</button>
            </div>

            <div class="tag-filter" id="tagFilter"></div>
            <div id="entries"></div>
        </div>
    </div>

    <!-- Edit Modal -->
    <div class="modal" id="editModal" role="dialog" aria-labelledby="editModalTitle">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="section-title" id="editModalTitle">Notiz bearbeiten</h2>
                <button class="modal-close" id="closeEditModal" aria-label="Schließen">✕</button>
            </div>
            <textarea id="editText" aria-label="Text bearbeiten"></textarea>
            <div class="tags-section">
                <label>Verfügbare Tags:</label>
                <div class="available-tags" id="editAvailableTags">
                </div>
                <label>Tags:</label>
                <div class="tags-input-group">
                    <input type="text" id="editNewTag" placeholder="Neuer Tag...">
                    <button class="btn-secondary" id="addEditTagBtn">+ Tag</button>
                </div>
                <div class="tag-list" id="editTags"></div>
            </div>
            <div class="loading" id="editDictateLoading" role="status">KI verarbeitet Diktat...</div>
            <div class="button-group">
                <button class="btn-icon" id="dictateEditBtn">🎤 Änderung diktieren</button>
                <button class="btn-primary" id="saveEditBtn">Speichern</button>
                <button class="btn-secondary" id="cancelEditBtn">Abbrechen</button>
            </div>
            <div class="error" id="editError" role="alert"></div>
            <div class="success" id="editSuccess" role="status"></div>
        </div>
    </div>

    <!-- Batch Summary Modal -->
    <div class="modal" id="batchSummaryModal" role="dialog" aria-labelledby="batchSummaryTitle">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="section-title" id="batchSummaryTitle">Ergebnis der Stapelaktion</h2>
                <button class="modal-close" id="closeBatchSummaryModal" aria-label="Schließen">✕</button>
            </div>
            <div class="loading show" id="batchSummaryLoading" role="status">KI erstellt Gesamt-Zusammenfassung...</div>
            <textarea id="batchSummaryText" style="display:none;" aria-label="Gesamt-Zusammenfassung"></textarea>
            <div class="button-group" id="batchSummaryActions" style="display:none;">
                <button class="btn-primary" id="saveBatchSummaryBtn">Als neue Notiz speichern</button>
                <button class="btn-icon" id="copyBatchSummaryBtn">Kopieren</button>
                <button class="btn-secondary" id="closeBatchSummaryBtn">Schließen</button>
            </div>
            <div class="success" id="batchSummarySuccess" role="status"></div>
        </div>
    </div>
    
    <!-- Confirmation Modal -->
    <div class="modal" id="confirmModal" role="dialog" aria-labelledby="confirmTitle">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="section-title" id="confirmTitle">Bestätigung</h2>
                <button class="modal-close" id="closeConfirmModal" aria-label="Schließen">✕</button>
            </div>
            <p id="confirmMessage" style="margin-bottom: 20px;">Sind Sie sicher?</p>
            <div class="button-group">
                <button class="btn-primary" id="confirmYesBtn">Ja</button>
                <button class="btn-secondary" id="confirmNoBtn">Nein</button>
            </div>
        </div>
    </div>

    <script>
        // MediaRecorder State
        let __mr, __mrStream, __mrChunks = [], __mrRecording = false;
        
        let isEditDictating = false;

        let recognition;
        let isRecording = false;
        let currentTranscript = '';
        let currentLocation = null;
        let currentTags = [];
        let currentImageBase64 = null;
        let selectionMode = false;
        let selectedEntries = new Set();
        let editingEntryId = null;
        let activeTagFilter = null;
        let confirmCallback = null;
        let isApiSetupExpanded = false;

        const DIARY_KEY = 'diary_entries_v2';

        document.addEventListener('DOMContentLoaded', () => {
            loadAPIKey();
            loadLocationPermission();
            
            migrateStripImages();
            
            loadEntries();
            setupEventListeners();
            updateAvailableTags(); 
            
            initMediaRecorderFallback();
            initIOSFallback();
            
            updateNFCButton();
            updateNFCWriteButton();

            document.getElementById('diagnostics').classList.add('collapsed');
            
        });
        
        function migrateStripImages() {
          const entries = getEntries();
          let changed = false;
          entries.forEach(e => {
            if (e.image) { 
              delete e.image; 
              changed = true; 
            }
          });
          if (changed) {
            console.log('Migration durchgeführt: Alte Bildeinträge entfernt.');
            saveEntries(entries);
          }
        }


        function getEntries() {
            const stored = localStorage.getItem(DIARY_KEY);
            let entries = stored ? JSON.parse(stored) : [];
            entries.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            return entries;
        }

        function saveEntries(entries) {
            localStorage.setItem(DIARY_KEY, JSON.stringify(entries));
            loadEntries();
            updateAvailableTags(); 
        }
        
        function toggleApiSetup() {
            isApiSetupExpanded = !isApiSetupExpanded;
            const setupEl = document.getElementById('apiSetup');
            const headerEl = document.getElementById('header');
            
            if (isApiSetupExpanded) {
                setupEl.classList.remove('collapsed');
                headerEl.classList.add('expanded');
                headerEl.classList.remove('collapsed');
            } else {
                setupEl.classList.add('collapsed');
                headerEl.classList.remove('expanded');
                headerEl.classList.add('collapsed');
            }
        }
        
        function checkAndSetApiSetupState() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const setupEl = document.getElementById('apiSetup');
            const headerEl = document.getElementById('header');
            
            if (apiKey && apiKey.length > 0) {
                isApiSetupExpanded = false; 
                setupEl.classList.add('collapsed');
                headerEl.classList.add('collapsed');
                headerEl.classList.remove('expanded'); 
            } else {
                isApiSetupExpanded = true; 
                setupEl.classList.remove('collapsed');
                headerEl.classList.remove('collapsed');
                headerEl.classList.add('expanded');
            }
        }
        
        function toggleDiagnostics() {
            const diag = document.getElementById('diagnostics');
            diag.classList.toggle('collapsed');
        }


        function setupEventListeners() {
            document.getElementById('headerTitle').addEventListener('click', toggleApiSetup);
            document.getElementById('diagHeader').addEventListener('click', toggleDiagnostics);
            
            document.getElementById('apiKey').addEventListener('change', saveAPIKey);
            document.getElementById('apiProvider').addEventListener('change', saveAPIKey);
            document.getElementById('recordBtn').addEventListener('click', toggleRecording);
            
            document.getElementById('saveBtn').addEventListener('click', saveEntry);
            document.getElementById('editCancelBtn').addEventListener('click', resetForm);
            
            document.getElementById('locationPermission').addEventListener('change', handleLocationPermission);
            
            document.getElementById('addTagBtn').addEventListener('click', addCurrentTag);
            document.getElementById('newTag').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addCurrentTag();
            });

            document.getElementById('copyBtn').addEventListener('click', copyToClipboard);
            document.getElementById('shareBtn').addEventListener('click', shareContent);
            document.getElementById('summary').addEventListener('input', updateNFCWriteButton);

            document.getElementById('toggleSelectionBtn').addEventListener('click', toggleSelectionMode);
            
            document.getElementById('summarizeSelectedBtn').addEventListener('click', summarizeSelected);
            document.getElementById('mergeSelectedBtn').addEventListener('click', mergeSelected);
            document.getElementById('tagSelectedBtn').addEventListener('click', tagSelected);
            document.getElementById('exportSelectedBtn').addEventListener('click', exportSelected);
            document.getElementById('shareSelectedBtn').addEventListener('click', shareSelected);
            document.getElementById('deleteSelectedBtn').addEventListener('click', deleteSelected);

            document.getElementById('closeEditModal').addEventListener('click', closeEditModal);
            document.getElementById('cancelEditBtn').addEventListener('click', closeEditModal);
            document.getElementById('saveEditBtn').addEventListener('click', saveEditedEntry);
            document.getElementById('addEditTagBtn').addEventListener('click', addEditTag);
            document.getElementById('editNewTag').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addEditTag();
            });
            
            document.getElementById('dictateEditBtn').addEventListener('click', toggleEditDictation);

            document.getElementById('closeBatchSummaryModal').addEventListener('click', closeBatchSummaryModal);
            document.getElementById('closeBatchSummaryBtn').addEventListener('click', closeBatchSummaryModal);
            document.getElementById('saveBatchSummaryBtn').addEventListener('click', saveBatchSummary);
            document.getElementById('copyBatchSummaryBtn').addEventListener('click', copyBatchSummary);
            
            document.getElementById('confirmYesBtn').addEventListener('click', () => {
                if (confirmCallback) {
                    const cb = confirmCallback;
                    closeConfirmModal();
                    cb();
                } else {
                    closeConfirmModal();
                }
            });
            document.getElementById('confirmNoBtn').addEventListener('click', closeConfirmModal);
            document.getElementById('closeConfirmModal').addEventListener('click', closeConfirmModal);

            const audioInput = document.getElementById('audioInput');
            audioInput.addEventListener('change', handleAudioFileSelection);
            
            const imageInput = document.getElementById('imageInput');
            document.getElementById('imageUploadBtn').addEventListener('click', () => {
                resetForm();
                imageInput.click();
            });
            imageInput.addEventListener('change', handleImageFileSelection);

            document.getElementById('photoToNfcBtn').addEventListener('click', () => {
                document.getElementById('photoToNfcInput').click();
            });
            document.getElementById('photoToNfcInput').addEventListener('change', handlePhotoToNfc);
            
            const nfcBtn = document.getElementById('nfcBtn');
            if (nfcBtn) nfcBtn.addEventListener('click', readNFC);
            
            const writeNFCBtn = document.getElementById('writeNFCBtn');
            if (writeNFCBtn) writeNFCBtn.addEventListener('click', writeNFC);
        }
        
        function updateNFCWriteButton() {
            const writeNFCBtn = document.getElementById('writeNFCBtn');
            if (!writeNFCBtn) return;
            
            const isNFCSupported = ('NDEFReader' in window);
            const hasText = document.getElementById('summary').value.trim().length > 0;
            
            if (isNFCSupported && hasText) {
                writeNFCBtn.style.display = 'inline-flex';
                writeNFCBtn.disabled = false;
            } else {
                writeNFCBtn.style.display = 'none';
                writeNFCBtn.disabled = true;
            }
        }


        function initSpeechRecognition() {} 
        
        function updateNFCButton() {
            const nfcBtn = document.getElementById('nfcBtn');
            if (nfcBtn && ('NDEFReader' in window)) {
                nfcBtn.style.display = 'inline-flex';
            } else if (nfcBtn) {
                nfcBtn.style.display = 'none';
            }
        }
        
        async function writeTextToNFC(textToWrite, buttonEl = null) {
            if (!('NDEFReader' in window)) {
                showError('NFC-Schreiben wird von diesem Gerät/Browser nicht unterstützt.');
                return false;
            }

            if (!textToWrite) {
                showError('Kein Text zum Schreiben auf den NFC-Tag vorhanden.');
                return false;
            }
            
            let originalText = buttonEl ? buttonEl.textContent : 'Auf NFC-Tag speichern 📲';
            
            showSuccess('NFC-Tag zum Beschreiben bereithalten...');

            try {
                const ndef = new NDEFReader();
                await ndef.write(textToWrite);
                showSuccess('Daten erfolgreich auf NFC-Tag geschrieben!');
                return true;
                
            } catch (error) {
                let errMsg = `Fehler beim Schreiben: ${error.message}`;
                if (error.name === 'NotAllowedError') errMsg = 'NFC-Zugriff verweigert oder Tag nicht rechtzeitig gescannt.';
                else if (error.name === 'NotSupportedError') errMsg = 'Tag ist schreibgeschützt oder hat nicht genug Speicher.';
                showError(errMsg);
                return false;
            }
        }

        async function writeNFC() {
            const textToWrite = document.getElementById('summary').value.trim();
            const btn = document.getElementById('writeNFCBtn');
            await writeTextToNFC(textToWrite, btn);
        }

        async function writeEntryToNFC(id, buttonEl) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry || !entry.text) {
                showError('Eintrag nicht gefunden oder leer.');
                return;
            }
            await writeTextToNFC(entry.text, buttonEl);
        }
        
        function convertKeyValueToMarkdownTable(text) {
            const lines = text.trim().split('\n');
            let markdown = '| Merkmal | Wert |\n|---|---|\n';
            lines.forEach(line => {
                const parts = line.split(':');
                const key = parts[0] ? parts[0].trim() : '';
                const value = parts.length > 1 ? parts.slice(1).join(':').trim() : '';
                if (key) {
                    markdown += `| ${key} | ${value} |\n`;
                }
            });
            return markdown;
        }


        async function readNFC() {
            if (!('NDEFReader' in window)) {
                showError('NFC-Lesen wird von diesem Gerät/Browser nicht unterstützt.');
                return;
            }
            
            resetForm();
            updateRecordButton('NFC: Warte auf Tag-Scan...', 'processing');
            
            try {
                const ndef = new NDEFReader();
                await ndef.scan();
                
                ndef.onreadingerror = (e) => {
                    if (document.getElementById('status').textContent.includes('NFC')) {
                        showError('NFC Lese-Fehler: Tag ungültig, leer, oder Scan abgebrochen.');
                        updateRecordButton('Bereit zur Aufnahme');
                    }
                };

                ndef.onreading = (e) => {
                    try { ndef.cancelScan(); } catch (_) {}
                    
                    const record = e.message.records[0];
                    if (record && record.recordType === 'text') {
                        const decoder = new TextDecoder();
                        const text = decoder.decode(record.data);
                        processNFCReadout(text);
                    } else {
                        showError('NFC-Tag enthält keinen lesbaren Text.');
                        updateRecordButton('Bereit zur Aufnahme');
                    }
                };
                
            } catch (error) {
                const errMsg = `NFC-Fehler: ${error.message}`;
                showError(errMsg);
                updateRecordButton('Bereit zur Aufnahme');
            }
        }
        
        async function processNFCReadout(text) {
             let processedText = text;
             const isCompactFormat = text.includes('\n') && text.includes(':') && !text.includes('|---');

             if (isCompactFormat) {
                 try {
                     processedText = convertKeyValueToMarkdownTable(text);
                     showSuccess('Kompaktdaten vom NFC-Tag erkannt und in Tabelle umgewandelt.');
                 } catch (e) {
                     console.error("Fehler beim Umwandeln des NFC-Textes in eine Tabelle:", e);
                     processedText = text;
                 }
             }

             currentTranscript = processedText;
             const t = document.getElementById('transcript');
             if (t) t.value = currentTranscript;
             
             document.getElementById('transcriptTitle').textContent = 'NFC-Text (Wird automatisch verarbeitet...)';
             const ts = document.getElementById('transcriptSection');
             if (ts) ts.classList.add('show');
             
             document.getElementById('status').textContent = 'NFC-Inhalt erfasst. Erstelle Zusammenfassung...';
             await summarize(currentTranscript, null);
        }

        async function handleImageFileSelection(e) {
            const file = e.target.files && e.target.files[0];
            if (!file) return;

            const imagePreview = document.getElementById('imagePreview');
            const reader = new FileReader();

            reader.onload = async (event) => {
                imagePreview.src = event.target.result;
                imagePreview.style.display = 'block';
                
                currentImageBase64 = event.target.result; 
                
                document.getElementById('transcriptTitle').textContent = 'Bild-Beschreibung (Wird automatisch verarbeitet...)';
                document.getElementById('transcriptSection').classList.add('show');
                document.getElementById('status').textContent = 'Bild hochgeladen. Erstelle Beschreibung...';
                document.getElementById('status').classList.add('processing');
                
                try {
                    await summarize(null, file);
                } finally {
                    document.getElementById('status').classList.remove('processing');
                    imagePreview.src = '';
                    imagePreview.style.display = 'none';
                    currentImageBase64 = null; 
                }
                
                document.getElementById('transcriptSection').classList.remove('show');
            };

            reader.onerror = () => {
                showError('Fehler beim Lesen der Datei.');
                resetForm();
            };

            reader.readAsDataURL(file);
        }
        
        async function handlePhotoToNfc(e) {
            const file = e.target.files && e.target.files[0];
            if (!file) return;

            updateRecordButton('Foto wird analysiert...', 'processing');
            showSuccess('Foto wird analysiert, bitte warten...');

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            if (!apiKey) {
                showError('Bitte gib einen API-Schlüssel ein.');
                resetForm();
                return;
            }

            const extractionPrompt = `Analysiere das Bild. Extrahiere die Werte für die folgenden Merkmale. Gib deine Antwort NUR als Liste von "Merkmal:Wert"-Paaren zurück, wobei jedes Paar in einer neuen Zeile steht. Lasse den Wert leer, wenn er nicht gefunden wird. Füge KEINE zusätzlichen Erklärungen, Kommentare oder Formatierungen wie Markdown hinzu.

HK.Nr.:
KKS:
Leistung:
Strom:
Spannung:
Widerstand:
Regler:
Sicherheitsregler/Begrenzer:
Wächter:
Projekt Nr.:
Anzahl Heizkabeleinheiten:
Trennkasten:
Heizkabeltyp:
Schaltung:
Meßwertgeber:
PT 100:
NiCr-Ni:
geprüft von:
am:`;
            
            const systemInstruction = "Du bist ein präziser Datenextraktions-Assistent. Deine einzige Aufgabe ist es, Daten aus einem Bild zu extrahieren und sie in dem vom Benutzer vorgegebenen kompakten Key-Value-Format zurückzugeben.";

            try {
                const compactData = await callLLMAPI(extractionPrompt, apiKey, provider, 0, file, systemInstruction);
                
                if (!compactData || !compactData.includes(':')) {
                    throw new Error("Die KI hat keine gültigen Daten zurückgegeben.");
                }

                updateRecordButton('Analyse fertig. Schreibe auf NFC...', 'processing');
                const writeSuccess = await writeTextToNFC(compactData);
                
                if (writeSuccess) {
                    showSuccess('Daten erfolgreich auf NFC-Tag geschrieben!');
                }

            } catch (error) {
                showError('Fehler beim Extrahieren der Daten: ' + error.message);
            } finally {
                resetForm();
                e.target.value = '';
            }
        }


        async function imageToText(file, apiKey, provider) {
            const maxMB = 5;
            if (file.size > maxMB * 1024 * 1024) {
                throw new Error(`Bilddatei ist größer als ${maxMB} MB.`);
            }

            if (provider === 'openai' || provider === 'anthropic' || provider === 'gemini') {
                return callLLMAPI('Beschreibe dieses Bild detailliert.', apiKey, provider, 0, file);
            }

            throw new Error('Der ausgewählte KI-Anbieter unterstützt möglicherweise keine Bildanalyse.');
        }


        function toggleRecording() {
            if (isRecording) {
                stopMediaRecorder();
                isRecording = false;
                updateRecordButton('Bereit zur Aufnahme');
            } else {
                resetForm();
                startMediaRecorder().then(success => {
                    if (success) {
                        isRecording = true;
                        updateRecordButton('Aufnahme läuft...');
                    }
                });
            }
        }
        
        async function startMediaRecorder(onStopCallback = processAudioRecording) {
            try{
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                __mrStream = stream;
                
                const mime = MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' :
                             (MediaRecorder.isTypeSupported('audio/ogg') ? 'audio/ogg' : 
                             (MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4' : ''));

                if (!mime) {
                    showError('Ihr Browser unterstützt keine MediaRecorder-Formate für Audio.');
                    stopStream(__mrStream);
                    return false;
                }

                __mr = new MediaRecorder(stream, { mimeType: mime });
                __mrChunks = [];
                __mr.ondataavailable = e => { 
                    if(e.data && e.data.size > 0) __mrChunks.push(e.data); 
                };
                
                __mr.onerror = (e) => {
                    showError('Aufnahmefehler: ' + e.error.name, isEditDictating ? 'editError' : 'error');
                    stopStream(__mrStream);
                    __mrRecording = false;
                    isRecording = false;
                    isEditDictating = false;
                    updateRecordButton('Fehler.');
                    document.getElementById('dictateEditBtn').classList.remove('recording');
                };

                __mr.onstop = onStopCallback;

                __mr.start(500); 
                __mrRecording = true;
                return true;

            } catch(err){
                const errMsg = err.name === 'NotAllowedError' ? 'Mikrofonzugriff verweigert.' : (err.message || err);
                showError('Zugriff auf Mikrofon fehlgeschlagen: ' + errMsg, isEditDictating ? 'editError' : 'error');
                updateRecordButton('Bereit zur Aufnahme');
                return false;
            }
        }
        
        function stopMediaRecorder() {
            try{ 
                if (__mr && __mr.state === 'recording') {
                    __mr.stop(); 
                }
            }catch(_){}
            stopStream(__mrStream);
            __mrRecording = false;
        }

        async function processAudioRecording() {
            try{
                const blobType = __mr && __mr.mimeType ? __mr.mimeType : 'audio/webm';
                const blob = new Blob(__mrChunks, { type: blobType });
                const file = new File([blob], 'aufnahme.' + (blobType.includes('ogg') ? 'ogg' : 'webm'), { type: blobType });
                
                await processAudioFile(file);

            }catch(err){
                showError('Verarbeitung fehlgeschlagen: ' + (err.message || err));
                resetForm();
            }
        }
        
        async function processAudioFile(file) {
            document.getElementById('status').textContent = 'Audio-Datei gesendet. Warte auf KI-Transkription...';
            document.getElementById('status').classList.add('processing');
            document.getElementById('transcriptTitle').textContent = 'Transkription (Wird automatisch verarbeitet...)';
            
            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            if(!apiKey){ 
                showError('Bitte gib einen API-Schlüssel ein.'); 
                resetForm();
                return; 
            }
            
            let transcript;
            try {
                transcript = await transcribeAudio(file, apiKey, provider);
                currentTranscript = transcript || '';
                
                const t = document.getElementById('transcript');
                if (t) t.value = currentTranscript;
                const ts = document.getElementById('transcriptSection');
                if (ts) ts.classList.add('show');

            } catch(err) {
                 const errorMessage = 'Transkription fehlgeschlagen: ' + (err.message || err);
                showError(errorMessage);
                resetForm();
                return;
            }

            document.getElementById('status').textContent = 'Transkription abgeschlossen. Erstelle Zusammenfassung...';
            await summarize(currentTranscript, null);
            document.getElementById('status').classList.remove('processing');
        }


        async function handleAudioFileSelection(e) {
            const file = e.target.files && e.target.files[0];
            if (!file) return;

            if (!window.MediaRecorder) {
                await processAudioFile(file);
            }
        }

        function initMediaRecorderFallback(){ }
        function initIOSFallback() {
            const iosHint = document.getElementById('iosHint');
            const audioInput = document.getElementById('audioInput');
            if (iosHint && !window.MediaRecorder) {
                iosHint.style.display = 'block';
                document.getElementById('recordBtn').addEventListener('click', (e) => {
                    e.preventDefault();
                    if (!isRecording) {
                        audioInput.click();
                    }
                });
            }
        }
        
        function stopStream(stream){ 
            try{ if(stream) stream.getTracks().forEach(t=>t.stop()); }catch(_){} 
        }
        
        function updateRecordButton(statusText) {
            const btn = document.getElementById('recordBtn');
            const status = document.getElementById('status');
            const imgBtn = document.getElementById('imageUploadBtn');
            const nfcBtn = document.getElementById('nfcBtn');
            const photoToNfcBtn = document.getElementById('photoToNfcBtn');


            if (status) status.textContent = statusText;

            if (statusText.includes('Aufnahme läuft')) {
                if (btn) {
                    btn.classList.add('recording');
                    btn.textContent = '⏹️';
                    btn.setAttribute('aria-label', 'Aufnahme stoppen');
                }
            } else {
                 if (btn) {
                    btn.classList.remove('recording');
                    btn.textContent = '🎤';
                    btn.setAttribute('aria-label', 'Aufnahme starten');
                }
            }

            const isProcessing = statusText.includes('Warte auf KI') || 
                                 statusText.includes('Erstelle Zusammenfassung') || 
                                 statusText.includes('Verarbeite') || 
                                 statusText.includes('NFC') ||
                                 statusText.includes('analysiert') ||
                                 statusText.includes('Analyse') ||
                                 statusText.includes('Beschreibung');

            if (isProcessing) {
                 if (status) status.classList.add('processing');
                 if (btn) btn.disabled = true;
                 if (imgBtn) imgBtn.disabled = true;
                 if (nfcBtn) nfcBtn.disabled = true;
                 if (photoToNfcBtn) photoToNfcBtn.disabled = true;


            } else {
                 if (status) status.classList.remove('processing');
                 if (btn) btn.disabled = false;
                 if (imgBtn) imgBtn.disabled = false;
                 if (nfcBtn) nfcBtn.disabled = false;
                 if (photoToNfcBtn) photoToNfcBtn.disabled = false;
            }
        }


        function getCurrentLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        currentLocation = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude
                        };
                    },
                    (error) => {
                        console.error('Location error:', error);
                        currentLocation = null;
                    }
                );
            }
        }

        function saveLocationPermission(isChecked) {
            localStorage.setItem('location_permission', isChecked ? 'true' : 'false');
        }

        function loadLocationPermission() {
            const permissionCheckbox = document.getElementById('locationPermission');
            const storedValue = localStorage.getItem('location_permission');
            
            if (storedValue === 'true') {
                permissionCheckbox.checked = true;
            } else {
                permissionCheckbox.checked = false;
            }
        }
        
        function handleLocationPermission() {
            const permissionCheckbox = document.getElementById('locationPermission');
            const isChecked = permissionCheckbox.checked;

            saveLocationPermission(isChecked);

            if (isChecked) {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        () => {},
                        (error) => {
                            console.error('Location permission denied:', error);
                            permissionCheckbox.checked = false;
                            saveLocationPermission(false);
                            showError('Standort-Berechtigung wurde verweigert oder ist nicht verfügbar.');
                        }
                    );
                } else {
                    showError('Geolocation wird von diesem Browser nicht unterstützt.');
                    permissionCheckbox.checked = false;
                    saveLocationPermission(false);
                }
            }
        }

        async function summarize(transcript, imageFile) {
            if (!transcript && !imageFile) { 
                showError('Kein Transkript oder Bild vorhanden.'); 
                resetForm();
                return; 
            }

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { 
                showError('Bitte gib einen API-Schlüssel ein.'); 
                resetForm();
                return; 
            }

            document.getElementById('loading').classList.add('show');
            document.getElementById('error').classList.remove('show');
            document.getElementById('summarySection').classList.add('show');
            
            if (imageFile) {
                 document.getElementById('status').textContent = 'KI erstellt Bildbeschreibung...';
            } else if (transcript) {
                 document.getElementById('status').textContent = 'KI erstellt Zusammenfassung...';
            }

            try {
                let summary = '';
                if (imageFile) {
                    summary = await imageToText(imageFile, apiKey, provider);
                } else if (transcript) {
                    summary = await callLLMAPI(transcript, apiKey, provider);
                }

                document.getElementById('summary').value = summary;
                document.getElementById('loading').classList.remove('show');
                
                updateRecordButton(imageFile ? 'Bildbeschreibung fertig!' : 'Zusammenfassung fertig!');
                
                currentTags = [];
                updateCurrentTags();
                updateNFCWriteButton();
                
            } catch (error) {
                const errorMessage = 'Fehler beim Erstellen der Notiz: ' + error.message;
                showError(errorMessage);
                document.getElementById('loading').classList.remove('show');
                resetForm();
            }
        }

        function addCurrentTag() {
            const tagInput = document.getElementById('newTag');
            const tag = tagInput.value.trim();
            if (tag && !currentTags.includes(tag)) {
                currentTags.push(tag);
                updateCurrentTags();
                tagInput.value = '';
            }
        }

        function updateCurrentTags() {
            const container = document.getElementById('currentTags');
            container.innerHTML = '';
            currentTags.forEach(tag => {
                const wrap = document.createElement('div');
                wrap.className = 'tag';
                const txt = document.createElement('span');
                txt.textContent = tag;
                const btn = document.createElement('button');
                btn.className = 'tag-remove';
                btn.textContent = '×';
                btn.setAttribute('aria-label', `Tag ${tag} entfernen`);
                btn.addEventListener('click', () => removeCurrentTag(tag));
                wrap.appendChild(txt);
                wrap.appendChild(btn);
                container.appendChild(wrap);
            });
            updateAvailableTags();
        }

        function removeCurrentTag(tag) {
            currentTags = currentTags.filter(t => t !== tag);
            updateCurrentTags();
        }
        
        function updateAvailableTags() {
            const allEntries = getEntries();
            const allTags = new Set();
            allEntries.forEach(entry => {
                if (entry.tags) entry.tags.forEach(tag => allTags.add(tag));
            });

            const container = document.getElementById('availableTags');
            renderTagSuggestions(container, allTags, tag => {
                if (!currentTags.includes(tag)) {
                    currentTags.push(tag);
                } else {
                    currentTags = currentTags.filter(t => t !== tag);
                }
                updateCurrentTags();
            }, currentTags);
            
            const editContainer = document.getElementById('editAvailableTags');
            const tagsForEditModal = editingEntryId ? getEntries().find(e => e.id === editingEntryId)?.tags || [] : currentTags;
            renderTagSuggestions(editContainer, allTags, tag => {
                if (!currentTags.includes(tag)) {
                    currentTags.push(tag);
                } else {
                    currentTags = currentTags.filter(t => t !== tag);
                }
                updateEditTags();
            }, tagsForEditModal);

            updateTagFilter(allEntries);
        }

        function renderTagSuggestions(container, tags, clickHandler, activeTags) {
            container.innerHTML = '';
            Array.from(tags).sort().forEach(tag => {
                const tagEl = document.createElement('div');
                tagEl.className = `tag-suggestion ${activeTags.includes(tag) ? 'active' : ''}`;
                tagEl.textContent = tag;
                tagEl.addEventListener('click', () => clickHandler(tag));
                container.appendChild(tagEl);
            });
        }


        function addEditTag() {
            const tagInput = document.getElementById('editNewTag');
            const tag = tagInput.value.trim();
            if (tag && !currentTags.includes(tag)) {
                currentTags.push(tag);
                updateEditTags();
                tagInput.value = '';
            }
        }

        function updateEditTags() {
            const container = document.getElementById('editTags');
            container.innerHTML = '';
            currentTags.forEach(tag => {
                const wrap = document.createElement('div');
                wrap.className = 'tag';
                const txt = document.createElement('span');
                txt.textContent = tag;
                const btn = document.createElement('button');
                btn.className = 'tag-remove';
                btn.textContent = '×';
                btn.setAttribute('aria-label', `Tag ${tag} entfernen`);
                btn.addEventListener('click', () => removeEditTag(tag));
                wrap.appendChild(txt);
                wrap.appendChild(btn);
                container.appendChild(wrap);
            });
            updateAvailableTags();
        }

        function removeEditTag(tag) {
            currentTags = currentTags.filter(t => t !== tag);
            updateEditTags();
        }

        function saveEntry() {
            const summary = document.getElementById('summary').value.trim();

            if (!summary) { 
                showError('Bitte gib Text ein (Zusammenfassung).');
                return;
            }

            const entries = getEntries();
            const newEntry = {
                id: Date.now().toString(),
                text: summary || '',
                image: null,
                tags: [...currentTags], 
                location: currentLocation,
                timestamp: new Date().toISOString(),
                transcript: currentTranscript || '' 
            };

            entries.unshift(newEntry);
            saveEntries(entries);

            showSuccess('Notiz gespeichert!');
            resetForm(); 
        }

        function deleteEntry(id) {
            showConfirmModal('Eintrag wirklich löschen?', () => {
                const entries = getEntries().filter(e => e.id !== id);
                saveEntries(entries);
                showSuccess('Eintrag gelöscht!');
            });
        }

        function editEntry(id) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry) return;

            editingEntryId = id;
            document.getElementById('editText').value = entry.text;
            document.getElementById('editModal').classList.add('show');
            document.getElementById('editError').classList.remove('show');
            document.getElementById('editSuccess').classList.remove('show');
            
            currentTags = entry.tags ? [...entry.tags] : [];
            updateEditTags();
            updateAvailableTags();
        }

        function saveEditedEntry() {
            const text = document.getElementById('editText').value.trim();
            if (!text) { showError('Text darf nicht leer sein.', 'editError'); return; }

            const entries = getEntries();
            const entryIndex = entries.findIndex(e => e.id === editingEntryId);

            if (entryIndex > -1) {
                entries[entryIndex].text = text;
                entries[entryIndex].tags = [...currentTags];
                saveEntries(entries);
                
                showSuccess('Eintrag aktualisiert!', 'editSuccess');
                setTimeout(() => closeEditModal(), 1000);
            }
        }

        function closeEditModal() {
            if(isEditDictating) {
                stopMediaRecorder();
                isEditDictating = false;
            }
            document.getElementById('dictateEditBtn').classList.remove('recording');
            document.getElementById('editModal').classList.remove('show');
            editingEntryId = null;
            currentTags = [];
        }
        
        async function toggleEditDictation() {
            const btn = document.getElementById('dictateEditBtn');
            if (isEditDictating) {
                stopMediaRecorder();
                isEditDictating = false;
                btn.classList.remove('recording');
                btn.textContent = '🎤 Änderung diktieren';
            } else {
                const recordingStarted = await startMediaRecorder(processEditDictation);
                if (recordingStarted) {
                    isEditDictating = true;
                    btn.classList.add('recording');
                    btn.textContent = '⏹️ Aufnahme stoppen';
                }
            }
        }

        async function processEditDictation() {
            isEditDictating = false;
            const btn = document.getElementById('dictateEditBtn');
            btn.classList.remove('recording');
            btn.textContent = '🎤 Änderung diktieren';

            try {
                const blobType = __mr && __mr.mimeType ? __mr.mimeType : 'audio/webm';
                const blob = new Blob(__mrChunks, { type: blobType });
                const file = new File([blob], 'diktat.' + (blobType.includes('ogg') ? 'ogg' : 'webm'), { type: blobType });
                
                await applyDictatedChanges(file);

            } catch (err) {
                showError('Verarbeitung des Diktats fehlgeschlagen: ' + (err.message || err), 'editError');
            }
        }
        
        async function applyDictatedChanges(audioFile) {
            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            if (!apiKey) {
                showError('API-Schlüssel benötigt.', 'editError');
                return;
            }

            const loadingEl = document.getElementById('editDictateLoading');
            loadingEl.classList.add('show');
            
            try {
                const instructionText = await transcribeAudio(audioFile, apiKey, provider);
                if (!instructionText) {
                    throw new Error("Transkription ergab keinen Text.");
                }

                const originalText = document.getElementById('editText').value;
                const prompt = `Du bist ein intelligenter Text-Editor. Modifiziere den "Originaltext" basierend auf der diktierten "Anweisung". Gib NUR den finalen, vollständigen und geänderten Text zurück, ohne zusätzliche Kommentare.

                Originaltext:
                ---
                ${originalText}
                ---

                Anweisung:
                ---
                ${instructionText}
                ---

                Finaler Text:`;

                const modifiedText = await callLLMAPI(prompt, apiKey, provider);
                document.getElementById('editText').value = modifiedText;
                showSuccess('Text per Diktat aktualisiert!', 'editSuccess');

            } catch(error) {
                showError('Fehler bei der diktierten Änderung: ' + error.message, 'editError');
            } finally {
                loadingEl.classList.remove('show');
            }
        }


        async function copyEntry(id) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry) return;

            let textToCopy = entry.text;
            if (entry.image) {
                textToCopy = `[Bild-Notiz]\n${textToCopy}`;
            }

            try {
                await navigator.clipboard.writeText(textToCopy);
                showSuccess('In Zwischenablage kopiert!');
            } catch (error) {
                showError('Fehler beim Kopieren: ' + error.message);
            }
        }

        async function shareEntry(id) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry) return;
            
            let textToShare = entry.text;
            if (entry.image) {
                textToShare = `[Bild-Notiz]\n${textToShare}`;
            }

            if (navigator.share) {
                try {
                    await navigator.share({ title: 'Sprach-Tagebuch Notiz', text: textToShare });
                } catch (error) {
                    console.log('Sharing cancelled');
                }
            } else {
                showError('Teilen wird in diesem Browser nicht unterstützt.');
            }
        }

        function loadEntries() {
            let entries = getEntries();
            
            if (activeTagFilter) {
                entries = entries.filter(e => e.tags && e.tags.includes(activeTagFilter));
            }

            renderEntries(entries);
        }

        function renderEntries(entries) {
            const container = document.getElementById('entries');
            container.innerHTML = '';
            
            const converter = new showdown.Converter({ tables: true, simpleLineBreaks: true });

            if (entries.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'empty-state';
                empty.textContent = 'Noch keine Einträge vorhanden.\nNimm deine erste Notiz auf!';
                container.appendChild(empty);
                return;
            }

            entries.forEach(entry => {
                const entryDiv = document.createElement('div');
                entryDiv.className = `entry ${selectionMode ? 'selection-mode' : ''}`;

                if (selectionMode) {
                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.className = 'entry-checkbox';
                    cb.checked = selectedEntries.has(entry.id);
                    cb.setAttribute('aria-label', `Notiz vom ${new Date(entry.timestamp).toLocaleDateString('de-DE')} auswählen`);
                    cb.addEventListener('change', e => {
                        if (e.target.checked) selectedEntries.add(entry.id);
                        else selectedEntries.delete(e.target.id);
                        updateBatchActionsVisibility();
                    });
                    entryDiv.appendChild(cb);
                }

                const header = document.createElement('div');
                header.className = 'entry-header';
                const dateDiv = document.createElement('div');
                const dateEl = document.createElement('div');
                dateEl.className = 'entry-date';
                dateEl.textContent = new Date(entry.timestamp).toLocaleDateString('de-DE', {
                    day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit'
                });
                dateDiv.appendChild(dateEl);

                if (entry.location) {
                    const locEl = document.createElement('div');
                    locEl.className = 'entry-location';
                    locEl.textContent = `📍 ${entry.location.latitude.toFixed(4)}, ${entry.location.longitude.toFixed(4)}`;
                    dateDiv.appendChild(locEl);
                }
                header.appendChild(dateDiv);
                entryDiv.appendChild(header);
                
                if (entry.image) {
                     const img = document.createElement('img');
                     img.className = 'entry-image';
                     img.src = entry.image;
                     img.alt = entry.text.substring(0, 50) + '...';
                     entryDiv.appendChild(img);
                }


                if (entry.tags && entry.tags.length > 0) {
                    const tagsDiv = document.createElement('div');
                    tagsDiv.className = 'entry-tags';
                    entry.tags.forEach(tag => {
                        const tagEl = document.createElement('div');
                        tagEl.className = 'tag';
                        tagEl.textContent = tag;
                        tagsDiv.appendChild(tagEl);
                    });
                    entryDiv.appendChild(tagsDiv);
                }

                const textEl = document.createElement('div');
                textEl.className = 'entry-text';
                
                const html = converter.makeHtml(entry.text || '');
                textEl.innerHTML = html;

                const isLongText = (entry.text || '').split('\n').length > 5 || (entry.text || '').length > 300;
                if (isLongText) {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'entry-text-wrapper';
                    textEl.classList.add('collapsed');
                    
                    const overlay = document.createElement('div');
                    overlay.className = 'expand-overlay';

                    wrapper.appendChild(textEl);
                    wrapper.appendChild(overlay);
                    entryDiv.appendChild(wrapper);
                } else {
                    entryDiv.appendChild(textEl);
                }

                const actions = document.createElement('div');
                actions.className = 'entry-actions';
                
                const btnConfigs = [
                    ['Bearbeiten', 'btn-icon', () => editEntry(entry.id)],
                    ['Kopieren', 'btn-icon', () => copyEntry(entry.id)],
                    ['Teilen', 'btn-icon', () => shareEntry(entry.id)]
                ];

                if ('NDEFReader' in window) {
                    btnConfigs.push(['Auf NFC schreiben', 'btn-icon', (btn) => writeEntryToNFC(entry.id, btn)]);
                }

                btnConfigs.push(['Löschen', 'delete-btn', () => deleteEntry(entry.id)]);

                btnConfigs.forEach(([label, className, handler]) => {
                    const btn = document.createElement('button');
                    btn.className = className;
                    btn.textContent = label;
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        handler();
                    });
                    actions.appendChild(btn);
                });

                entryDiv.appendChild(actions);

                entryDiv.addEventListener('click', (e) => {
                    if (e.target.closest('button, input, a')) {
                        return;
                    }
                    entryDiv.classList.toggle('expanded');
                });

                container.appendChild(entryDiv);
            });
        }

        function updateTagFilter(allEntries) {
            const allTags = new Set();
            allEntries.forEach(entry => {
                if (entry.tags) entry.tags.forEach(tag => allTags.add(tag));
            });

            const container = document.getElementById('tagFilter');
            container.innerHTML = '';
            
            if (allTags.size === 0 && !activeTagFilter) return;

            const allBtn = document.createElement('div');
            allBtn.className = `filter-tag ${!activeTagFilter ? 'active' : ''}`;
            allBtn.textContent = 'Alle';
            allBtn.addEventListener('click', () => filterByTag(null));
            container.appendChild(allBtn);

            Array.from(allTags).forEach(tag => {
                const tagBtn = document.createElement('div');
            tagBtn.className = `filter-tag ${activeTagFilter === tag ? 'active' : ''}`;
                tagBtn.textContent = tag;
                tagBtn.addEventListener('click', () => filterByTag(tag));
                container.appendChild(tagBtn);
            });
        }

        function filterByTag(tag) {
            activeTagFilter = tag;
            loadEntries();
            updateTagFilter(getEntries());
        }

        function toggleSelectionMode() {
            selectionMode = !selectionMode;
            selectedEntries.clear();
            
            const btn = document.getElementById('toggleSelectionBtn');
            btn.textContent = selectionMode ? 'Fertig' : 'Auswählen';
            
            loadEntries();
            updateBatchActionsVisibility();
        }

        function updateBatchActionsVisibility() {
            const batchActions = document.getElementById('batchActions');
            if (selectionMode && selectedEntries.size > 0) {
                batchActions.classList.add('show');
            } else {
                batchActions.classList.remove('show');
            }
        }

        async function summarizeSelected() {
            const allEntries = getEntries();
            const entries = allEntries.filter(e => selectedEntries.has(e.id));
            if (entries.length === 0) return;

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { showError('Bitte gib einen API-Schlüssel ein.'); return; }
            
            document.getElementById('batchSummaryTitle').textContent = 'Gesamt-Zusammenfassung';
            document.getElementById('batchSummaryModal').classList.add('show');
            document.getElementById('batchSummaryText').style.display = 'none';
            document.getElementById('batchSummaryActions').style.display = 'none';
            document.getElementById('batchSummaryLoading').classList.add('show');
            document.getElementById('batchSummarySuccess').classList.remove('show');

            try {
                const combinedText = entries.map((e, i) => {
                    const imgNote = e.image ? ' [Bild-Notiz enthalten]' : '';
                    return `Notiz ${i + 1} (${new Date(e.timestamp).toLocaleDateString('de-DE')})${imgNote}:\n${e.text}`;
                }).join('\n\n---\n\n');
                
                const prompt = `Erstelle eine prägnante Gesamt-Zusammenfassung der folgenden ${entries.length} Notizen. Identifiziere gemeinsame Themen und wichtige Erkenntnisse:\n\n${combinedText}`;

                let summary = await callLLMAPI(prompt, apiKey, provider, 0, null);

                document.getElementById('batchSummaryLoading').classList.remove('show');
                document.getElementById('batchSummaryText').value = summary;
                document.getElementById('batchSummaryText').style.display = 'block';
                document.getElementById('batchSummaryActions').style.display = 'flex';
            } catch (error) {
                document.getElementById('batchSummaryLoading').classList.remove('show');
                showError('Fehler beim Zusammenfassen: ' + error.message, 'batchSummarySuccess');
            }
        }
        
        async function mergeSelected() {
            const allEntries = getEntries();
            const entries = allEntries.filter(e => selectedEntries.has(e.id));
            if (entries.length === 0) return;

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { showError('Bitte gib einen API-Schlüssel ein.'); return; }
            
            document.getElementById('batchSummaryTitle').textContent = 'Zusammenführung (Daten-Kompilation)';
            document.getElementById('batchSummaryModal').classList.add('show');
            document.getElementById('batchSummaryText').style.display = 'none';
            document.getElementById('batchSummaryActions').style.display = 'none';
            document.getElementById('batchSummaryLoading').classList.add('show');
            document.getElementById('batchSummarySuccess').classList.remove('show');
            document.getElementById('batchSummaryLoading').textContent = 'KI führt Einträge zusammen...';


            try {
                const combinedText = entries.map((e, i) => {
                    const imgNote = e.image ? ' [Bild-Notiz enthalten]' : '';
                    return `--- Eintrag ${i + 1}${imgNote} ---\n${e.text}`;
                }).join('\n\n');
                
                const prompt = `Führe die folgenden ${entries.length} Notizen zusammen, ohne Informationen zu verlieren oder zu verallgemeinern. Deine Aufgabe ist die detailgetreue Kompilation.
                
                Wichtige Regeln:
                1. KEINE Zusammenfassung, KEINE Verallgemeinerung.
                2. Wenn es sich um Listen (z.B. Einkaufslisten, To-Do-Listen) handelt, kompiliere diese direkt in EINE EINZIGE, VOLLSTÄNDIGE Liste.
                3. Erhalte alle spezifischen Details (z.B. genaue Produktnamen, Zahlen, Adressen).
                
                Texte zum Zusammenführen:
                
                ${combinedText}`;

                let result = await callLLMAPI(prompt, apiKey, provider, 0, null);

                document.getElementById('batchSummaryLoading').classList.remove('show');
                document.getElementById('batchSummaryText').value = result;
                document.getElementById('batchSummaryText').style.display = 'block';
                document.getElementById('batchSummaryActions').style.display = 'flex';
            } catch (error) {
                document.getElementById('batchSummaryLoading').classList.remove('show');
                showError('Fehler beim Zusammenführen: ' + error.message, 'batchSummarySuccess');
            }
        }


        function saveBatchSummary() {
            const summary = document.getElementById('batchSummaryText').value.trim();
            if (!summary) return;

            const entry = {
                id: Date.now().toString(),
                text: summary,
                timestamp: new Date().toISOString(),
                location: null,
                tags: [document.getElementById('batchSummaryTitle').textContent.includes('Zusammenfassung') ? 'Zusammenfassung' : 'Kompilation'],
                transcript: `${document.getElementById('batchSummaryTitle').textContent} von ${selectedEntries.size} Notizen`,
                image: null
            };

            const entries = getEntries();
            entries.unshift(entry);
            saveEntries(entries);

            showSuccess('Ergebnis gespeichert!', 'batchSummarySuccess');
            setTimeout(() => closeBatchSummaryModal(), 1000);
        }

        function closeBatchSummaryModal() {
            document.getElementById('batchSummaryModal').classList.remove('show');
            document.getElementById('batchSummaryText').value = '';
            document.getElementById('batchSummaryText').style.display = 'none';
            document.getElementById('batchSummaryActions').style.display = 'none';
            document.getElementById('batchSummaryLoading').classList.add('show');
            document.getElementById('batchSummaryTitle').textContent = 'Ergebnis der Stapelaktion';
            document.getElementById('batchSummaryLoading').textContent = 'KI erstellt Gesamt-Zusammenfassung...';
        }

        function copyBatchSummary() {
            const text = document.getElementById('batchSummaryText').value;
            if (!text) return;
            navigator.clipboard.writeText(text).then(() => {
                showSuccess('In Zwischenablage kopiert!', 'batchSummarySuccess');
            }).catch(() => {
                showError('Fehler beim Kopieren.', 'batchSummarySuccess');
            });
        }

        function deleteSelected() {
            if (selectedEntries.size === 0) return;

            showConfirmModal(`${selectedEntries.size} Einträge wirklich löschen?`, () => {
                const entries = getEntries().filter(e => !selectedEntries.has(e.id));
                saveEntries(entries);
                
                selectedEntries.clear();
                toggleSelectionMode();
                showSuccess('Ausgewählte Einträge gelöscht!');
            });
        }

        function tagSelected() {
            const tag = prompt('Tag für ausgewählte Einträge:');
            if (!tag || selectedEntries.size === 0) return;

            const entries = getEntries();
            let changed = false;
            entries.forEach(entry => {
                if (selectedEntries.has(entry.id)) {
                    if (!entry.tags) entry.tags = [];
                    if (!entry.tags.includes(tag)) {
                        entry.tags.push(tag);
                        changed = true;
                    }
                }
            });
            
            if (changed) {
                saveEntries(entries);
                showSuccess('Tags hinzugefügt!');
            }
        }

        function exportSelected() {
            const allEntries = getEntries();
            const entries = allEntries.filter(e => selectedEntries.has(e.id));
            if (entries.length === 0) return;

            const text = entries.map(e => {
                const date = new Date(e.timestamp).toLocaleString('de-DE');
                const tags = e.tags ? `\nTags: ${e.tags.join(', ')}` : '';
                const location = e.location ? `\nStandort: ${e.location.latitude}, ${e.location.longitude}` : '';
                const image = e.image ? `\n[Bild-Notiz enthalten]` : '';
                return `=== ${date} ===${image}${tags}${location}\n\n${e.text}`;
            }).join('\n\n' + '='.repeat(50) + '\n\n');

            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `notizen_${new Date().toISOString().split('T')[0]}.txt`;
            a.click();
            URL.revokeObjectURL(url);

            showSuccess('Exportiert!');
        }

        async function shareSelected() {
            const allEntries = getEntries();
            const entries = allEntries.filter(e => selectedEntries.has(e.id));
            if (entries.length === 0) return;

            const text = entries.map(e => {
                const date = new Date(e.timestamp).toLocaleDateString('de-DE');
                const image = e.image ? '[Bild-Notiz] ' : '';
                return `${date}: ${image}\n${e.text}`;
            }).join('\n\n---\n\n');

            if (navigator.share) {
                try {
                    await navigator.share({ title: 'Meine Notizen', text: text });
                } catch (error) {
                    console.log('Sharing cancelled');
                }
            } else {
                showError('Teilen wird in diesem Browser nicht unterstützt.');
            }
        }

        function saveAPIKey() {
            localStorage.setItem('api_key', document.getElementById('apiKey').value);
            localStorage.setItem('api_provider', document.getElementById('apiProvider').value);
            checkAndSetApiSetupState();
        }

        function loadAPIKey() {
            const apiKey = localStorage.getItem('api_key');
            const provider = localStorage.getItem('api_provider');
            if (apiKey) document.getElementById('apiKey').value = apiKey;
            if (provider) document.getElementById('apiProvider').value = provider;
            
            checkAndSetApiSetupState();
        }

        function showError(message, targetId = 'error') {
            const errorEl = document.getElementById(targetId);
            errorEl.textContent = message;
            errorEl.classList.add('show');
            setTimeout(() => errorEl.classList.remove('show'), 5000);
        }

        function showSuccess(message, targetId = 'success') {
            const successEl = document.getElementById(targetId);
            successEl.textContent = message;
            successEl.classList.add('show');
            setTimeout(() => successEl.classList.remove('show'), 3000);
        }

        function showConfirmModal(message, callback) {
            document.getElementById('confirmMessage').textContent = message;
            document.getElementById('confirmModal').classList.add('show');
            confirmCallback = callback;
        }

        function closeConfirmModal() {
            document.getElementById('confirmModal').classList.remove('show');
            confirmCallback = null;
        }

        async function copyToClipboard() {
            const text = document.getElementById('summary').value;
            try {
                await navigator.clipboard.writeText(text);
                showSuccess('In Zwischenablage kopiert!');
            } catch (error) {
                showError('Fehler beim Kopieren: ' + error.message);
            }
        }

        async function shareContent() {
            const text = document.getElementById('summary').value;
            if (navigator.share) {
                try {
                    await navigator.share({ title: 'Sprach-Tagebuch Notiz', text: text });
                } catch (error) {
                    console.log('Sharing cancelled');
                }
            } else {
                showError('Teilen wird in diesem Browser nicht unterstützt.');
            }
        }

        function resetForm() {
            currentTranscript = '';
            currentLocation = null;
            currentTags = [];
            currentImageBase64 = null;
            document.getElementById('transcript').value = '';
            document.getElementById('summary').value = '';
            document.getElementById('newTag').value = '';
            document.getElementById('transcriptSection').classList.remove('show');
            document.getElementById('summarySection').classList.remove('show');
            
            const imagePreview = document.getElementById('imagePreview');
            imagePreview.src = '';
            imagePreview.style.display = 'none';
            
            updateRecordButton('Bereit zur Aufnahme');
            
            updateCurrentTags();
            document.getElementById('error').classList.remove('show');
            document.getElementById('success').classList.remove('show');
            
            updateNFCWriteButton();
        }
    </script>
    
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js', { scope: '/captain/' })
                    .then(reg => {
                        console.log('Service Worker registriert:', reg.scope);
                        if (reg.waiting) { reg.waiting.postMessage('SKIP_WAITING'); }
                        reg.addEventListener('updatefound', () => {
                            const nw = reg.installing;
                            if (nw) {
                                nw.addEventListener('statechange', () => {
                                    if (nw.state === 'installed' && reg.waiting) {
                                        reg.waiting.postMessage('SKIP_WAITING');
                                    }
                                });
                            }
                        });
                    })
                    .catch(err => console.error('SW Fehler:', err));

                navigator.serviceWorker.addEventListener('controllerchange', () => {
                    console.log('Neue Version aktiv – Seite wird aktualisiert…');
                    window.location.reload();
                });
            });
        }
    </script>

    <!-- KI API Logik -->
    <script>
        function handleAPIResponse(provider, data) {
            if (provider === 'anthropic') {
                const textBlock = data.content?.find(block => block.type === 'text');
                return textBlock?.text || 'Fehler: Anthropic-Antwort konnte nicht gelesen werden.';
            } else if (provider === 'openai') {
                return data.choices?.[0]?.message?.content || 'Fehler: OpenAI-Antwort konnte nicht gelesen werden.';
            } else if (provider === 'gemini') {
                if (data.promptFeedback?.blockReason) {
                    const reason = data.promptFeedback.blockReason;
                    const userMessage = "Die KI hat die Anfrage wegen Sicherheitsbedenken blockiert. Versuchen Sie eine andere Formulierung.";
                    return `Fehler: ${userMessage}`; 
                }

                const candidate = data.candidates?.[0];
                if (candidate) {
                    const finishReason = candidate.finishReason;
                    if (finishReason && finishReason !== 'STOP' && finishReason !== 'MAX_TOKENS') {
                        const userMessage = `Die KI hat die Antwort aus Sicherheitsgründen gestoppt (Grund: ${finishReason}).`;
                        return `Fehler: ${userMessage}`;
                    }

                    const text = candidate.content?.parts?.[0]?.text;
                    if (text) {
                        return text;
                    }
                }
                
                return 'Fehler beim Parsen der Gemini-Antwort (kein Inhalt gefunden).';

            }
            return 'Fehler: Unbekannter KI-Anbieter.';
        }
        
        function dataURLtoParts(dataURL) {
            const parts = dataURL.split(';base64,');
            if (parts.length < 2) throw new Error("Ungültiges Data-URL-Format.");
            const mime = parts[0].split(':')[1];
            const base64 = parts[1];
            return { mimeType: mime, data: base64 };
        }


        async function callLLMAPI(userPrompt, apiKey, provider, retryCount = 0, imageFile = null, systemInstructionOverride = null) {
            let url = '';
            let headers = {};
            let body = {};
            let model = '';
            let systemInstruction = systemInstructionOverride || 'Du bist ein freundlicher, prägnanter Assistent, der Notizen zusammenfasst, umformuliert oder Bilder detailliert beschreibt. Deine Antwort soll nur die gewünschte Ausgabe enthalten, ohne einleitenden Text wie "Hier ist die Zusammenfassung". Antworte auf Deutsch.';
            
            let imageParts = null;
            if (imageFile) {
                const base64Url = await new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.readAsDataURL(imageFile);
                });
                imageParts = dataURLtoParts(base64Url);
            }


            if (provider === 'anthropic') {
                url = 'https://api.anthropic.com/v1/messages';
                model = 'claude-3-5-sonnet-20240620';
                
                let content = [{ type: 'text', text: userPrompt }];
                if (imageParts) {
                    content.unshift({
                        type: 'image',
                        source: {
                            type: 'base64',
                            media_type: imageParts.mimeType,
                            data: imageParts.data
                        }
                    });
                }
                
                headers = {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01'
                };
                body = {
                    model: model,
                    max_tokens: 2000,
                    system: systemInstruction,
                    messages: [
                        { role: 'user', content: content }
                    ]
                };
                
            } else if (provider === 'openai') {
                url = 'https://api.openai.com/v1/chat/completions';
                model = 'gpt-4o';
                
                let content = [{ type: 'text', text: userPrompt }];
                if (currentImageBase64) {
                    content.push({
                        type: 'image_url',
                        image_url: {
                            url: currentImageBase64,
                            detail: "low" 
                        }
                    });
                } else if (imageParts) {
                     content.push({
                        type: 'image_url',
                        image_url: {
                            url: `data:${imageParts.mimeType};base64,${imageParts.data}`,
                            detail: "auto"
                        }
                    });
                }

                headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                };
                body = {
                    model: model,
                    messages: [
                        { role: 'system', content: systemInstruction },
                        { role: 'user', content: content }
                    ],
                    max_tokens: 2000
                };
            } else if (provider === 'gemini') {
                url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
                model = 'gemini-2.5-flash';
                headers = {
                    'Content-Type': 'application/json'
                };
                
                let parts = [{ text: userPrompt }];
                if (imageParts) {
                     parts.push({
                         inlineData: { mimeType: imageParts.mimeType, data: imageParts.data }
                     });
                }

                body = {
                    contents: [{ parts: parts }],
                    systemInstruction: { parts: [{ text: systemInstruction }] },
                    generationConfig: { maxOutputTokens: 2000 }
                };
            } else {
                throw new Error('Unbekannter KI-Anbieter ausgewählt.');
            }
            
            try {
                if(window.__memotag?.diag) {
                    __memotag.diag.diagLog(`Starte API-Aufruf zu ${provider} mit Modell ${model}...`);
                }
            } catch(_) {}


            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(body)
                });

                const data = await response.json();

                if (!response.ok) {
                    const errorMsg = data.error?.message || data.error?.type || 'Unbekannter Fehler';
                    throw new Error(`API-Fehler (${response.status}): ${errorMsg}`);
                }

                const resultText = handleAPIResponse(provider, data);
                if (resultText.startsWith('Fehler')) {
                     throw new Error(resultText);
                }
                
                return resultText;

            } catch (error) {
                if (retryCount < 3 && (error.message.includes('Failed to fetch') || error.message.includes('Timeout'))) {
                    const delay = Math.pow(2, retryCount) * 1000;
                    console.warn(`API-Aufruf fehlgeschlagen. Versuche es in ${delay}ms erneut...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return callLLMAPI(userPrompt, apiKey, provider, retryCount + 1, imageFile, systemInstructionOverride);
                }
                throw error;
            }
        }
    </script>
    
<section class="diag-card collapsed" id="diagnostics">
  <h3 style="margin-top:0" id="diagHeader">Diagnose <span class="toggle-icon">▼</span></h3>
  <div class="diag-content" id="diagContent">
      <div class="diag-grid">
        <div>Zustand</div>
        <div><span id="diag-state" class="state-badge state-warn">bereit</span></div>

        <div>Mikrofon-Pegel</div>
        <div class="level-wrap"><div id="diag-level" class="level-bar anim"></div></div>

        <div>Letzter Fehler</div>
        <div id="diag-last-error">–</div>

        <div>Ereignis-Log</div>
        <div id="diag-log" aria-live="polite"></div>
      </div>
  </div>
</section>


<script id="diag-script">
  (function(){
    const $state = () => document.getElementById('diag-state');
    const $log = () => document.getElementById('diag-log');
    const $err = () => document.getElementById('diag-last-error');
    const $lvl = () => document.getElementById('diag-level');

    window.__memotag = window.__memotag || {};
    let audioCtx, analyser, micStream, rafId;
    let lowLevelStart = null;

    function ts(){
      const d = new Date();
      return d.toLocaleTimeString();
    }

    function diagSetState(text, cls){
      const el = $state();
      if(!el) return;
      el.textContent = text;
      el.classList.remove('state-ok','state-warn','state-err');
      el.classList.add(cls || 'state-warn');
    }

    function diagLog(msg){
      const el = $log();
      if(!el) return;
      const line = document.createElement('div');
      line.className = 'line';
      line.textContent = `[${ts()}] ${msg}`;
      el.prepend(line);
      const nodes = el.querySelectorAll('.line');
      if(nodes.length > 60) el.removeChild(nodes[nodes.length-1]);
    }

    function diagError(msg){
      const el = $err();
      if(el) el.textContent = msg || '–';
      diagSetState('Fehler', 'state-err');
      diagLog('ERROR: ' + msg);
    }

    async function startMicMeter(){
      try{
        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
          diagLog('getUserMedia nicht verfügbar');
          return;
        }
        micStream = await navigator.mediaDevices.getUserMedia({audio:true});
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        const source = audioCtx.createMediaStreamSource(micStream);
        source.connect(analyser);
        const data = new Uint8Array(analyser.fftSize);

        function tick(){
          analyser.getByteTimeDomainData(data);
          let sum = 0;
          for(let i=0;i<data.length;i++){ const v = (data[i]-128)/128; sum += v*v; }
          const rms = Math.sqrt(sum/data.length);
          const pct = Math.min(100, Math.max(0, Math.round(rms*180)));
          const bar = $lvl();
          if(bar){ bar.style.width = pct + '%'; }
          if(pct < 5){
            if(!lowLevelStart) lowLevelStart = performance.now();
            else if(performance.now() - lowLevelStart > 3000){
              diagLog('Hinweis: Sehr niedriger Pegel erkannt (Mikro weit weg? stumm?)');
              lowLevelStart = null;
            }
          } else {
            lowLevelStart = null;
          }
          rafId = requestAnimationFrame(tick);
        }
        tick();
        diagLog('Mic-Meter gestartet');
      }catch(e){
        diagError('Mic-Meter Fehler: ' + e.message);
      }
    }

    function stopMicMeter(){
      if(rafId) cancelAnimationFrame(rafId);
      rafId = null;
      try { if(micStream){ micStream.getTracks().forEach(t=>t.stop()); } } catch(e){}
      try { if(audioCtx){ audioCtx.close(); } } catch(e){}
      const bar = $lvl();
      if(bar){ bar.style.width = '0%'; }
      diagLog('Mic-Meter gestoppt');
    }

    window.__memotag.diag = { diagSetState, diagLog, diagError, startMicMeter, stopMicMeter };
  })();
</script>


<script>
document.addEventListener('DOMContentLoaded', () => {
    const hash = location.hash;
    if (hash === '#new') {
        const b = document.getElementById('recordBtn');
        if (b) { b.scrollIntoView({behavior:'smooth', block:'center'}); b.focus(); }
    } else if (hash === '#entries') {
        const e = document.querySelector('.entries-section');
        if (e) e.scrollIntoView({behavior:'smooth', block:'start'});
    }
});
</script>
<script>
function isIOS() {
    return /iPhone|iPad|iPod/i.test(navigator.userAgent);
}

async function fileToBase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = error => reject(error);
        reader.readAsDataURL(file);
    });
}


function normalizeMime(file) {
    const t = (file.type || '').toLowerCase();
    if (t) return t;
    const name = (file.name || '').toLowerCase();
    if (name.endsWith('.m4a')) return 'audio/mp4';
    if (name.endsWith('.mp3')) return 'audio/mpeg';
    if (name.endsWith('.wav')) return 'audio/wav';
    if (name.endsWith('.ogg')) return 'audio/ogg';
    if (name.endsWith('.webm')) return 'audio/webm';
    if (name.endsWith('.png')) return 'image/png';
    if (name.endsWith('.jpg') || name.endsWith('.jpeg')) return 'image/jpeg';
    return 'application/octet-stream';
}


async function transcribeAudio(file, apiKey, provider) {
    const maxMB = 20;
    if (file.size > maxMB * 1024 * 1024) {
        throw new Error(`Audiodatei ist größer als ${maxMB} MB.`);
    }

    if (provider === 'openai') {
        const url = 'https://api.openai.com/v1/audio/transcriptions';
        const form = new FormData();
        form.append('file', file, file.name || 'audio.m4a');
        form.append('model', 'whisper-1');
        form.append('language', 'de');
        const resp = await fetch(url, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${apiKey}` },
            body: form
        });
        const data = await resp.json();
        if (!resp.ok) {
            const msg = data.error?.message || 'Unbekannter Fehler';
            throw new Error(`OpenAI-Fehler (${resp.status}): ${msg}`);
        }
        return data.text || '';
    }

    if (provider === 'anthropic') {
        const url = 'https://api.anthropic.com/v1/messages';
        const b64 = await fileToBase64(file);
        const mime = normalizeMime(file);
        const body = {
            model: 'claude-3-5-haiku-latest',
            max_tokens: 2000,
            system: 'Du bist ein präziser Transkriptionsassistent. Transkribiere nur den gesprochenen deutschen Text, ohne Zusatz.',
            messages: [{
                role: 'user',
                content: [
                    { type: 'text', text: 'Transkribiere dieses Audio auf Deutsch.' },
                    { type: 'image', source: { type: 'base64', data: b64, media_type: mime } }
                ]
            }]
        };
        const resp = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': apiKey,
                'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify(body)
        });
        const data = await resp.json();
        if (!resp.ok) {
            const msg = data.error?.message || data.error?.type || 'Unbekannter Fehler';
            throw new Error(`Anthropic-Fehler (${resp.status}): ${msg}`);
        }
        const block = (data.content || []).find(b => b.type === 'text');
        return (block && block.text) || '';
    }

    if (provider === 'gemini') {
        const mime = normalizeMime(file);
        const b64 = await fileToBase64(file);
        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
        const body = {
            contents: [{
                parts: [
                    { text: 'Transkribiere dieses Audio auf Deutsch. Antworte nur mit dem reinen Transkript.' },
                    { inlineData: { mimeType: mime, data: b64 } }
                ]
            }],
            generationConfig: { maxOutputTokens: 2000 }
        };
        const resp = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });
        const data = await resp.json();
        if (!resp.ok) {
            const msg = data.error?.message || 'Unbekannter Fehler';
            throw new Error(`Gemini-Fehler (${resp.status}): ${msg}`);
        }
        const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
        return text;
    }

    throw new Error('Unbekannter KI-Anbieter für Audio-Transkription.');
}
</script>
<script>
function stopStream(stream){ try{ if(stream) stream.getTracks().forEach(t=>t.stop()); }catch(_){} }

function initMediaRecorderFallback() {
    // Diese Funktion prüft, ob eine Alternative (Fallback) für die Audio-Aufnahme benötigt wird.
    // Eine Log-Nachricht wird nur ausgegeben, wenn die MediaRecorder-API nicht vom Browser unterstützt wird.
    if (!('MediaRecorder' in window)) {
        try {
            if (window.__memotag?.diag) {
                window.__memotag.diag.diagLog('Hinweis: MediaRecorder nicht unterstützt. Fallback wird aktiviert.');
            }
        } catch(_) {
            // Fehler beim Loggen werden ignoriert.
        }
    }
}
</script>
</body>
</html>
