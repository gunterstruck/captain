<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="manifest" href="/captain/manifest.webmanifest">
    <meta name="theme-color" content="#4F46E5">

    <meta name="description" content="Sprach-Tagebuch mit KI-Zusammenfassungen und Bild-Notizen">
    <title>Synaptic Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        .header,
        .record-section,
        .entries-section {
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 12px; 
            padding: 20px;
        }
        
        .record-section {
            padding: 30px;
            text-align: center;
        }
        
        .header {
             padding: 20px;
        }
        
        .entries-section {
             padding: 20px;
        }

        h1 {
            color: #4F46E5;
            font-size: 28px;
            margin-bottom: 15px;
            overflow-wrap: break-word;
            cursor: pointer; 
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .settings-icon {
            font-size: 20px;
            color: #4F46E5;
            transition: transform 0.3s;
        }

        .header:not(.expanded) .settings-icon {
            transform: rotate(-90deg);
        }
        .header.expanded .settings-icon {
            transform: rotate(0deg);
        }


        .api-setup {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            transition: max-height 0.5s ease-out, opacity 0.5s ease-out, padding 0.5s ease-out, margin-bottom 0.5s ease-out;
            overflow: hidden;
            max-height: 500px; 
            opacity: 1;
        }
        
        .api-setup .input-group input,
        .api-setup .input-group select {
            background-color: #F3F4F6;
        }


        .api-setup.collapsed {
            max-height: 0 !important;
            opacity: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            margin-bottom: 0 !important;
        }

        .input-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            font-size: 14px;
            color: #374151;
            margin-bottom: 5px;
            font-weight: 500;
        }

        input[type="text"], input[type="password"], select, textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #E5E7EB;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #4F46E5;
        }
        
        .record-button {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            font-size: 48px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px auto 10px;
        }

        .record-button:hover {
            transform: scale(1.05);
        }

        .record-button:focus {
            outline: 3px solid #818CF8;
            outline-offset: 3px;
        }

        .record-button.recording {
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
            animation: pulse 1.5s infinite;
        }
        
        #dictateEditBtn.recording {
            background: #EF4444;
            color: white;
            animation: pulse 1.5s infinite;
        }


        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .status {
            font-size: 16px;
            color: #6B7280;
            margin-top: 10px;
        }
        
        .processing {
            color: #4F46E5;
            font-weight: 601;
        }


        .transcript-section, .summary-section {
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            opacity: 0;
            height: 0;
            overflow: hidden;
            pointer-events: none;
            margin: 0;          
            padding: 0;
            transition: opacity 0.5s ease-in-out, height 0.5s ease-in-out, padding 0.5s ease-in-out, margin-bottom 0.5s ease-in-out;
        }

        .transcript-section.show, .summary-section.show {
            opacity: 1;
            height: auto;
            pointer-events: all;
            margin-bottom: 12px; 
            padding: 20px;
        }

        .section-title {
            font-size: 18px;
            color: #4F46E5;
            margin-bottom: 15px;
            font-weight: 600;
        }

        textarea {
            min-height: 150px;
            resize: vertical;
            font-family: inherit;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        button:focus {
            outline: 2px solid #4F46E5;
            outline-offset: 2px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex: 1;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-action {
            background: #4F46E5;
            color: white;
            flex: 1;
        }
        
        .btn-action:hover {
            background: #4338CA;
            box-shadow: 0 3px 10px rgba(79, 70, 229, 0.4);
        }


        .btn-secondary {
            background: #F3F4F6;
            color: #374151;
            flex: 1;
        }

        .btn-secondary:hover {
            background: #E5E7EB;
        }

        .btn-icon {
            background: #F3F4F6;
            color: #374151;
            padding: 10px 15px;
            flex: 1;
        }

        .btn-icon:hover {
            background: #E5E7EB;
        }
        
        .record-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 10px;
        }
        
        .record-actions button {
            padding: 8px 15px;
            font-size: 14px;
            flex: 0 0 auto;
        }

        .tags-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #F3F4F6;
        }
        
        .available-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: #F9FAFB;
            border-radius: 8px;
        }
        
        .tag-suggestion {
            background: #E0E7FF;
            color: #4F46E5;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .tag-suggestion:hover {
            background: #C7D2FE;
        }
        
        .tag-suggestion.active {
            background: #4F46E5;
            color: white;
            border-color: #4F46E5;
        }


        .tags-input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .tags-input-group input {
            flex: 1;
        }

        .tags-input-group button {
            flex: 0 0 auto;
        }

        .tag-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .tag {
            background: #EEF2FF;
            color: #4F46E5;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tag-remove {
            background: none;
            border: none;
            color: #4F46E5;
            cursor: pointer;
            padding: 0;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-size: 12px;
        }

        .tag-remove:hover {
            background: #4F46E5;
            color: white;
        }

        .entries-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .tag-filter {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .filter-tag {
            background: #F3F4F6;
            color: #374151;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .filter-tag:hover {
            background: #E5E7EB;
        }

        .filter-tag.active {
            background: #4F46E5;
            color: white;
            border-color: #4F46E5;
        }

        .selection-mode-btn {
            background: #4F46E5;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
        }

        .batch-actions {
            display: none;
            background: #FEF3C7;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            gap: 10px;
            flex-wrap: wrap;
        }

        .batch-actions.show {
            display: flex;
        }

        .batch-actions button {
            flex: 0 0 auto;
            padding: 8px 16px;
            font-size: 13px;
        }

        .entry {
            background: #F9FAFB;
            padding: 15px;
            border-left: 4px solid #4F46E5;
            position: relative;
            border-radius: 10px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .entry:hover {
            background-color: #F3F4F6;
        }
        
        .entry-actions button, .entry-checkbox, .entry-tags .tag {
            cursor: pointer;
        }


        .entry.selection-mode {
            padding-left: 50px;
        }

        .entry-checkbox {
            position: absolute;
            left: 15px;
            top: 20px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .entry-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
            gap: 10px;
        }

        .entry-date {
            font-size: 14px;
            color: #4F46E5;
            font-weight: 600;
        }

        .entry-location {
            font-size: 12px;
            color: #6B7280;
            margin-top: 2px;
        }

        .entry-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 8px 0;
        }

        .entry-text {
            color: #374151;
            line-height: 1.6;
            white-space: pre-wrap;
            margin-bottom: 10px;
        }

        .entry-text-wrapper {
            position: relative;
        }
        .entry-text.collapsed {
            max-height: 110px;
            overflow: hidden;
            transition: max-height 0.4s ease-out;
        }
        .entry-text-wrapper .expand-overlay {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: linear-gradient(to bottom, transparent, #F9FAFB);
            pointer-events: none;
            opacity: 1;
            transition: opacity 0.4s ease-out;
        }
        
        .entry.expanded .entry-text.collapsed {
            max-height: 1500px;
        }
        .entry.expanded .expand-overlay {
            opacity: 0;
        }
        
        .entry-image {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 10px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .entry-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            margin-top: 0;
            transition: max-height 0.4s ease-out, opacity 0.4s ease-out, margin-top 0.4s ease-out;
            pointer-events: none;
        }
        
        .entry.expanded .entry-actions {
            max-height: 200px;
            opacity: 1;
            margin-top: 15px;
            pointer-events: auto;
        }

        .entry-actions button {
            padding: 6px 12px;
            font-size: 12px;
        }
        
        .entry-text table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 14px;
        }
        .entry-text th, .entry-text td {
            border: 1px solid #E5E7EB;
            padding: 8px 12px;
            text-align: left;
        }
        .entry-text th {
            background-color: #F3F4F6;
            font-weight: 600;
        }
        .entry-text tr:nth-child(even) {
            background-color: #F9FAFB;
        }


        .delete-btn {
            background: #EF4444;
            color: white;
        }

        .delete-btn:hover {
            background: #DC2626;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #9CA3AF;
        }

        .loading {
            display: none;
            text-align: center;
            color: #6B7280;
            padding: 10px;
        }

        .loading.show {
            display: block;
        }

        .error {
            background: #FEE2E2;
            color: #991B1B;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            display: none;
        }

        .error.show {
            display: block;
        }

        .success {
            background: #D1FAE5;
            color: #065F46;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            display: none;
        }

        .success.show {
            display: block;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-close {
            background: #F3F4F6;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
        }
        
        #imagePreview {
            max-width: 100%;
            max-height: 200px; 
            margin: 15px auto 5px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            display: none;
        }


        @media (max-width: 640px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 22px;
            }
            
            .button-group, .reformulate-buttons {
                flex-direction: column;
            }
            
            .btn-icon {
                flex: 1 1 100%;
            }

            .tags-input-group {
                flex-direction: column;
            }

            .tags-input-group button {
                flex: 1 1 100%;
            }
            
            .record-actions {
                flex-direction: column;
            }
        }
    </style>

<style id="diag-styles">
  /* Diagnostik Styles (Collapsible) */
  .diag-card { 
      margin: 16px auto; 
      max-width: 900px; 
      background: rgba(255,255,255,0.9); 
      border-radius: 16px; 
      padding: 16px; 
      box-shadow: 0 6px 24px rgba(0,0,0,0.08); 
      margin-bottom: 12px !important; 
  }
  .diag-card h3 {
      cursor: pointer;
      margin-top: 0;
      margin-bottom: 0; 
      display: flex;
      align-items: center;
      justify-content: space-between;
  }
  .diag-card h3 .toggle-icon {
      font-size: 14px;
      transition: transform 0.3s;
      margin-left: 8px;
      transform: rotate(0deg);
  }
  .diag-card.collapsed h3 .toggle-icon {
      transform: rotate(-90deg);
  }

  .diag-content {
      transition: max-height 0.5s ease-in-out, opacity 0.5s ease-in-out, padding-top 0.5s ease-in-out;
      max-height: 1000px; 
      overflow: hidden;
      opacity: 1;
      padding-top: 16px;
  }
  .diag-card.collapsed .diag-content {
      max-height: 0;
      opacity: 0;
      padding-top: 0;
  }
    
  .diag-grid { display: grid; grid-template-columns: 160px 1fr; gap: 8px 16px; align-items: center; }
  .state-badge { display:inline-block; padding:4px 10px; border-radius:999px; font-size:12px; font-weight:600; }
  .state-ok { background:#e6f7ef; color:#0a7f4f; }
  .state-warn { background:#fff4e6; color:#a15a00; }
  .state-err { background:#ffe8e6; color:#b50000; }
  .level-wrap { width:100%; height:10px; background:#eee; border-radius:6px; overflow:hidden; }
  .level-bar.anim { background: linear-gradient(90deg, #a78bfa, #7c3aed); }
  #diag-log { max-height: 140px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:12px; background:#fafafa; border:1px solid #eee; border-radius:8px; padding:8px; }
  #diag-log .line { padding:2px 0; border-bottom:1px dashed #eee;}
  #diag-last-error { color:#b50000; font-weight:600; }
</style>

    <link rel="apple-touch-icon" href="/captain/icon-192-v2.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
</head>
<body>
    <div class="container">
        <div class="header collapsed" id="header">
            <h1 id="headerTitle">
                Synaptic Pro
                <span class="settings-icon" id="settingsIcon">‚öôÔ∏è</span>
            </h1>
            
            <div class="api-setup collapsed" id="apiSetup">
                <div class="input-group">
                    <label for="apiProvider">KI-Anbieter:</label>
                    <select id="apiProvider">
                        <option value="anthropic">Anthropic (Claude)</option>
                        <option value="openai">OpenAI (GPT)</option>
                        <option value="gemini">Google (Gemini)</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="apiKey">API-Schl√ºssel:</label>
                    <input type="password" id="apiKey" placeholder="Dein API-Schl√ºssel">
                </div>
                <div class="input-group">
                    <label>
                        <input type="checkbox" id="locationPermission">
                        Standort-Freigabe (optional)
                    </label>
                </div>
            </div>
        </div>

        <div class="record-section">
            <h2 class="section-title">Neue Notiz aufnehmen</h2>
            <button class="record-button" id="recordBtn" aria-label="Aufnahme starten">üé§</button>
            
            <img id="imagePreview" src="" alt="Hochgeladenes Bild" />

            <div class="record-actions">
                <button class="btn-secondary" id="imageUploadBtn">üñºÔ∏è Bild hochladen</button>
                <button class="btn-action" id="photoToNfcBtn">üì∑ Foto zu NFC</button>
                <input type="file" id="audioInput" accept="audio/*" capture="microphone" style="display:none;">
                <input type="file" id="imageInput" accept="image/*" style="display:none;">
                <input type="file" id="photoToNfcInput" accept="image/*" capture="camera" style="display:none;">
                
                <button class="btn-secondary" id="nfcBtn" style="display:none;">NFC-Tag lesen üì≤</button>
            </div>


            <div id="iosHint" class="status" style="display:none;">Mobile Ger√§te erkannt: Tippe auf das Mikrofon-Symbol, um die Aufnahme zu starten oder eine Audiodatei auszuw√§hlen.</div>
            
            <div class="status" id="status" role="status" aria-live="polite">Bereit zur Aufnahme</div>
        </div>

        <div class="transcript-section" id="transcriptSection">
            <h2 class="section-title" id="transcriptTitle">Transkription (Wird automatisch verarbeitet...)</h2>
            <textarea id="transcript" readonly aria-label="Transkribierter Text"></textarea>
            <div class="loading" id="loading" role="status">KI erstellt Zusammenfassung...</div>
            <div class="error" id="error" role="alert"></div>
        </div>

        <div class="summary-section" id="summarySection">
            <h2 class="section-title">Zusammenfassung</h2>
            <textarea id="summary" aria-label="Zusammenfassung bearbeiten"></textarea>
            
            <div class="tags-section">
                <label>Verf√ºgbare Tags:</label>
                <div class="available-tags" id="availableTags">
                </div>

                <label>Tags hinzuf√ºgen:</label>
                <div class="tags-input-group">
                    <input type="text" id="newTag" placeholder="z.B. Arbeit, Einkauf, Idee...">
                    <button class="btn-secondary" id="addTagBtn">+ Tag</button>
                </div>
                <div class="tag-list" id="currentTags"></div>
            </div>

            <div class="button-group">
                <button class="btn-primary" id="saveBtn">Speichern</button>
                <button class="btn-action" id="writeNFCBtn" style="display:none;">Auf NFC-Tag speichern üì≤</button>
                <button class="btn-icon" id="copyBtn">Kopieren</button>
                <button class="btn-icon" id="shareBtn">Teilen</button>
                <button class="btn-secondary" id="editCancelBtn">Abbrechen</button>
            </div>
            <div class="success" id="success" role="status"></div>
        </div>

        <div class="entries-section">
            <div class="entries-header">
                <h2 class="section-title">Meine Eintr√§ge</h2>
                <button class="selection-mode-btn" id="toggleSelectionBtn">Ausw√§hlen</button>
            </div>

            <div class="batch-actions" id="batchActions">
                <button class="btn-primary" id="summarizeSelectedBtn">Gesamt-Zusammenfassung</button>
                <button class="btn-primary" id="mergeSelectedBtn">Zusammenf√ºhren</button>
                <button class="btn-secondary" id="tagSelectedBtn">Tags setzen</button>
                <button class="btn-secondary" id="exportSelectedBtn">Exportieren</button>
                <button class="btn-secondary" id="shareSelectedBtn">Teilen</button>
                <button class="delete-btn" id="deleteSelectedBtn">L√∂schen</button>
            </div>

            <div class="tag-filter" id="tagFilter"></div>
            <div id="entries"></div>
        </div>
    </div>

    <!-- Edit Modal -->
    <div class="modal" id="editModal" role="dialog" aria-labelledby="editModalTitle">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="section-title" id="editModalTitle">Notiz bearbeiten</h2>
                <button class="modal-close" id="closeEditModal" aria-label="Schlie√üen">‚úï</button>
            </div>
            <textarea id="editText" aria-label="Text bearbeiten"></textarea>
            <div class="tags-section">
                <label>Verf√ºgbare Tags:</label>
                <div class="available-tags" id="editAvailableTags">
                </div>
                <label>Tags:</label>
                <div class="tags-input-group">
                    <input type="text" id="editNewTag" placeholder="Neuer Tag...">
                    <button class="btn-secondary" id="addEditTagBtn">+ Tag</button>
                </div>
                <div class="tag-list" id="editTags"></div>
            </div>
            <div class="loading" id="editDictateLoading" role="status">KI verarbeitet Diktat...</div>
            <div class="button-group">
                <button class="btn-icon" id="dictateEditBtn">üé§ √Ñnderung diktieren</button>
                <button class="btn-primary" id="saveEditBtn">Speichern</button>
                <button class="btn-secondary" id="cancelEditBtn">Abbrechen</button>
            </div>
            <div class="error" id="editError" role="alert"></div>
            <div class="success" id="editSuccess" role="status"></div>
        </div>
    </div>

    <!-- Batch Summary Modal -->
    <div class="modal" id="batchSummaryModal" role="dialog" aria-labelledby="batchSummaryTitle">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="section-title" id="batchSummaryTitle">Ergebnis der Stapelaktion</h2>
                <button class="modal-close" id="closeBatchSummaryModal" aria-label="Schlie√üen">‚úï</button>
            </div>
            <div class="loading show" id="batchSummaryLoading" role="status">KI erstellt Gesamt-Zusammenfassung...</div>
            <textarea id="batchSummaryText" style="display:none;" aria-label="Gesamt-Zusammenfassung"></textarea>
            <div class="button-group" id="batchSummaryActions" style="display:none;">
                <button class="btn-primary" id="saveBatchSummaryBtn">Als neue Notiz speichern</button>
                <button class="btn-icon" id="copyBatchSummaryBtn">Kopieren</button>
                <button class="btn-secondary" id="closeBatchSummaryBtn">Schlie√üen</button>
            </div>
            <div class="success" id="batchSummarySuccess" role="status"></div>
        </div>
    </div>
    
    <!-- Confirmation Modal -->
    <div class="modal" id="confirmModal" role="dialog" aria-labelledby="confirmTitle">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="section-title" id="confirmTitle">Best√§tigung</h2>
                <button class="modal-close" id="closeConfirmModal" aria-label="Schlie√üen">‚úï</button>
            </div>
            <p id="confirmMessage" style="margin-bottom: 20px;">Sind Sie sicher?</p>
            <div class="button-group">
                <button class="btn-primary" id="confirmYesBtn">Ja</button>
                <button class="btn-secondary" id="confirmNoBtn">Nein</button>
            </div>
        </div>
    </div>

    <script>
        // MediaRecorder State
        let __mr, __mrStream, __mrChunks = [], __mrRecording = false;
        
        let isEditDictating = false;

        let recognition;
        let isRecording = false;
        let currentTranscript = '';
        let currentLocation = null;
        let currentTags = [];
        let currentImageBase64 = null;
        let selectionMode = false;
        let selectedEntries = new Set();
        let editingEntryId = null;
        let activeTagFilter = null;
        let confirmCallback = null;
        let isApiSetupExpanded = false;

        const DIARY_KEY = 'diary_entries_v2';

        document.addEventListener('DOMContentLoaded', () => {
            loadAPIKey();
            loadLocationPermission();
            
            migrateStripImages();
            
            loadEntries();
            setupEventListeners();
            updateAvailableTags(); 
            
            initMediaRecorderFallback();
            initIOSFallback();
            
            updateNFCButton();
            updateNFCWriteButton();

            document.getElementById('diagnostics').classList.add('collapsed');
            
        });
        
        function migrateStripImages() {
          const entries = getEntries();
          let changed = false;
          entries.forEach(e => {
            if (e.image) { 
              delete e.image; 
              changed = true; 
            }
          });
          if (changed) {
            console.log('Migration durchgef√ºhrt: Alte Bildeintr√§ge entfernt.');
            saveEntries(entries);
          }
        }


        function getEntries() {
            const stored = localStorage.getItem(DIARY_KEY);
            let entries = stored ? JSON.parse(stored) : [];
            entries.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            return entries;
        }

        function saveEntries(entries) {
            localStorage.setItem(DIARY_KEY, JSON.stringify(entries));
            loadEntries();
            updateAvailableTags(); 
        }
        
        function toggleApiSetup() {
            isApiSetupExpanded = !isApiSetupExpanded;
            const setupEl = document.getElementById('apiSetup');
            const headerEl = document.getElementById('header');
            
            if (isApiSetupExpanded) {
                setupEl.classList.remove('collapsed');
                headerEl.classList.add('expanded');
                headerEl.classList.remove('collapsed');
            } else {
                setupEl.classList.add('collapsed');
                headerEl.classList.remove('expanded');
                headerEl.classList.add('collapsed');
            }
        }
        
        function checkAndSetApiSetupState() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const setupEl = document.getElementById('apiSetup');
            const headerEl = document.getElementById('header');
            
            if (apiKey && apiKey.length > 0) {
                isApiSetupExpanded = false; 
                setupEl.classList.add('collapsed');
                headerEl.classList.add('collapsed');
                headerEl.classList.remove('expanded'); 
            } else {
                isApiSetupExpanded = true; 
                setupEl.classList.remove('collapsed');
                headerEl.classList.remove('collapsed');
                headerEl.classList.add('expanded');
            }
        }
        
        function toggleDiagnostics() {
            const diag = document.getElementById('diagnostics');
            diag.classList.toggle('collapsed');
        }


        function setupEventListeners() {
            document.getElementById('headerTitle').addEventListener('click', toggleApiSetup);
            document.getElementById('diagHeader').addEventListener('click', toggleDiagnostics);
            
            document.getElementById('apiKey').addEventListener('change', saveAPIKey);
            document.getElementById('apiProvider').addEventListener('change', saveAPIKey);
            document.getElementById('recordBtn').addEventListener('click', toggleRecording);
            
            document.getElementById('saveBtn').addEventListener('click', saveEntry);
            document.getElementById('editCancelBtn').addEventListener('click', resetForm);
            
            document.getElementById('locationPermission').addEventListener('change', handleLocationPermission);
            
            document.getElementById('addTagBtn').addEventListener('click', addCurrentTag);
            document.getElementById('newTag').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addCurrentTag();
            });

            document.getElementById('copyBtn').addEventListener('click', copyToClipboard);
            document.getElementById('shareBtn').addEventListener('click', shareContent);
            document.getElementById('summary').addEventListener('input', updateNFCWriteButton);

            document.getElementById('toggleSelectionBtn').addEventListener('click', toggleSelectionMode);
            
            document.getElementById('summarizeSelectedBtn').addEventListener('click', summarizeSelected);
            document.getElementById('mergeSelectedBtn').addEventListener('click', mergeSelected);
            document.getElementById('tagSelectedBtn').addEventListener('click', tagSelected);
            document.getElementById('exportSelectedBtn').addEventListener('click', exportSelected);
            document.getElementById('shareSelectedBtn').addEventListener('click', shareSelected);
            document.getElementById('deleteSelectedBtn').addEventListener('click', deleteSelected);

            document.getElementById('closeEditModal').addEventListener('click', closeEditModal);
            document.getElementById('cancelEditBtn').addEventListener('click', closeEditModal);
            document.getElementById('saveEditBtn').addEventListener('click', saveEditedEntry);
            document.getElementById('addEditTagBtn').addEventListener('click', addEditTag);
            document.getElementById('editNewTag').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addEditTag();
            });
            
            document.getElementById('dictateEditBtn').addEventListener('click', toggleEditDictation);

            document.getElementById('closeBatchSummaryModal').addEventListener('click', closeBatchSummaryModal);
            document.getElementById('closeBatchSummaryBtn').addEventListener('click', closeBatchSummaryModal);
            document.getElementById('saveBatchSummaryBtn').addEventListener('click', saveBatchSummary);
            document.getElementById('copyBatchSummaryBtn').addEventListener('click', copyBatchSummary);
            
            document.getElementById('confirmYesBtn').addEventListener('click', () => {
                if (confirmCallback) {
                    const cb = confirmCallback;
                    closeConfirmModal();
                    cb();
                } else {
                    closeConfirmModal();
                }
            });
            document.getElementById('confirmNoBtn').addEventListener('click', closeConfirmModal);
            document.getElementById('closeConfirmModal').addEventListener('click', closeConfirmModal);

            const audioInput = document.getElementById('audioInput');
            audioInput.addEventListener('change', handleAudioFileSelection);
            
            const imageInput = document.getElementById('imageInput');
            document.getElementById('imageUploadBtn').addEventListener('click', () => {
                resetForm();
                imageInput.click();
            });
            imageInput.addEventListener('change', handleImageFileSelection);

            document.getElementById('photoToNfcBtn').addEventListener('click', () => {
                document.getElementById('photoToNfcInput').click();
            });
            document.getElementById('photoToNfcInput').addEventListener('change', handlePhotoToNfc);
            
            const nfcBtn = document.getElementById('nfcBtn');
            if (nfcBtn) nfcBtn.addEventListener('click', readNFC);
            
            const writeNFCBtn = document.getElementById('writeNFCBtn');
            if (writeNFCBtn) writeNFCBtn.addEventListener('click', writeNFC);
        }
        
        function updateNFCWriteButton() {
            const writeNFCBtn = document.getElementById('writeNFCBtn');
            if (!writeNFCBtn) return;
            
            const isNFCSupported = ('NDEFReader' in window);
            const hasText = document.getElementById('summary').value.trim().length > 0;
            
            if (isNFCSupported && hasText) {
                writeNFCBtn.style.display = 'inline-flex';
                writeNFCBtn.disabled = false;
            } else {
                writeNFCBtn.style.display = 'none';
                writeNFCBtn.disabled = true;
            }
        }


        function initSpeechRecognition() {} 
        
        function updateNFCButton() {
            const nfcBtn = document.getElementById('nfcBtn');
            if (nfcBtn && ('NDEFReader' in window)) {
                nfcBtn.style.display = 'inline-flex';
            } else if (nfcBtn) {
                nfcBtn.style.display = 'none';
            }
        }
        
        async function writeTextToNFC(textToWrite, buttonEl = null) {
            if (!('NDEFReader' in window)) {
                showError('NFC-Schreiben wird von diesem Ger√§t/Browser nicht unterst√ºtzt.');
                return false;
            }

            if (!textToWrite) {
                showError('Kein Text zum Schreiben auf den NFC-Tag vorhanden.');
                return false;
            }
            
            let originalText = buttonEl ? buttonEl.textContent : 'Auf NFC-Tag speichern üì≤';
            
            showSuccess('NFC-Tag zum Beschreiben bereithalten...');

            try {
                const ndef = new NDEFReader();
                await ndef.write(textToWrite);
                showSuccess('Daten erfolgreich auf NFC-Tag geschrieben!');
                return true;
                
            } catch (error) {
                let errMsg = `Fehler beim Schreiben: ${error.message}`;
                if (error.name === 'NotAllowedError') errMsg = 'NFC-Zugriff verweigert oder Tag nicht rechtzeitig gescannt.';
                else if (error.name === 'NotSupportedError') errMsg = 'Tag ist schreibgesch√ºtzt oder hat nicht genug Speicher.';
                showError(errMsg);
                return false;
            }
        }

        async function writeNFC() {
            const textToWrite = document.getElementById('summary').value.trim();
            const btn = document.getElementById('writeNFCBtn');
            await writeTextToNFC(textToWrite, btn);
        }

        async function writeEntryToNFC(id, buttonEl) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry || !entry.text) {
                showError('Eintrag nicht gefunden oder leer.');
                return;
            }
            await writeTextToNFC(entry.text, buttonEl);
        }
        
        function convertKeyValueToMarkdownTable(text) {
            const lines = text.trim().split('\n');
            let markdown = '| Merkmal | Wert |\n|---|---|\n';
            lines.forEach(line => {
                const parts = line.split(':');
                const key = parts[0] ? parts[0].trim() : '';
                const value = parts.length > 1 ? parts.slice(1).join(':').trim() : '';
                if (key) {
                    markdown += `| ${key} | ${value} |\n`;
                }
            });
            return markdown;
        }


        async function readNFC() {
            if (!('NDEFReader' in window)) {
                showError('NFC-Lesen wird von diesem Ger√§t/Browser nicht unterst√ºtzt.');
                return;
            }
            
            resetForm();
            updateRecordButton('NFC: Warte auf Tag-Scan...', 'processing');
            
            try {
                const ndef = new NDEFReader();
                await ndef.scan();
                
                ndef.onreadingerror = (e) => {
                    if (document.getElementById('status').textContent.includes('NFC')) {
                        showError('NFC Lese-Fehler: Tag ung√ºltig, leer, oder Scan abgebrochen.');
                        updateRecordButton('Bereit zur Aufnahme');
                    }
                };

                ndef.onreading = (e) => {
                    try { ndef.cancelScan(); } catch (_) {}
                    
                    const record = e.message.records[0];
                    if (record && record.recordType === 'text') {
                        const decoder = new TextDecoder();
                        const text = decoder.decode(record.data);
                        processNFCReadout(text);
                    } else {
                        showError('NFC-Tag enth√§lt keinen lesbaren Text.');
                        updateRecordButton('Bereit zur Aufnahme');
                    }
                };
                
            } catch (error) {
                const errMsg = `NFC-Fehler: ${error.message}`;
                showError(errMsg);
                updateRecordButton('Bereit zur Aufnahme');
            }
        }
        
        async function processNFCReadout(text) {
             let processedText = text;
             const isCompactFormat = text.includes('\n') && text.includes(':') && !text.includes('|---');

             if (isCompactFormat) {
                 try {
                     processedText = convertKeyValueToMarkdownTable(text);
                     showSuccess('Kompaktdaten vom NFC-Tag erkannt und in Tabelle umgewandelt.');
                 } catch (e) {
                     console.error("Fehler beim Umwandeln des NFC-Textes in eine Tabelle:", e);
                     processedText = text;
                 }
             }

             currentTranscript = processedText;
             const t = document.getElementById('transcript');
             if (t) t.value = currentTranscript;
             
             document.getElementById('transcriptTitle').textContent = 'NFC-Text (Wird automatisch verarbeitet...)';
             const ts = document.getElementById('transcriptSection');
             if (ts) ts.classList.add('show');
             
             document.getElementById('status').textContent = 'NFC-Inhalt erfasst. Erstelle Zusammenfassung...';
             await summarize(currentTranscript, null);
        }

        async function handleImageFileSelection(e) {
            const file = e.target.files && e.target.files[0];
            if (!file) return;

            const imagePreview = document.getElementById('imagePreview');
            const reader = new FileReader();

            reader.onload = async (event) => {
                imagePreview.src = event.target.result;
                imagePreview.style.display = 'block';
                
                currentImageBase64 = event.target.result; 
                
                document.getElementById('transcriptTitle').textContent = 'Bild-Beschreibung (Wird automatisch verarbeitet...)';
                document.getElementById('transcriptSection').classList.add('show');
                document.getElementById('status').textContent = 'Bild hochgeladen. Erstelle Beschreibung...';
                document.getElementById('status').classList.add('processing');
                
                try {
                    await summarize(null, file);
                } finally {
                    document.getElementById('status').classList.remove('processing');
                    imagePreview.src = '';
                    imagePreview.style.display = 'none';
                    currentImageBase64 = null; 
                }
                
                document.getElementById('transcriptSection').classList.remove('show');
            };

            reader.onerror = () => {
                showError('Fehler beim Lesen der Datei.');
                resetForm();
            };

            reader.readAsDataURL(file);
        }
        
        async function handlePhotoToNfc(e) {
            const file = e.target.files && e.target.files[0];
            if (!file) return;

            updateRecordButton('Foto wird analysiert...', 'processing');
            showSuccess('Foto wird analysiert, bitte warten...');

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            if (!apiKey) {
                showError('Bitte gib einen API-Schl√ºssel ein.');
                resetForm();
                return;
            }

            const extractionPrompt = `Analysiere das Bild. Extrahiere die Werte f√ºr die folgenden Merkmale. Gib deine Antwort NUR als Liste von "Merkmal:Wert"-Paaren zur√ºck, wobei jedes Paar in einer neuen Zeile steht. Lasse den Wert leer, wenn er nicht gefunden wird. F√ºge KEINE zus√§tzlichen Erkl√§rungen, Kommentare oder Formatierungen wie Markdown hinzu.

HK.Nr.:
KKS:
Leistung:
Strom:
Spannung:
Widerstand:
Regler:
Sicherheitsregler/Begrenzer:
W√§chter:
Projekt Nr.:
Anzahl Heizkabeleinheiten:
Trennkasten:
Heizkabeltyp:
Schaltung:
Me√üwertgeber:
PT 100:
NiCr-Ni:
gepr√ºft von:
am:`;
            
            const systemInstruction = "Du bist ein pr√§ziser Datenextraktions-Assistent. Deine einzige Aufgabe ist es, Daten aus einem Bild zu extrahieren und sie in dem vom Benutzer vorgegebenen kompakten Key-Value-Format zur√ºckzugeben.";

            try {
                const compactData = await callLLMAPI(extractionPrompt, apiKey, provider, 0, file, systemInstruction);
                
                if (!compactData || !compactData.includes(':')) {
                    throw new Error("Die KI hat keine g√ºltigen Daten zur√ºckgegeben.");
                }

                updateRecordButton('Analyse fertig. Schreibe auf NFC...', 'processing');
                const writeSuccess = await writeTextToNFC(compactData);
                
                if (writeSuccess) {
                    showSuccess('Daten erfolgreich auf NFC-Tag geschrieben!');
                }

            } catch (error) {
                showError('Fehler beim Extrahieren der Daten: ' + error.message);
            } finally {
                resetForm();
                e.target.value = '';
            }
        }


        async function imageToText(file, apiKey, provider) {
            const maxMB = 5;
            if (file.size > maxMB * 1024 * 1024) {
                throw new Error(`Bilddatei ist gr√∂√üer als ${maxMB} MB.`);
            }

            if (provider === 'openai' || provider === 'anthropic' || provider === 'gemini') {
                return callLLMAPI('Beschreibe dieses Bild detailliert.', apiKey, provider, 0, file);
            }

            throw new Error('Der ausgew√§hlte KI-Anbieter unterst√ºtzt m√∂glicherweise keine Bildanalyse.');
        }


        function toggleRecording() {
            if (isRecording) {
                stopMediaRecorder();
                isRecording = false;
                updateRecordButton('Bereit zur Aufnahme');
            } else {
                resetForm();
                startMediaRecorder().then(success => {
                    if (success) {
                        isRecording = true;
                        updateRecordButton('Aufnahme l√§uft...');
                    }
                });
            }
        }
        
        async function startMediaRecorder(onStopCallback = processAudioRecording) {
            try{
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                __mrStream = stream;
                
                const mime = MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' :
                             (MediaRecorder.isTypeSupported('audio/ogg') ? 'audio/ogg' : 
                             (MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4' : ''));

                if (!mime) {
                    showError('Ihr Browser unterst√ºtzt keine MediaRecorder-Formate f√ºr Audio.');
                    stopStream(__mrStream);
                    return false;
                }

                __mr = new MediaRecorder(stream, { mimeType: mime });
                __mrChunks = [];
                __mr.ondataavailable = e => { 
                    if(e.data && e.data.size > 0) __mrChunks.push(e.data); 
                };
                
                __mr.onerror = (e) => {
                    showError('Aufnahmefehler: ' + e.error.name, isEditDictating ? 'editError' : 'error');
                    stopStream(__mrStream);
                    __mrRecording = false;
                    isRecording = false;
                    isEditDictating = false;
                    updateRecordButton('Fehler.');
                    document.getElementById('dictateEditBtn').classList.remove('recording');
                };

                __mr.onstop = onStopCallback;

                __mr.start(500); 
                __mrRecording = true;
                return true;

            } catch(err){
                const errMsg = err.name === 'NotAllowedError' ? 'Mikrofonzugriff verweigert.' : (err.message || err);
                showError('Zugriff auf Mikrofon fehlgeschlagen: ' + errMsg, isEditDictating ? 'editError' : 'error');
                updateRecordButton('Bereit zur Aufnahme');
                return false;
            }
        }
        
        function stopMediaRecorder() {
            try{ 
                if (__mr && __mr.state === 'recording') {
                    __mr.stop(); 
                }
            }catch(_){}
            stopStream(__mrStream);
            __mrRecording = false;
        }

        async function processAudioRecording() {
            try{
                const blobType = __mr && __mr.mimeType ? __mr.mimeType : 'audio/webm';
                const blob = new Blob(__mrChunks, { type: blobType });
                const file = new File([blob], 'aufnahme.' + (blobType.includes('ogg') ? 'ogg' : 'webm'), { type: blobType });
                
                await processAudioFile(file);

            }catch(err){
                showError('Verarbeitung fehlgeschlagen: ' + (err.message || err));
                resetForm();
            }
        }
        
        async function processAudioFile(file) {
            document.getElementById('status').textContent = 'Audio-Datei gesendet. Warte auf KI-Transkription...';
            document.getElementById('status').classList.add('processing');
            document.getElementById('transcriptTitle').textContent = 'Transkription (Wird automatisch verarbeitet...)';
            
            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            if(!apiKey){ 
                showError('Bitte gib einen API-Schl√ºssel ein.'); 
                resetForm();
                return; 
            }
            
            let transcript;
            try {
                transcript = await transcribeAudio(file, apiKey, provider);
                currentTranscript = transcript || '';
                
                const t = document.getElementById('transcript');
                if (t) t.value = currentTranscript;
                const ts = document.getElementById('transcriptSection');
                if (ts) ts.classList.add('show');

            } catch(err) {
                 const errorMessage = 'Transkription fehlgeschlagen: ' + (err.message || err);
                showError(errorMessage);
                resetForm();
                return;
            }

            document.getElementById('status').textContent = 'Transkription abgeschlossen. Erstelle Zusammenfassung...';
            await summarize(currentTranscript, null);
            document.getElementById('status').classList.remove('processing');
        }


        async function handleAudioFileSelection(e) {
            const file = e.target.files && e.target.files[0];
            if (!file) return;

            if (!window.MediaRecorder) {
                await processAudioFile(file);
            }
        }

        function initMediaRecorderFallback(){ }
        function initIOSFallback() {
            const iosHint = document.getElementById('iosHint');
            const audioInput = document.getElementById('audioInput');
            if (iosHint && !window.MediaRecorder) {
                iosHint.style.display = 'block';
                document.getElementById('recordBtn').addEventListener('click', (e) => {
                    e.preventDefault();
                    if (!isRecording) {
                        audioInput.click();
                    }
                });
            }
        }
        
        function stopStream(stream){ 
            try{ if(stream) stream.getTracks().forEach(t=>t.stop()); }catch(_){} 
        }
        
        function updateRecordButton(statusText) {
            const btn = document.getElementById('recordBtn');
            const status = document.getElementById('status');
            const imgBtn = document.getElementById('imageUploadBtn');
            const nfcBtn = document.getElementById('nfcBtn');
            const photoToNfcBtn = document.getElementById('photoToNfcBtn');


            if (status) status.textContent = statusText;

            if (statusText.includes('Aufnahme l√§uft')) {
                if (btn) {
                    btn.classList.add('recording');
                    btn.textContent = '‚èπÔ∏è';
                    btn.setAttribute('aria-label', 'Aufnahme stoppen');
                }
            } else {
                 if (btn) {
                    btn.classList.remove('recording');
                    btn.textContent = 'üé§';
                    btn.setAttribute('aria-label', 'Aufnahme starten');
                }
            }

            const isProcessing = statusText.includes('Warte auf KI') || 
                                 statusText.includes('Erstelle Zusammenfassung') || 
                                 statusText.includes('Verarbeite') || 
                                 statusText.includes('NFC') ||
                                 statusText.includes('analysiert') ||
                                 statusText.includes('Analyse') ||
                                 statusText.includes('Beschreibung');

            if (isProcessing) {
                 if (status) status.classList.add('processing');
                 if (btn) btn.disabled = true;
                 if (imgBtn) imgBtn.disabled = true;
                 if (nfcBtn) nfcBtn.disabled = true;
                 if (photoToNfcBtn) photoToNfcBtn.disabled = true;


            } else {
                 if (status) status.classList.remove('processing');
                 if (btn) btn.disabled = false;
                 if (imgBtn) imgBtn.disabled = false;
                 if (nfcBtn) nfcBtn.disabled = false;
                 if (photoToNfcBtn) photoToNfcBtn.disabled = false;
            }
        }


        function getCurrentLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        currentLocation = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude
                        };
                    },
                    (error) => {
                        console.error('Location error:', error);
                        currentLocation = null;
                    }
                );
            }
        }

        function saveLocationPermission(isChecked) {
            localStorage.setItem('location_permission', isChecked ? 'true' : 'false');
        }

        function loadLocationPermission() {
            const permissionCheckbox = document.getElementById('locationPermission');
            const storedValue = localStorage.getItem('location_permission');
            
            if (storedValue === 'true') {
                permissionCheckbox.checked = true;
            } else {
                permissionCheckbox.checked = false;
            }
        }
        
        function handleLocationPermission() {
            const permissionCheckbox = document.getElementById('locationPermission');
            const isChecked = permissionCheckbox.checked;

            saveLocationPermission(isChecked);

            if (isChecked) {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        () => {},
                        (error) => {
                            console.error('Location permission denied:', error);
                            permissionCheckbox.checked = false;
                            saveLocationPermission(false);
                            showError('Standort-Berechtigung wurde verweigert oder ist nicht verf√ºgbar.');
                        }
                    );
                } else {
                    showError('Geolocation wird von diesem Browser nicht unterst√ºtzt.');
                    permissionCheckbox.checked = false;
                    saveLocationPermission(false);
                }
            }
        }

        async function summarize(transcript, imageFile) {
            if (!transcript && !imageFile) { 
                showError('Kein Transkript oder Bild vorhanden.'); 
                resetForm();
                return; 
            }

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { 
                showError('Bitte gib einen API-Schl√ºssel ein.'); 
                resetForm();
                return; 
            }

            document.getElementById('loading').classList.add('show');
            document.getElementById('error').classList.remove('show');
            document.getElementById('summarySection').classList.add('show');
            
            if (imageFile) {
                 document.getElementById('status').textContent = 'KI erstellt Bildbeschreibung...';
            } else if (transcript) {
                 document.getElementById('status').textContent = 'KI erstellt Zusammenfassung...';
            }

            try {
                let summary = '';
                if (imageFile) {
                    summary = await imageToText(imageFile, apiKey, provider);
                } else if (transcript) {
                    summary = await callLLMAPI(transcript, apiKey, provider);
                }

                document.getElementById('summary').value = summary;
                document.getElementById('loading').classList.remove('show');
                
                updateRecordButton(imageFile ? 'Bildbeschreibung fertig!' : 'Zusammenfassung fertig!');
                
                currentTags = [];
                updateCurrentTags();
                updateNFCWriteButton();
                
            } catch (error) {
                const errorMessage = 'Fehler beim Erstellen der Notiz: ' + error.message;
                showError(errorMessage);
                document.getElementById('loading').classList.remove('show');
                resetForm();
            }
        }

        function addCurrentTag() {
            const tagInput = document.getElementById('newTag');
            const tag = tagInput.value.trim();
            if (tag && !currentTags.includes(tag)) {
                currentTags.push(tag);
                updateCurrentTags();
                tagInput.value = '';
            }
        }

        function updateCurrentTags() {
            const container = document.getElementById('currentTags');
            container.innerHTML = '';
            currentTags.forEach(tag => {
                const wrap = document.createElement('div');
                wrap.className = 'tag';
                const txt = document.createElement('span');
                txt.textContent = tag;
                const btn = document.createElement('button');
                btn.className = 'tag-remove';
                btn.textContent = '√ó';
                btn.setAttribute('aria-label', `Tag ${tag} entfernen`);
                btn.addEventListener('click', () => removeCurrentTag(tag));
                wrap.appendChild(txt);
                wrap.appendChild(btn);
                container.appendChild(wrap);
            });
            updateAvailableTags();
        }

        function removeCurrentTag(tag) {
            currentTags = currentTags.filter(t => t !== tag);
            updateCurrentTags();
        }
        
        function updateAvailableTags() {
            const allEntries = getEntries();
            const allTags = new Set();
            allEntries.forEach(entry => {
                if (entry.tags) entry.tags.forEach(tag => allTags.add(tag));
            });

            const container = document.getElementById('availableTags');
            renderTagSuggestions(container, allTags, tag => {
                if (!currentTags.includes(tag)) {
                    currentTags.push(tag);
                } else {
                    currentTags = currentTags.filter(t => t !== tag);
                }
                updateCurrentTags();
            }, currentTags);
            
            const editContainer = document.getElementById('editAvailableTags');
            const tagsForEditModal = editingEntryId ? getEntries().find(e => e.id === editingEntryId)?.tags || [] : currentTags;
            renderTagSuggestions(editContainer, allTags, tag => {
                if (!currentTags.includes(tag)) {
                    currentTags.push(tag);
                } else {
                    currentTags = currentTags.filter(t => t !== tag);
                }
                updateEditTags();
            }, tagsForEditModal);

            updateTagFilter(allEntries);
        }

        function renderTagSuggestions(container, tags, clickHandler, activeTags) {
            container.innerHTML = '';
            Array.from(tags).sort().forEach(tag => {
                const tagEl = document.createElement('div');
                tagEl.className = `tag-suggestion ${activeTags.includes(tag) ? 'active' : ''}`;
                tagEl.textContent = tag;
                tagEl.addEventListener('click', () => clickHandler(tag));
                container.appendChild(tagEl);
            });
        }


        function addEditTag() {
            const tagInput = document.getElementById('editNewTag');
            const tag = tagInput.value.trim();
            if (tag && !currentTags.includes(tag)) {
                currentTags.push(tag);
                updateEditTags();
                tagInput.value = '';
            }
        }

        function updateEditTags() {
            const container = document.getElementById('editTags');
            container.innerHTML = '';
            currentTags.forEach(tag => {
                const wrap = document.createElement('div');
                wrap.className = 'tag';
                const txt = document.createElement('span');
                txt.textContent = tag;
                const btn = document.createElement('button');
                btn.className = 'tag-remove';
                btn.textContent = '√ó';
                btn.setAttribute('aria-label', `Tag ${tag} entfernen`);
                btn.addEventListener('click', () => removeEditTag(tag));
                wrap.appendChild(txt);
                wrap.appendChild(btn);
                container.appendChild(wrap);
            });
            updateAvailableTags();
        }

        function removeEditTag(tag) {
            currentTags = currentTags.filter(t => t !== tag);
            updateEditTags();
        }

        function saveEntry() {
            const summary = document.getElementById('summary').value.trim();

            if (!summary) { 
                showError('Bitte gib Text ein (Zusammenfassung).');
                return;
            }

            const entries = getEntries();
            const newEntry = {
                id: Date.now().toString(),
                text: summary || '',
                image: null,
                tags: [...currentTags], 
                location: currentLocation,
                timestamp: new Date().toISOString(),
                transcript: currentTranscript || '' 
            };

            entries.unshift(newEntry);
            saveEntries(entries);

            showSuccess('Notiz gespeichert!');
            resetForm(); 
        }

        function deleteEntry(id) {
            showConfirmModal('Eintrag wirklich l√∂schen?', () => {
                const entries = getEntries().filter(e => e.id !== id);
                saveEntries(entries);
                showSuccess('Eintrag gel√∂scht!');
            });
        }

        function editEntry(id) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry) return;

            editingEntryId = id;
            document.getElementById('editText').value = entry.text;
            document.getElementById('editModal').classList.add('show');
            document.getElementById('editError').classList.remove('show');
            document.getElementById('editSuccess').classList.remove('show');
            
            currentTags = entry.tags ? [...entry.tags] : [];
            updateEditTags();
            updateAvailableTags();
        }

        function saveEditedEntry() {
            const text = document.getElementById('editText').value.trim();
            if (!text) { showError('Text darf nicht leer sein.', 'editError'); return; }

            const entries = getEntries();
            const entryIndex = entries.findIndex(e => e.id === editingEntryId);

            if (entryIndex > -1) {
                entries[entryIndex].text = text;
                entries[entryIndex].tags = [...currentTags];
                saveEntries(entries);
                
                showSuccess('Eintrag aktualisiert!', 'editSuccess');
                setTimeout(() => closeEditModal(), 1000);
            }
        }

        function closeEditModal() {
            if(isEditDictating) {
                stopMediaRecorder();
                isEditDictating = false;
            }
            document.getElementById('dictateEditBtn').classList.remove('recording');
            document.getElementById('editModal').classList.remove('show');
            editingEntryId = null;
            currentTags = [];
        }
        
        async function toggleEditDictation() {
            const btn = document.getElementById('dictateEditBtn');
            if (isEditDictating) {
                stopMediaRecorder();
                isEditDictating = false;
                btn.classList.remove('recording');
                btn.textContent = 'üé§ √Ñnderung diktieren';
            } else {
                const recordingStarted = await startMediaRecorder(processEditDictation);
                if (recordingStarted) {
                    isEditDictating = true;
                    btn.classList.add('recording');
                    btn.textContent = '‚èπÔ∏è Aufnahme stoppen';
                }
            }
        }

        async function processEditDictation() {
            isEditDictating = false;
            const btn = document.getElementById('dictateEditBtn');
            btn.classList.remove('recording');
            btn.textContent = 'üé§ √Ñnderung diktieren';

            try {
                const blobType = __mr && __mr.mimeType ? __mr.mimeType : 'audio/webm';
                const blob = new Blob(__mrChunks, { type: blobType });
                const file = new File([blob], 'diktat.' + (blobType.includes('ogg') ? 'ogg' : 'webm'), { type: blobType });
                
                await applyDictatedChanges(file);

            } catch (err) {
                showError('Verarbeitung des Diktats fehlgeschlagen: ' + (err.message || err), 'editError');
            }
        }
        
        async function applyDictatedChanges(audioFile) {
            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            if (!apiKey) {
                showError('API-Schl√ºssel ben√∂tigt.', 'editError');
                return;
            }

            const loadingEl = document.getElementById('editDictateLoading');
            loadingEl.classList.add('show');
            
            try {
                const instructionText = await transcribeAudio(audioFile, apiKey, provider);
                if (!instructionText) {
                    throw new Error("Transkription ergab keinen Text.");
                }

                const originalText = document.getElementById('editText').value;
                const prompt = `Du bist ein intelligenter Text-Editor. Modifiziere den "Originaltext" basierend auf der diktierten "Anweisung". Gib NUR den finalen, vollst√§ndigen und ge√§nderten Text zur√ºck, ohne zus√§tzliche Kommentare.

                Originaltext:
                ---
                ${originalText}
                ---

                Anweisung:
                ---
                ${instructionText}
                ---

                Finaler Text:`;

                const modifiedText = await callLLMAPI(prompt, apiKey, provider);
                document.getElementById('editText').value = modifiedText;
                showSuccess('Text per Diktat aktualisiert!', 'editSuccess');

            } catch(error) {
                showError('Fehler bei der diktierten √Ñnderung: ' + error.message, 'editError');
            } finally {
                loadingEl.classList.remove('show');
            }
        }


        async function copyEntry(id) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry) return;

            let textToCopy = entry.text;
            if (entry.image) {
                textToCopy = `[Bild-Notiz]\n${textToCopy}`;
            }

            try {
                await navigator.clipboard.writeText(textToCopy);
                showSuccess('In Zwischenablage kopiert!');
            } catch (error) {
                showError('Fehler beim Kopieren: ' + error.message);
            }
        }

        async function shareEntry(id) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry) return;
            
            let textToShare = entry.text;
            if (entry.image) {
                textToShare = `[Bild-Notiz]\n${textToShare}`;
            }

            if (navigator.share) {
                try {
                    await navigator.share({ title: 'Sprach-Tagebuch Notiz', text: textToShare });
                } catch (error) {
                    console.log('Sharing cancelled');
                }
            } else {
                showError('Teilen wird in diesem Browser nicht unterst√ºtzt.');
            }
        }

        function loadEntries() {
            let entries = getEntries();
            
            if (activeTagFilter) {
                entries = entries.filter(e => e.tags && e.tags.includes(activeTagFilter));
            }

            renderEntries(entries);
        }

        function renderEntries(entries) {
            const container = document.getElementById('entries');
            container.innerHTML = '';
            
            const converter = new showdown.Converter({ tables: true, simpleLineBreaks: true });

            if (entries.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'empty-state';
                empty.textContent = 'Noch keine Eintr√§ge vorhanden.\nNimm deine erste Notiz auf!';
                container.appendChild(empty);
                return;
            }

            entries.forEach(entry => {
                const entryDiv = document.createElement('div');
                entryDiv.className = `entry ${selectionMode ? 'selection-mode' : ''}`;

                if (selectionMode) {
                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.className = 'entry-checkbox';
                    cb.checked = selectedEntries.has(entry.id);
                    cb.setAttribute('aria-label', `Notiz vom ${new Date(entry.timestamp).toLocaleDateString('de-DE')} ausw√§hlen`);
                    cb.addEventListener('change', e => {
                        if (e.target.checked) selectedEntries.add(entry.id);
                        else selectedEntries.delete(e.target.id);
                        updateBatchActionsVisibility();
                    });
                    entryDiv.appendChild(cb);
                }

                const header = document.createElement('div');
                header.className = 'entry-header';
                const dateDiv = document.createElement('div');
                const dateEl = document.createElement('div');
                dateEl.className = 'entry-date';
                dateEl.textContent = new Date(entry.timestamp).toLocaleDateString('de-DE', {
                    day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit'
                });
                dateDiv.appendChild(dateEl);

                if (entry.location) {
                    const locEl = document.createElement('div');
                    locEl.className = 'entry-location';
                    locEl.textContent = `üìç ${entry.location.latitude.toFixed(4)}, ${entry.location.longitude.toFixed(4)}`;
                    dateDiv.appendChild(locEl);
                }
                header.appendChild(dateDiv);
                entryDiv.appendChild(header);
                
                if (entry.image) {
                     const img = document.createElement('img');
                     img.className = 'entry-image';
                     img.src = entry.image;
                     img.alt = entry.text.substring(0, 50) + '...';
                     entryDiv.appendChild(img);
                }


                if (entry.tags && entry.tags.length > 0) {
                    const tagsDiv = document.createElement('div');
                    tagsDiv.className = 'entry-tags';
                    entry.tags.forEach(tag => {
                        const tagEl = document.createElement('div');
                        tagEl.className = 'tag';
                        tagEl.textContent = tag;
                        tagsDiv.appendChild(tagEl);
                    });
                    entryDiv.appendChild(tagsDiv);
                }

                const textEl = document.createElement('div');
                textEl.className = 'entry-text';
                
                const html = converter.makeHtml(entry.text || '');
                textEl.innerHTML = html;

                const isLongText = (entry.text || '').split('\n').length > 5 || (entry.text || '').length > 300;
                if (isLongText) {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'entry-text-wrapper';
                    textEl.classList.add('collapsed');
                    
                    const overlay = document.createElement('div');
                    overlay.className = 'expand-overlay';

                    wrapper.appendChild(textEl);
                    wrapper.appendChild(overlay);
                    entryDiv.appendChild(wrapper);
                } else {
                    entryDiv.appendChild(textEl);
                }

                const actions = document.createElement('div');
                actions.className = 'entry-actions';
                
                const btnConfigs = [
                    ['Bearbeiten', 'btn-icon', () => editEntry(entry.id)],
                    ['Kopieren', 'btn-icon', () => copyEntry(entry.id)],
                    ['Teilen', 'btn-icon', () => shareEntry(entry.id)]
                ];

                if ('NDEFReader' in window) {
                    btnConfigs.push(['Auf NFC schreiben', 'btn-icon', (btn) => writeEntryToNFC(entry.id, btn)]);
                }

                btnConfigs.push(['L√∂schen', 'delete-btn', () => deleteEntry(entry.id)]);

                btnConfigs.forEach(([label, className, handler]) => {
                    const btn = document.createElement('button');
                    btn.className = className;
                    btn.textContent = label;
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        handler();
                    });
                    actions.appendChild(btn);
                });

                entryDiv.appendChild(actions);

                entryDiv.addEventListener('click', (e) => {
                    if (e.target.closest('button, input, a')) {
                        return;
                    }
                    entryDiv.classList.toggle('expanded');
                });

                container.appendChild(entryDiv);
            });
        }

        function updateTagFilter(allEntries) {
            const allTags = new Set();
            allEntries.forEach(entry => {
                if (entry.tags) entry.tags.forEach(tag => allTags.add(tag));
            });

            const container = document.getElementById('tagFilter');
            container.innerHTML = '';
            
            if (allTags.size === 0 && !activeTagFilter) return;

            const allBtn = document.createElement('div');
            allBtn.className = `filter-tag ${!activeTagFilter ? 'active' : ''}`;
            allBtn.textContent = 'Alle';
            allBtn.addEventListener('click', () => filterByTag(null));
            container.appendChild(allBtn);

            Array.from(allTags).forEach(tag => {
                const tagBtn = document.createElement('div');
            tagBtn.className = `filter-tag ${activeTagFilter === tag ? 'active' : ''}`;
                tagBtn.textContent = tag;
                tagBtn.addEventListener('click', () => filterByTag(tag));
                container.appendChild(tagBtn);
            });
        }

        function filterByTag(tag) {
            activeTagFilter = tag;
            loadEntries();
            updateTagFilter(getEntries());
        }

        function toggleSelectionMode() {
            selectionMode = !selectionMode;
            selectedEntries.clear();
            
            const btn = document.getElementById('toggleSelectionBtn');
            btn.textContent = selectionMode ? 'Fertig' : 'Ausw√§hlen';
            
            loadEntries();
            updateBatchActionsVisibility();
        }

        function updateBatchActionsVisibility() {
            const batchActions = document.getElementById('batchActions');
            if (selectionMode && selectedEntries.size > 0) {
                batchActions.classList.add('show');
            } else {
                batchActions.classList.remove('show');
            }
        }

        async function summarizeSelected() {
            const allEntries = getEntries();
            const entries = allEntries.filter(e => selectedEntries.has(e.id));
            if (entries.length === 0) return;

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { showError('Bitte gib einen API-Schl√ºssel ein.'); return; }
            
            document.getElementById('batchSummaryTitle').textContent = 'Gesamt-Zusammenfassung';
            document.getElementById('batchSummaryModal').classList.add('show');
            document.getElementById('batchSummaryText').style.display = 'none';
            document.getElementById('batchSummaryActions').style.display = 'none';
            document.getElementById('batchSummaryLoading').classList.add('show');
            document.getElementById('batchSummarySuccess').classList.remove('show');

            try {
                const combinedText = entries.map((e, i) => {
                    const imgNote = e.image ? ' [Bild-Notiz enthalten]' : '';
                    return `Notiz ${i + 1} (${new Date(e.timestamp).toLocaleDateString('de-DE')})${imgNote}:\n${e.text}`;
                }).join('\n\n---\n\n');
                
                const prompt = `Erstelle eine pr√§gnante Gesamt-Zusammenfassung der folgenden ${entries.length} Notizen. Identifiziere gemeinsame Themen und wichtige Erkenntnisse:\n\n${combinedText}`;

                let summary = await callLLMAPI(prompt, apiKey, provider, 0, null);

                document.getElementById('batchSummaryLoading').classList.remove('show');
                document.getElementById('batchSummaryText').value = summary;
                document.getElementById('batchSummaryText').style.display = 'block';
                document.getElementById('batchSummaryActions').style.display = 'flex';
            } catch (error) {
                document.getElementById('batchSummaryLoading').classList.remove('show');
                showError('Fehler beim Zusammenfassen: ' + error.message, 'batchSummarySuccess');
            }
        }
        
        async function mergeSelected() {
            const allEntries = getEntries();
            const entries = allEntries.filter(e => selectedEntries.has(e.id));
            if (entries.length === 0) return;

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { showError('Bitte gib einen API-Schl√ºssel ein.'); return; }
            
            document.getElementById('batchSummaryTitle').textContent = 'Zusammenf√ºhrung (Daten-Kompilation)';
            document.getElementById('batchSummaryModal').classList.add('show');
            document.getElementById('batchSummaryText').style.display = 'none';
            document.getElementById('batchSummaryActions').style.display = 'none';
            document.getElementById('batchSummaryLoading').classList.add('show');
            document.getElementById('batchSummarySuccess').classList.remove('show');
            document.getElementById('batchSummaryLoading').textContent = 'KI f√ºhrt Eintr√§ge zusammen...';


            try {
                const combinedText = entries.map((e, i) => {
                    const imgNote = e.image ? ' [Bild-Notiz enthalten]' : '';
                    return `--- Eintrag ${i + 1}${imgNote} ---\n${e.text}`;
                }).join('\n\n');
                
                const prompt = `F√ºhre die folgenden ${entries.length} Notizen zusammen, ohne Informationen zu verlieren oder zu verallgemeinern. Deine Aufgabe ist die detailgetreue Kompilation.
                
                Wichtige Regeln:
                1. KEINE Zusammenfassung, KEINE Verallgemeinerung.
                2. Wenn es sich um Listen (z.B. Einkaufslisten, To-Do-Listen) handelt, kompiliere diese direkt in EINE EINZIGE, VOLLST√ÑNDIGE Liste.
                3. Erhalte alle spezifischen Details (z.B. genaue Produktnamen, Zahlen, Adressen).
                
                Texte zum Zusammenf√ºhren:
                
                ${combinedText}`;

                let result = await callLLMAPI(prompt, apiKey, provider, 0, null);

                document.getElementById('batchSummaryLoading').classList.remove('show');
                document.getElementById('batchSummaryText').value = result;
                document.getElementById('batchSummaryText').style.display = 'block';
                document.getElementById('batchSummaryActions').style.display = 'flex';
            } catch (error) {
                document.getElementById('batchSummaryLoading').classList.remove('show');
                showError('Fehler beim Zusammenf√ºhren: ' + error.message, 'batchSummarySuccess');
            }
        }


        function saveBatchSummary() {
            const summary = document.getElementById('batchSummaryText').value.trim();
            if (!summary) return;

            const entry = {
                id: Date.now().toString(),
                text: summary,
                timestamp: new Date().toISOString(),
                location: null,
                tags: [document.getElementById('batchSummaryTitle').textContent.includes('Zusammenfassung') ? 'Zusammenfassung' : 'Kompilation'],
                transcript: `${document.getElementById('batchSummaryTitle').textContent} von ${selectedEntries.size} Notizen`,
                image: null
            };

            const entries = getEntries();
            entries.unshift(entry);
            saveEntries(entries);

            showSuccess('Ergebnis gespeichert!', 'batchSummarySuccess');
            setTimeout(() => closeBatchSummaryModal(), 1000);
        }

        function closeBatchSummaryModal() {
            document.getElementById('batchSummaryModal').classList.remove('show');
            document.getElementById('batchSummaryText').value = '';
            document.getElementById('batchSummaryText').style.display = 'none';
            document.getElementById('batchSummaryActions').style.display = 'none';
            document.getElementById('batchSummaryLoading').classList.add('show');
            document.getElementById('batchSummaryTitle').textContent = 'Ergebnis der Stapelaktion';
            document.getElementById('batchSummaryLoading').textContent = 'KI erstellt Gesamt-Zusammenfassung...';
        }

        function copyBatchSummary() {
            const text = document.getElementById('batchSummaryText').value;
            if (!text) return;
            navigator.clipboard.writeText(text).then(() => {
                showSuccess('In Zwischenablage kopiert!', 'batchSummarySuccess');
            }).catch(() => {
                showError('Fehler beim Kopieren.', 'batchSummarySuccess');
            });
        }

        function deleteSelected() {
            if (selectedEntries.size === 0) return;

            showConfirmModal(`${selectedEntries.size} Eintr√§ge wirklich l√∂schen?`, () => {
                const entries = getEntries().filter(e => !selectedEntries.has(e.id));
                saveEntries(entries);
                
                selectedEntries.clear();
                toggleSelectionMode();
                showSuccess('Ausgew√§hlte Eintr√§ge gel√∂scht!');
            });
        }

        function tagSelected() {
            const tag = prompt('Tag f√ºr ausgew√§hlte Eintr√§ge:');
            if (!tag || selectedEntries.size === 0) return;

            const entries = getEntries();
            let changed = false;
            entries.forEach(entry => {
                if (selectedEntries.has(entry.id)) {
                    if (!entry.tags) entry.tags = [];
                    if (!entry.tags.includes(tag)) {
                        entry.tags.push(tag);
                        changed = true;
                    }
                }
            });
            
            if (changed) {
                saveEntries(entries);
                showSuccess('Tags hinzugef√ºgt!');
            }
        }

        function exportSelected() {
            const allEntries = getEntries();
            const entries = allEntries.filter(e => selectedEntries.has(e.id));
            if (entries.length === 0) return;

            const text = entries.map(e => {
                const date = new Date(e.timestamp).toLocaleString('de-DE');
                const tags = e.tags ? `\nTags: ${e.tags.join(', ')}` : '';
                const location = e.location ? `\nStandort: ${e.location.latitude}, ${e.location.longitude}` : '';
                const image = e.image ? `\n[Bild-Notiz enthalten]` : '';
                return `=== ${date} ===${image}${tags}${location}\n\n${e.text}`;
            }).join('\n\n' + '='.repeat(50) + '\n\n');

            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `notizen_${new Date().toISOString().split('T')[0]}.txt`;
            a.click();
            URL.revokeObjectURL(url);

            showSuccess('Exportiert!');
        }

        async function shareSelected() {
            const allEntries = getEntries();
            const entries = allEntries.filter(e => selectedEntries.has(e.id));
            if (entries.length === 0) return;

            const text = entries.map(e => {
                const date = new Date(e.timestamp).toLocaleDateString('de-DE');
                const image = e.image ? '[Bild-Notiz] ' : '';
                return `${date}: ${image}\n${e.text}`;
            }).join('\n\n---\n\n');

            if (navigator.share) {
                try {
                    await navigator.share({ title: 'Meine Notizen', text: text });
                } catch (error) {
                    console.log('Sharing cancelled');
                }
            } else {
                showError('Teilen wird in diesem Browser nicht unterst√ºtzt.');
            }
        }

        function saveAPIKey() {
            localStorage.setItem('api_key', document.getElementById('apiKey').value);
            localStorage.setItem('api_provider', document.getElementById('apiProvider').value);
            checkAndSetApiSetupState();
        }

        function loadAPIKey() {
            const apiKey = localStorage.getItem('api_key');
            const provider = localStorage.getItem('api_provider');
            if (apiKey) document.getElementById('apiKey').value = apiKey;
            if (provider) document.getElementById('apiProvider').value = provider;
            
            checkAndSetApiSetupState();
        }

        function showError(message, targetId = 'error') {
            const errorEl = document.getElementById(targetId);
            errorEl.textContent = message;
            errorEl.classList.add('show');
            setTimeout(() => errorEl.classList.remove('show'), 5000);
        }

        function showSuccess(message, targetId = 'success') {
            const successEl = document.getElementById(targetId);
            successEl.textContent = message;
            successEl.classList.add('show');
            setTimeout(() => successEl.classList.remove('show'), 3000);
        }

        function showConfirmModal(message, callback) {
            document.getElementById('confirmMessage').textContent = message;
            document.getElementById('confirmModal').classList.add('show');
            confirmCallback = callback;
        }

        function closeConfirmModal() {
            document.getElementById('confirmModal').classList.remove('show');
            confirmCallback = null;
        }

        async function copyToClipboard() {
            const text = document.getElementById('summary').value;
            try {
                await navigator.clipboard.writeText(text);
                showSuccess('In Zwischenablage kopiert!');
            } catch (error) {
                showError('Fehler beim Kopieren: ' + error.message);
            }
        }

        async function shareContent() {
            const text = document.getElementById('summary').value;
            if (navigator.share) {
                try {
                    await navigator.share({ title: 'Sprach-Tagebuch Notiz', text: text });
                } catch (error) {
                    console.log('Sharing cancelled');
                }
            } else {
                showError('Teilen wird in diesem Browser nicht unterst√ºtzt.');
            }
        }

        function resetForm() {
            currentTranscript = '';
            currentLocation = null;
            currentTags = [];
            currentImageBase64 = null;
            document.getElementById('transcript').value = '';
            document.getElementById('summary').value = '';
            document.getElementById('newTag').value = '';
            document.getElementById('transcriptSection').classList.remove('show');
            document.getElementById('summarySection').classList.remove('show');
            
            const imagePreview = document.getElementById('imagePreview');
            imagePreview.src = '';
            imagePreview.style.display = 'none';
            
            updateRecordButton('Bereit zur Aufnahme');
            
            updateCurrentTags();
            document.getElementById('error').classList.remove('show');
            document.getElementById('success').classList.remove('show');
            
            updateNFCWriteButton();
        }
    </script>
    
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js', { scope: '/captain/' })
                    .then(reg => {
                        console.log('Service Worker registriert:', reg.scope);
                        if (reg.waiting) { reg.waiting.postMessage('SKIP_WAITING'); }
                        reg.addEventListener('updatefound', () => {
                            const nw = reg.installing;
                            if (nw) {
                                nw.addEventListener('statechange', () => {
                                    if (nw.state === 'installed' && reg.waiting) {
                                        reg.waiting.postMessage('SKIP_WAITING');
                                    }
                                });
                            }
                        });
                    })
                    .catch(err => console.error('SW Fehler:', err));

                navigator.serviceWorker.addEventListener('controllerchange', () => {
                    console.log('Neue Version aktiv ‚Äì Seite wird aktualisiert‚Ä¶');
                    window.location.reload();
                });
            });
        }
    </script>

    <!-- KI API Logik -->
    <script>
        function handleAPIResponse(provider, data) {
            if (provider === 'anthropic') {
                const textBlock = data.content?.find(block => block.type === 'text');
                return textBlock?.text || 'Fehler: Anthropic-Antwort konnte nicht gelesen werden.';
            } else if (provider === 'openai') {
                return data.choices?.[0]?.message?.content || 'Fehler: OpenAI-Antwort konnte nicht gelesen werden.';
            } else if (provider === 'gemini') {
                if (data.promptFeedback?.blockReason) {
                    const reason = data.promptFeedback.blockReason;
                    const userMessage = "Die KI hat die Anfrage wegen Sicherheitsbedenken blockiert. Versuchen Sie eine andere Formulierung.";
                    return `Fehler: ${userMessage}`; 
                }

                const candidate = data.candidates?.[0];
                if (candidate) {
                    const finishReason = candidate.finishReason;
                    if (finishReason && finishReason !== 'STOP' && finishReason !== 'MAX_TOKENS') {
                        const userMessage = `Die KI hat die Antwort aus Sicherheitsgr√ºnden gestoppt (Grund: ${finishReason}).`;
                        return `Fehler: ${userMessage}`;
                    }

                    const text = candidate.content?.parts?.[0]?.text;
                    if (text) {
                        return text;
                    }
                }
                
                return 'Fehler beim Parsen der Gemini-Antwort (kein Inhalt gefunden).';

            }
            return 'Fehler: Unbekannter KI-Anbieter.';
        }
        
        function dataURLtoParts(dataURL) {
            const parts = dataURL.split(';base64,');
            if (parts.length < 2) throw new Error("Ung√ºltiges Data-URL-Format.");
            const mime = parts[0].split(':')[1];
            const base64 = parts[1];
            return { mimeType: mime, data: base64 };
        }


        async function callLLMAPI(userPrompt, apiKey, provider, retryCount = 0, imageFile = null, systemInstructionOverride = null) {
            let url = '';
            let headers = {};
            let body = {};
            let model = '';
            let systemInstruction = systemInstructionOverride || 'Du bist ein freundlicher, pr√§gnanter Assistent, der Notizen zusammenfasst, umformuliert oder Bilder detailliert beschreibt. Deine Antwort soll nur die gew√ºnschte Ausgabe enthalten, ohne einleitenden Text wie "Hier ist die Zusammenfassung". Antworte auf Deutsch.';
            
            let imageParts = null;
            if (imageFile) {
                const base64Url = await new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.readAsDataURL(imageFile);
                });
                imageParts = dataURLtoParts(base64Url);
            }


            if (provider === 'anthropic') {
                url = 'https://api.anthropic.com/v1/messages';
                model = 'claude-3-5-sonnet-20240620';
                
                let content = [{ type: 'text', text: userPrompt }];
                if (imageParts) {
                    content.unshift({
                        type: 'image',
                        source: {
                            type: 'base64',
                            media_type: imageParts.mimeType,
                            data: imageParts.data
                        }
                    });
                }
                
                headers = {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01'
                };
                body = {
                    model: model,
                    max_tokens: 2000,
                    system: systemInstruction,
                    messages: [
                        { role: 'user', content: content }
                    ]
                };
                
            } else if (provider === 'openai') {
                url = 'https://api.openai.com/v1/chat/completions';
                model = 'gpt-4o';
                
                let content = [{ type: 'text', text: userPrompt }];
                if (currentImageBase64) {
                    content.push({
                        type: 'image_url',
                        image_url: {
                            url: currentImageBase64,
                            detail: "low" 
                        }
                    });
                } else if (imageParts) {
                     content.push({
                        type: 'image_url',
                        image_url: {
                            url: `data:${imageParts.mimeType};base64,${imageParts.data}`,
                            detail: "auto"
                        }
                    });
                }

                headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                };
                body = {
                    model: model,
                    messages: [
                        { role: 'system', content: systemInstruction },
                        { role: 'user', content: content }
                    ],
                    max_tokens: 2000
                };
            } else if (provider === 'gemini') {
                url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
                model = 'gemini-2.5-flash';
                headers = {
                    'Content-Type': 'application/json'
                };
                
                let parts = [{ text: userPrompt }];
                if (imageParts) {
                     parts.push({
                         inlineData: { mimeType: imageParts.mimeType, data: imageParts.data }
                     });
                }

                body = {
                    contents: [{ parts: parts }],
                    systemInstruction: { parts: [{ text: systemInstruction }] },
                    generationConfig: { maxOutputTokens: 2000 }
                };
            } else {
                throw new Error('Unbekannter KI-Anbieter ausgew√§hlt.');
            }
            
            try {
                if(window.__memotag?.diag) {
                    __memotag.diag.diagLog(`Starte API-Aufruf zu ${provider} mit Modell ${model}...`);
                }
            } catch(_) {}


            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(body)
                });

                const data = await response.json();

                if (!response.ok) {
                    const errorMsg = data.error?.message || data.error?.type || 'Unbekannter Fehler';
                    throw new Error(`API-Fehler (${response.status}): ${errorMsg}`);
                }

                const resultText = handleAPIResponse(provider, data);
                if (resultText.startsWith('Fehler')) {
                     throw new Error(resultText);
                }
                
                return resultText;

            } catch (error) {
                if (retryCount < 3 && (error.message.includes('Failed to fetch') || error.message.includes('Timeout'))) {
                    const delay = Math.pow(2, retryCount) * 1000;
                    console.warn(`API-Aufruf fehlgeschlagen. Versuche es in ${delay}ms erneut...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return callLLMAPI(userPrompt, apiKey, provider, retryCount + 1, imageFile, systemInstructionOverride);
                }
                throw error;
            }
        }
    </script>
    
<section class="diag-card collapsed" id="diagnostics">
  <h3 style="margin-top:0" id="diagHeader">Diagnose <span class="toggle-icon">‚ñº</span></h3>
  <div class="diag-content" id="diagContent">
      <div class="diag-grid">
        <div>Zustand</div>
        <div><span id="diag-state" class="state-badge state-warn">bereit</span></div>

        <div>Mikrofon-Pegel</div>
        <div class="level-wrap"><div id="diag-level" class="level-bar anim"></div></div>

        <div>Letzter Fehler</div>
        <div id="diag-last-error">‚Äì</div>

        <div>Ereignis-Log</div>
        <div id="diag-log" aria-live="polite"></div>
      </div>
  </div>
</section>


<script id="diag-script">
  (function(){
    const $state = () => document.getElementById('diag-state');
    const $log = () => document.getElementById('diag-log');
    const $err = () => document.getElementById('diag-last-error');
    const $lvl = () => document.getElementById('diag-level');

    window.__memotag = window.__memotag || {};
    let audioCtx, analyser, micStream, rafId;
    let lowLevelStart = null;

    function ts(){
      const d = new Date();
      return d.toLocaleTimeString();
    }

    function diagSetState(text, cls){
      const el = $state();
      if(!el) return;
      el.textContent = text;
      el.classList.remove('state-ok','state-warn','state-err');
      el.classList.add(cls || 'state-warn');
    }

    function diagLog(msg){
      const el = $log();
      if(!el) return;
      const line = document.createElement('div');
      line.className = 'line';
      line.textContent = `[${ts()}] ${msg}`;
      el.prepend(line);
      const nodes = el.querySelectorAll('.line');
      if(nodes.length > 60) el.removeChild(nodes[nodes.length-1]);
    }

    function diagError(msg){
      const el = $err();
      if(el) el.textContent = msg || '‚Äì';
      diagSetState('Fehler', 'state-err');
      diagLog('ERROR: ' + msg);
    }

    async function startMicMeter(){
      try{
        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
          diagLog('getUserMedia nicht verf√ºgbar');
          return;
        }
        micStream = await navigator.mediaDevices.getUserMedia({audio:true});
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        const source = audioCtx.createMediaStreamSource(micStream);
        source.connect(analyser);
        const data = new Uint8Array(analyser.fftSize);

        function tick(){
          analyser.getByteTimeDomainData(data);
          let sum = 0;
          for(let i=0;i<data.length;i++){ const v = (data[i]-128)/128; sum += v*v; }
          const rms = Math.sqrt(sum/data.length);
          const pct = Math.min(100, Math.max(0, Math.round(rms*180)));
          const bar = $lvl();
          if(bar){ bar.style.width = pct + '%'; }
          if(pct < 5){
            if(!lowLevelStart) lowLevelStart = performance.now();
            else if(performance.now() - lowLevelStart > 3000){
              diagLog('Hinweis: Sehr niedriger Pegel erkannt (Mikro weit weg? stumm?)');
              lowLevelStart = null;
            }
          } else {
            lowLevelStart = null;
          }
          rafId = requestAnimationFrame(tick);
        }
        tick();
        diagLog('Mic-Meter gestartet');
      }catch(e){
        diagError('Mic-Meter Fehler: ' + e.message);
      }
    }

    function stopMicMeter(){
      if(rafId) cancelAnimationFrame(rafId);
      rafId = null;
      try { if(micStream){ micStream.getTracks().forEach(t=>t.stop()); } } catch(e){}
      try { if(audioCtx){ audioCtx.close(); } } catch(e){}
      const bar = $lvl();
      if(bar){ bar.style.width = '0%'; }
      diagLog('Mic-Meter gestoppt');
    }

    window.__memotag.diag = { diagSetState, diagLog, diagError, startMicMeter, stopMicMeter };
  })();
</script>


<script>
document.addEventListener('DOMContentLoaded', () => {
    const hash = location.hash;
    if (hash === '#new') {
        const b = document.getElementById('recordBtn');
        if (b) { b.scrollIntoView({behavior:'smooth', block:'center'}); b.focus(); }
    } else if (hash === '#entries') {
        const e = document.querySelector('.entries-section');
        if (e) e.scrollIntoView({behavior:'smooth', block:'start'});
    }
});
</script>
<script>
function isIOS() {
    return /iPhone|iPad|iPod/i.test(navigator.userAgent);
}

async function fileToBase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = error => reject(error);
        reader.readAsDataURL(file);
    });
}


function normalizeMime(file) {
    const t = (file.type || '').toLowerCase();
    if (t) return t;
    const name = (file.name || '').toLowerCase();
    if (name.endsWith('.m4a')) return 'audio/mp4';
    if (name.endsWith('.mp3')) return 'audio/mpeg';
    if (name.endsWith('.wav')) return 'audio/wav';
    if (name.endsWith('.ogg')) return 'audio/ogg';
    if (name.endsWith('.webm')) return 'audio/webm';
    if (name.endsWith('.png')) return 'image/png';
    if (name.endsWith('.jpg') || name.endsWith('.jpeg')) return 'image/jpeg';
    return 'application/octet-stream';
}


async function transcribeAudio(file, apiKey, provider) {
    const maxMB = 20;
    if (file.size > maxMB * 1024 * 1024) {
        throw new Error(`Audiodatei ist gr√∂√üer als ${maxMB} MB.`);
    }

    if (provider === 'openai') {
        const url = 'https://api.openai.com/v1/audio/transcriptions';
        const form = new FormData();
        form.append('file', file, file.name || 'audio.m4a');
        form.append('model', 'whisper-1');
        form.append('language', 'de');
        const resp = await fetch(url, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${apiKey}` },
            body: form
        });
        const data = await resp.json();
        if (!resp.ok) {
            const msg = data.error?.message || 'Unbekannter Fehler';
            throw new Error(`OpenAI-Fehler (${resp.status}): ${msg}`);
        }
        return data.text || '';
    }

    if (provider === 'anthropic') {
        const url = 'https://api.anthropic.com/v1/messages';
        const b64 = await fileToBase64(file);
        const mime = normalizeMime(file);
        const body = {
            model: 'claude-3-5-haiku-latest',
            max_tokens: 2000,
            system: 'Du bist ein pr√§ziser Transkriptionsassistent. Transkribiere nur den gesprochenen deutschen Text, ohne Zusatz.',
            messages: [{
                role: 'user',
                content: [
                    { type: 'text', text: 'Transkribiere dieses Audio auf Deutsch.' },
                    { type: 'image', source: { type: 'base64', data: b64, media_type: mime } }
                ]
            }]
        };
        const resp = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': apiKey,
                'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify(body)
        });
        const data = await resp.json();
        if (!resp.ok) {
            const msg = data.error?.message || data.error?.type || 'Unbekannter Fehler';
            throw new Error(`Anthropic-Fehler (${resp.status}): ${msg}`);
        }
        const block = (data.content || []).find(b => b.type === 'text');
        return (block && block.text) || '';
    }

    if (provider === 'gemini') {
        const mime = normalizeMime(file);
        const b64 = await fileToBase64(file);
        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
        const body = {
            contents: [{
                parts: [
                    { text: 'Transkribiere dieses Audio auf Deutsch. Antworte nur mit dem reinen Transkript.' },
                    { inlineData: { mimeType: mime, data: b64 } }
                ]
            }],
            generationConfig: { maxOutputTokens: 2000 }
        };
        const resp = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });
        const data = await resp.json();
        if (!resp.ok) {
            const msg = data.error?.message || 'Unbekannter Fehler';
            throw new Error(`Gemini-Fehler (${resp.status}): ${msg}`);
        }
        const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
        return text;
    }

    throw new Error('Unbekannter KI-Anbieter f√ºr Audio-Transkription.');
}
</script>
<script>
function stopStream(stream){ try{ if(stream) stream.getTracks().forEach(t=>t.stop()); }catch(_){} }

function initMediaRecorderFallback() {
    // Diese Funktion pr√ºft, ob eine Alternative (Fallback) f√ºr die Audio-Aufnahme ben√∂tigt wird.
    // Eine Log-Nachricht wird nur ausgegeben, wenn die MediaRecorder-API nicht vom Browser unterst√ºtzt wird.
    if (!('MediaRecorder' in window)) {
        try {
            if (window.__memotag?.diag) {
                window.__memotag.diag.diagLog('Hinweis: MediaRecorder nicht unterst√ºtzt. Fallback wird aktiviert.');
            }
        } catch(_) {
            // Fehler beim Loggen werden ignoriert.
        }
    }
}
</script>
</body>
</html>
