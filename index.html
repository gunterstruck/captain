<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#4F46E5">
    <meta name="description" content="Sprach-Tagebuch mit KI-Zusammenfassungen und Bild-Notizen">
    <title>Sprach-Tagebuch Pro</title>
    <link rel="manifest" href="manifest.webmanifest">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        /* AKTUELLE ABSCHNITTE MIT ANPASSUNG DES ABSTANDES */
        .header,
        .record-section,
        /* .transcript-section, .summary-section sind jetzt unten in ihrer eigenen Regel */
        .entries-section {
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            /* NEU: Einheitlicher, reduzierter Abstand von 12px zwischen den Sektionen */
            margin-bottom: 12px; 
            padding: 20px; /* Standard-Padding f√ºr Header, Eintr√§ge, etc. */
        }
        
        /* Spezifisches Padding f√ºr Record Section, da sie den gro√üen Button hat */
        .record-section {
            padding: 30px;
            text-align: center;
        }
        
        /* Spezifisches Padding f√ºr Header */
        .header {
             padding: 20px;
        }
        
        /* Spezifisches Padding f√ºr Eintr√§ge Section */
        .entries-section {
             padding: 20px;
        }

        h1 {
            color: #4F46E5;
            font-size: 28px;
            margin-bottom: 15px;
            overflow-wrap: break-word;
            cursor: pointer; 
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .settings-icon {
            font-size: 20px;
            color: #4F46E5;
            transition: transform 0.3s;
        }

        /* NEU: Icon ist beim Start eingeklappt (rotiert) */
        .header:not(.expanded) .settings-icon {
            transform: rotate(-90deg); /* Zeigt den Pfeil nach unten/rechts */
        }
        /* Wenn aufgeklappt (expanded), zeigt der Pfeil nach oben/links */
        .header.expanded .settings-icon {
            transform: rotate(0deg); /* Zeigt das Zahnrad aufrecht im aufgeklappten Zustand */
        }


        .api-setup {
            /* Hintergrundfarbe entfernt, da sie nicht ben√∂tigt wird, wenn die √§u√üere Karte wei√ü ist und die inneren Elemente ihren eigenen Hintergrund haben */
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            transition: max-height 0.5s ease-out, opacity 0.5s ease-out, padding 0.5s ease-out, margin-bottom 0.5s ease-out;
            overflow: hidden;
            max-height: 500px; 
            opacity: 1;
        }
        
        /* NEU: Hintergrund f√ºr die API-Eingabefelder */
        .api-setup .input-group input,
        .api-setup .input-group select {
             /* Helle, neutrale Farbe, die vorher f√§lschlicherweise knallpink war */
            background-color: #F3F4F6;
        }


        .api-setup.collapsed {
            max-height: 0 !important;
            opacity: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            margin-bottom: 0 !important;
        }

        .input-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            font-size: 14px;
            color: #374151;
            margin-bottom: 5px;
            font-weight: 500;
        }

        input[type="text"], input[type="password"], select, textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #E5E7EB;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #4F46E5;
        }
        
        /* ALTE REGELN ENTFERNT UND ZUSAMMENGEFASST OBEN */
        
        .record-button {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            font-size: 48px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px auto 10px; /* Abstand nach unten reduziert */
        }

        .record-button:hover {
            transform: scale(1.05);
        }

        .record-button:focus {
            outline: 3px solid #818CF8;
            outline-offset: 3px;
        }

        .record-button.recording {
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .status {
            font-size: 16px;
            color: #6B7280;
            margin-top: 10px;
        }
        
        /* Neuer Status f√ºr laufende KI-Verarbeitung */
        .processing {
            color: #4F46E5;
            font-weight: 601;
        }


        /* NEUE REGEL: Standardm√§√üig komplett kollabiert, KEIN Margin/Padding */
        .transcript-section, .summary-section {
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            opacity: 0;
            height: 0;
            overflow: hidden;
            pointer-events: none;
            /* NEU: margin und padding im kollabierten Zustand entfernen */
            margin: 0;          
            padding: 0;
            transition: opacity 0.5s ease-in-out, height 0.5s ease-in-out, padding 0.5s ease-in-out, margin-bottom 0.5s ease-in-out;
        }

        /* NEUE REGEL: Im .show-Zustand wieder Margin/Padding/H√∂he geben */
        .transcript-section.show, .summary-section.show {
            opacity: 1;
            height: auto;
            pointer-events: all;
            margin-bottom: 12px; 
            padding: 20px;
        }

        .section-title {
            font-size: 18px;
            color: #4F46E5;
            margin-bottom: 15px;
            font-weight: 600;
        }

        textarea {
            min-height: 150px;
            resize: vertical;
            font-family: inherit;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        button:focus {
            outline: 2px solid #4F46E5;
            outline-offset: 2px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex: 1;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #F3F4F6;
            color: #374151;
            flex: 1;
        }

        .btn-secondary:hover {
            background: #E5E7EB;
        }

        .btn-icon {
            background: #F3F4F6;
            color: #374151;
            padding: 10px 15px;
            flex: 1;
        }

        .btn-icon:hover {
            background: #E5E7EB;
        }
        
        /* NEUER STIL F√úR AKTIONEN UNTER DEM RECORD BUTTON */
        .record-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 10px;
        }
        
        .record-actions button {
            padding: 8px 15px;
            font-size: 14px;
            flex: 0 0 auto;
        }

        .tags-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #F3F4F6;
        }
        
        /* Neuer Stil f√ºr Tag-Vorschl√§ge */
        .available-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: #F9FAFB;
            border-radius: 8px;
        }
        
        .tag-suggestion {
            background: #E0E7FF;
            color: #4F46E5;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .tag-suggestion:hover {
            background: #C7D2FE;
        }
        
        .tag-suggestion.active {
            background: #4F46E5;
            color: white;
            border-color: #4F46E5;
        }


        .tags-input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .tags-input-group input {
            flex: 1;
        }

        .tags-input-group button {
            flex: 0 0 auto;
        }

        .tag-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .tag {
            background: #EEF2FF;
            color: #4F46E5;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tag-remove {
            background: none;
            border: none;
            color: #4F46E5;
            cursor: pointer;
            padding: 0;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-size: 12px;
        }

        .tag-remove:hover {
            background: #4F46E5;
            color: white;
        }

        .reformulate-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #F3F4F6;
        }

        .reformulate-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .entries-section {
            /* Das margin-bottom von 12px wird bereits oben im Sammelselektor angewendet */
        }

        .entries-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .tag-filter {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        /* NEUE STILE F√úR AKTIVEN FILTER TAG */
        .filter-tag {
            background: #F3F4F6;
            color: #374151;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .filter-tag:hover {
            background: #E5E7EB;
        }

        .filter-tag.active {
            background: #4F46E5;
            color: white;
            border-color: #4F46E5;
        }

        .selection-mode-btn {
            background: #4F46E5;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
        }

        .batch-actions {
            display: none;
            background: #FEF3C7;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            gap: 10px;
            flex-wrap: wrap;
        }

        .batch-actions.show {
            display: flex;
        }

        .batch-actions button {
            flex: 0 0 auto;
            padding: 8px 16px;
            font-size: 13px;
        }

        .entry {
            background: #F9FAFB;
            padding: 15px;
            border-left: 4px solid #4F46E5;
            position: relative;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .entry.selection-mode {
            padding-left: 50px;
        }

        .entry-checkbox {
            position: absolute;
            left: 15px;
            top: 20px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .entry-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
            gap: 10px;
        }

        .entry-date {
            font-size: 14px;
            color: #4F46E5;
            font-weight: 600;
        }

        .entry-location {
            font-size: 12px;
            color: #6B7280;
            margin-top: 2px;
        }

        .entry-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 8px 0;
        }

        .entry-text {
            color: #374151;
            line-height: 1.6;
            white-space: pre-wrap;
            margin-bottom: 10px;
        }
        
        /* NEU: Bild-Vorschau in Eintr√§gen */
        .entry-image {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 10px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .entry-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .entry-actions button {
            padding: 6px 12px;
            font-size: 12px;
        }

        .delete-btn {
            background: #EF4444;
            color: white;
        }

        .delete-btn:hover {
            background: #DC2626;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #9CA3AF;
        }

        .loading {
            display: none;
            text-align: center;
            color: #6B7280;
            padding: 10px;
        }

        .loading.show {
            display: block;
        }

        .error {
            background: #FEE2E2;
            color: #991B1B;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            display: none;
        }

        .error.show {
            display: block;
        }

        .success {
            background: #D1FAE5;
            color: #065F46;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            display: none;
        }

        .success.show {
            display: block;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-close {
            background: #F3F4F6;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
        }
        
        /* NEU: Stil f√ºr die Bildvorschau beim Hochladen */
        #imagePreview {
            max-width: 100%;
            max-height: 200px; 
            margin: 15px auto 5px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            display: none;
        }


        @media (max-width: 640px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 22px;
            }
            
            .button-group, .reformulate-buttons {
                flex-direction: column;
            }
            
            .btn-icon {
                flex: 1 1 100%;
            }

            .tags-input-group {
                flex-direction: column;
            }

            .tags-input-group button {
                flex: 1 1 100%;
            }
            
            .record-actions {
                flex-direction: column;
            }
        }
    </style>

<style id="diag-styles">
  /* Diagnostik Styles (Collapsible) */
  .diag-card { 
      margin: 16px auto; 
      max-width: 900px; 
      background: rgba(255,255,255,0.9); 
      border-radius: 16px; 
      padding: 16px; 
      box-shadow: 0 6px 24px rgba(0,0,0,0.08); 
      /* NEU: Auch hier einen kleinen margin-bottom nutzen */
      margin-bottom: 12px !important; 
  }
  .diag-card h3 {
      cursor: pointer;
      margin-top: 0;
      margin-bottom: 0; 
      display: flex;
      align-items: center;
      justify-content: space-between;
  }
  .diag-card h3 .toggle-icon {
      font-size: 14px;
      transition: transform 0.3s;
      margin-left: 8px;
      transform: rotate(0deg);
  }
  .diag-card.collapsed h3 .toggle-icon {
      transform: rotate(-90deg);
  }

  .diag-content {
      transition: max-height 0.5s ease-in-out, opacity 0.5s ease-in-out, padding-top 0.5s ease-in-out;
      max-height: 1000px; 
      overflow: hidden;
      opacity: 1;
      padding-top: 16px;
  }
  .diag-card.collapsed .diag-content {
      max-height: 0;
      opacity: 0;
      padding-top: 0;
  }
    
  .diag-grid { display: grid; grid-template-columns: 160px 1fr; gap: 8px 16px; align-items: center; }
  .state-badge { display:inline-block; padding:4px 10px; border-radius:999px; font-size:12px; font-weight:600; }
  .state-ok { background:#e6f7ef; color:#0a7f4f; }
  .state-warn { background:#fff4e6; color:#a15a00; }
  .state-err { background:#ffe8e6; color:#b50000; }
  .level-wrap { width:100%; height:10px; background:#eee; border-radius:6px; overflow:hidden; }
  .level-bar.anim { background: linear-gradient(90deg, #a78bfa, #7c3aed); }
  #diag-log { max-height: 140px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:12px; background:#fafafa; border:1px solid #eee; border-radius:8px; padding:8px; }
  #diag-log .line { padding:2px 0; border-bottom:1px dashed #eee;}
  #diag-last-error { color:#b50000; font-weight:600; }
</style>


    <link rel="apple-touch-icon" href="icon-192.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
</head>
<body>
    <div class="container">
        <!-- NEU: Header-Div erh√§lt die Klasse 'expanded' beim Laden, wenn kein API-Schl√ºssel hinterlegt ist -->
        <div class="header collapsed" id="header"> <!-- HIER IST DIE WICHTIGE √ÑNDERUNG: collapsed ist jetzt standardm√§√üig gesetzt -->
            <!-- NEU: Klickbares H1 f√ºr Toggle -->
            <h1 id="headerTitle">
                Sprach-Tagebuch Pro
                <span class="settings-icon" id="settingsIcon">‚öôÔ∏è</span>
            </h1>
            
            <div class="api-setup collapsed" id="apiSetup"> <!-- HIER IST DIE WICHTIGE √ÑNDERUNG: collapsed ist standardm√§√üig gesetzt -->
                <div class="input-group">
                    <label for="apiProvider">KI-Anbieter:</label>
                    <select id="apiProvider">
                        <option value="anthropic">Anthropic (Claude)</option>
                        <option value="openai">OpenAI (GPT)</option>
                        <option value="gemini">Google (Gemini)</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="apiKey">API-Schl√ºssel:</label>
                    <input type="password" id="apiKey" placeholder="Dein API-Schl√ºssel">
                </div>
                <div class="input-group">
                    <label>
                        <input type="checkbox" id="locationPermission">
                        Standort-Freigabe (optional)
                    </label>
                </div>
            </div>
        </div>

        <div class="record-section">
            <h2 class="section-title">Neue Notiz aufnehmen</h2>
            <button class="record-button" id="recordBtn" aria-label="Aufnahme starten">üé§</button>
            
            <!-- NEU: Bild-Vorschau -->
            <img id="imagePreview" src="" alt="Hochgeladenes Bild" />

            <div class="record-actions">
                <!-- Bild Upload Button -->
                <button class="btn-secondary" id="imageUploadBtn">üñºÔ∏è Bild hochladen</button>
                <!-- Nur noch ein verstecktes Input-Feld f√ºr den Audio-Upload-Fallback -->
                <input type="file" id="audioInput" accept="audio/*" capture="microphone" style="display:none;">
                <!-- NEU: Verstecktes Input-Feld f√ºr den Bild-Upload -->
                <input type="file" id="imageInput" accept="image/*" style="display:none;">
                
                <!-- NFC-Button (nur sichtbar, wenn Web NFC API unterst√ºtzt wird) -->
                <button class="btn-secondary" id="nfcBtn" style="display:none;">NFC-Tag lesen üì≤</button>
            </div>


            <div id="iosHint" class="status" style="display:none;">Mobile Ger√§te erkannt: Tippe auf das Mikrofon-Symbol, um die Aufnahme zu starten oder eine Audiodatei auszuw√§hlen.</div>
            
            <div class="status" id="status" role="status" aria-live="polite">Bereit zur Aufnahme</div>
        </div>

        <div class="transcript-section" id="transcriptSection">
            <h2 class="section-title" id="transcriptTitle">Transkription (Wird automatisch verarbeitet...)</h2>
            <textarea id="transcript" readonly aria-label="Transkribierter Text"></textarea>
            <!-- Buttons entfernt, da der Prozess jetzt automatisch in die Zusammenfassung √ºbergeht -->
            <div class="loading" id="loading" role="status">KI erstellt Zusammenfassung...</div>
            <div class="error" id="error" role="alert"></div>
        </div>

        <div class="summary-section" id="summarySection">
            <h2 class="section-title">Zusammenfassung</h2>
            <textarea id="summary" aria-label="Zusammenfassung bearbeiten"></textarea>
            
            <div class="tags-section">
                <label>Verf√ºgbare Tags:</label>
                <div class="available-tags" id="availableTags">
                    <!-- Hier werden die Tags per JavaScript eingef√ºgt -->
                </div>

                <label>Tags hinzuf√ºgen:</label>
                <div class="tags-input-group">
                    <input type="text" id="newTag" placeholder="z.B. Arbeit, Einkauf, Idee...">
                    <button class="btn-secondary" id="addTagBtn">+ Tag</button>
                </div>
                <div class="tag-list" id="currentTags"></div>
            </div>

            <div class="reformulate-section">
                <label>Neu formulieren:</label>
                <div class="reformulate-buttons">
                    <button class="btn-icon" id="reformulateShorter">K√ºrzer</button>
                    <button class="btn-icon" id="reformulateFormal">Formeller</button>
                    <button class="btn-icon" id="reformulateCasual">Lockerer</button>
                </div>
                <div class="loading" id="reformulateLoading" role="status">KI formuliert um...</div>
            </div>

            <div class="button-group">
                <button class="btn-primary" id="saveBtn">Speichern</button>
                <button class="btn-icon" id="copyBtn">Kopieren</button>
                <button class="btn-icon" id="shareBtn">Teilen</button>
                <button class="btn-secondary" id="editCancelBtn">Abbrechen</button>
            </div>
            <div class="success" id="success" role="status"></div>
        </div>

        <div class="entries-section">
            <div class="entries-header">
                <h2 class="section-title">Meine Eintr√§ge</h2>
                <button class="selection-mode-btn" id="toggleSelectionBtn">Ausw√§hlen</button>
            </div>

            <div class="batch-actions" id="batchActions">
                <button class="btn-primary" id="summarizeSelectedBtn">Gesamt-Zusammenfassung</button>
                <button class="btn-primary" id="mergeSelectedBtn">Zusammenf√ºhren</button>
                <button class="btn-secondary" id="tagSelectedBtn">Tags setzen</button>
                <button class="btn-secondary" id="exportSelectedBtn">Exportieren</button>
                <button class="btn-secondary" id="shareSelectedBtn">Teilen</button>
                <button class="delete-btn" id="deleteSelectedBtn">L√∂schen</button>
            </div>

            <div class="tag-filter" id="tagFilter"></div>
            <div id="entries"></div>
        </div>
    </div>

    <!-- Edit Modal -->
    <div class="modal" id="editModal" role="dialog" aria-labelledby="editModalTitle">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="section-title" id="editModalTitle">Notiz bearbeiten</h2>
                <button class="modal-close" id="closeEditModal" aria-label="Schlie√üen">‚úï</button>
            </div>
            <textarea id="editText" aria-label="Text bearbeiten"></textarea>
            <div class="tags-section">
                <label>Verf√ºgbare Tags:</label>
                <div class="available-tags" id="editAvailableTags">
                    <!-- Hier werden die Tags per JavaScript eingef√ºgt -->
                </div>
                <label>Tags:</label>
                <div class="tags-input-group">
                    <input type="text" id="editNewTag" placeholder="Neuer Tag...">
                    <button class="btn-secondary" id="addEditTagBtn">+ Tag</button>
                </div>
                <div class="tag-list" id="editTags"></div>
            </div>
            <div class="button-group">
                <button class="btn-primary" id="saveEditBtn">Speichern</button>
                <button class="btn-secondary" id="cancelEditBtn">Abbrechen</button>
            </div>
            <div class="error" id="editError" role="alert"></div>
            <div class="success" id="editSuccess" role="status"></div>
        </div>
    </div>

    <!-- Batch Summary Modal -->
    <div class="modal" id="batchSummaryModal" role="dialog" aria-labelledby="batchSummaryTitle">
        <div class="modal-content">
            <div class="modal-header">
                <!-- Titel wird dynamisch in JS gesetzt (Zusammenfassung vs. Zusammenf√ºhrung) -->
                <h2 class="section-title" id="batchSummaryTitle">Ergebnis der Stapelaktion</h2>
                <button class="modal-close" id="closeBatchSummaryModal" aria-label="Schlie√üen">‚úï</button>
            </div>
            <div class="loading show" id="batchSummaryLoading" role="status">KI erstellt Gesamt-Zusammenfassung...</div>
            <textarea id="batchSummaryText" style="display:none;" aria-label="Gesamt-Zusammenfassung"></textarea>
            <div class="button-group" id="batchSummaryActions" style="display:none;">
                <button class="btn-primary" id="saveBatchSummaryBtn">Als neue Notiz speichern</button>
                <button class="btn-icon" id="copyBatchSummaryBtn">Kopieren</button>
                <button class="btn-secondary" id="closeBatchSummaryBtn">Schlie√üen</button>
            </div>
            <div class="success" id="batchSummarySuccess" role="status"></div>
        </div>
    </div>
    
    <!-- Confirmation Modal -->
    <div class="modal" id="confirmModal" role="dialog" aria-labelledby="confirmTitle">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="section-title" id="confirmTitle">Best√§tigung</h2>
                <button class="modal-close" id="closeConfirmModal" aria-label="Schlie√üen">‚úï</button>
            </div>
            <p id="confirmMessage" style="margin-bottom: 20px;">Sind Sie sicher?</p>
            <div class="button-group">
                <button class="btn-primary" id="confirmYesBtn">Ja</button>
                <button class="btn-secondary" id="confirmNoBtn">Nein</button>
            </div>
        </div>
    </div>

    <script>
        // MediaRecorder State
        let __mr, __mrStream, __mrChunks = [], __mrRecording = false;

        let recognition; // recognition bleibt, aber wird nicht mehr prim√§r genutzt
        let isRecording = false;
        let currentTranscript = '';
        let currentLocation = null;
        let currentTags = [];
        let currentImageBase64 = null; // Speichert das Base64-Bild f√ºr die Notiz (tempor√§r f√ºr KI-Call)
        let selectionMode = false;
        let selectedEntries = new Set();
        let editingEntryId = null;
        let activeTagFilter = null;
        let confirmCallback = null;
        let isApiSetupExpanded = false; // Standardm√§√üig auf FALSE gesetzt!

        const DIARY_KEY = 'diary_entries_v2';

        document.addEventListener('DOMContentLoaded', () => {
            loadAPIKey(); // <--- API Key und Provider werden geladen
            loadLocationPermission(); // NEU: Standort-Pr√§ferenz wird geladen
            
            migrateStripImages(); // NEU: Alte Bilder aus dem Speicher entfernen
            
            loadEntries();
            // initSpeechRecognition(); // Entfernt, da Live-SR wegf√§llt
            setupEventListeners();
            updateAvailableTags(); 
            
            // Wichtiger Aufruf, um die MediaRecorder-Logik zu initialisieren
            initMediaRecorderFallback();
            initIOSFallback(); // Beh√§lt das Audio-Upload-Handling
            
            // NEU: NFC Button nur zeigen, wenn API da ist
            updateNFCButton();

            // NEU: Diagnose beim Start einklappen
            document.getElementById('diagnostics').classList.add('collapsed');
            
            // Die Logik zum Aufklappen wird jetzt von loadAPIKey aufgerufen, 
            // damit der DOM-Wert des Keys gelesen werden kann.
        });
        
        // NEUE FUNKTION: Entfernt alle Bilder aus den gespeicherten Eintr√§gen
        function migrateStripImages() {
          const entries = getEntries();
          let changed = false;
          entries.forEach(e => {
            if (e.image) { 
              delete e.image; 
              changed = true; 
            }
          });
          if (changed) {
            console.log('Migration durchgef√ºhrt: Alte Bildeintr√§ge entfernt.');
            saveEntries(entries);
          }
        }


        function getEntries() {
            const stored = localStorage.getItem(DIARY_KEY);
            let entries = stored ? JSON.parse(stored) : [];
            entries.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            return entries;
        }

        function saveEntries(entries) {
            localStorage.setItem(DIARY_KEY, JSON.stringify(entries));
            loadEntries();
            updateAvailableTags(); 
        }
        
        // NEU: Logik zum Ein-/Ausklappen der API-Einstellungen
        function toggleApiSetup() {
            isApiSetupExpanded = !isApiSetupExpanded;
            const setupEl = document.getElementById('apiSetup');
            const headerEl = document.getElementById('header');
            
            if (isApiSetupExpanded) {
                setupEl.classList.remove('collapsed');
                headerEl.classList.add('expanded');
                headerEl.classList.remove('collapsed'); // Klasse entfernen, falls sie noch da ist
            } else {
                setupEl.classList.add('collapsed');
                headerEl.classList.remove('expanded');
                headerEl.classList.add('collapsed'); // Klasse hinzuf√ºgen
            }
        }
        
        // NEU: Pr√ºft beim Laden, ob API-Schl√ºssel vorhanden und passt den Zustand an
        function checkAndSetApiSetupState() {
            const apiKey = document.getElementById('apiKey').value.trim(); // <-- Liest den aktuellen (wiederhergestellten) Wert
            const setupEl = document.getElementById('apiSetup');
            const headerEl = document.getElementById('header');
            
            // Logik: Nur aufklappen, wenn KEIN Schl√ºssel vorhanden ist
            if (apiKey && apiKey.length > 0) {
                // Schl√ºssel vorhanden -> Zustand bleibt geschlossen (durch HTML-Klasse)
                isApiSetupExpanded = false; 
                // Klassen explizit setzen (beim Start: collapsed)
                setupEl.classList.add('collapsed');
                headerEl.classList.add('collapsed'); // F√ºge collapsed zur Header-Box hinzu
                headerEl.classList.remove('expanded'); 
            } else {
                // KEIN Schl√ºssel vorhanden -> ge√∂ffnet starten (Klasse entfernen)
                isApiSetupExpanded = true; 
                setupEl.classList.remove('collapsed');
                headerEl.classList.remove('collapsed'); // Entferne collapsed von Header-Box
                headerEl.classList.add('expanded');
            }
        }
        
        // NEU: Logik zum Ein-/Ausklappen der Diagnose
        function toggleDiagnostics() {
            const diag = document.getElementById('diagnostics');
            diag.classList.toggle('collapsed');
        }


        function setupEventListeners() {
            // NEU: Event-Listener f√ºr den Header-Titel
            document.getElementById('headerTitle').addEventListener('click', toggleApiSetup);
            // NEU: Event-Listener f√ºr den Diagnose-Header
            document.getElementById('diagHeader').addEventListener('click', toggleDiagnostics);
            
            document.getElementById('apiKey').addEventListener('change', saveAPIKey);
            document.getElementById('apiProvider').addEventListener('change', saveAPIKey);
            document.getElementById('recordBtn').addEventListener('click', toggleRecording);
            
            document.getElementById('saveBtn').addEventListener('click', saveEntry);
            document.getElementById('editCancelBtn').addEventListener('click', resetForm); // Zur√ºcksetzen, nicht nur Abbrechen
            
            // NEU: Listener speichert Pr√§ferenz beim √Ñndern
            document.getElementById('locationPermission').addEventListener('change', handleLocationPermission);
            
            document.getElementById('addTagBtn').addEventListener('click', addCurrentTag);
            document.getElementById('newTag').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addCurrentTag();
            });

            document.getElementById('copyBtn').addEventListener('click', copyToClipboard);
            document.getElementById('shareBtn').addEventListener('click', shareContent);

            document.getElementById('reformulateShorter').addEventListener('click', () => reformulate('k√ºrzer'));
            document.getElementById('reformulateFormal').addEventListener('click', () => reformulate('formeller'));
            document.getElementById('reformulateCasual').addEventListener('click', () => reformulate('lockerer'));

            document.getElementById('toggleSelectionBtn').addEventListener('click', toggleSelectionMode);
            
            document.getElementById('summarizeSelectedBtn').addEventListener('click', summarizeSelected);
            document.getElementById('mergeSelectedBtn').addEventListener('click', mergeSelected); // NEU: Event-Listener f√ºr Zusammenf√ºhren
            document.getElementById('tagSelectedBtn').addEventListener('click', tagSelected);
            document.getElementById('exportSelectedBtn').addEventListener('click', exportSelected);
            document.getElementById('shareSelectedBtn').addEventListener('click', shareSelected);
            document.getElementById('deleteSelectedBtn').addEventListener('click', deleteSelected);

            document.getElementById('closeEditModal').addEventListener('click', closeEditModal);
            document.getElementById('cancelEditBtn').addEventListener('click', closeEditModal);
            document.getElementById('saveEditBtn').addEventListener('click', saveEditedEntry);
            document.getElementById('addEditTagBtn').addEventListener('click', addEditTag);
            document.getElementById('editNewTag').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addEditTag();
            });

            document.getElementById('closeBatchSummaryModal').addEventListener('click', closeBatchSummaryModal);
            document.getElementById('closeBatchSummaryBtn').addEventListener('click', closeBatchSummaryModal);
            document.getElementById('saveBatchSummaryBtn').addEventListener('click', saveBatchSummary);
            document.getElementById('copyBatchSummaryBtn').addEventListener('click', copyBatchSummary);
            
            document.getElementById('confirmYesBtn').addEventListener('click', () => {
                if (confirmCallback) {
                    const cb = confirmCallback;
                    closeConfirmModal();
                    cb();
                } else {
                    closeConfirmModal();
                }
            });
            document.getElementById('confirmNoBtn').addEventListener('click', closeConfirmModal);
            document.getElementById('closeConfirmModal').addEventListener('click', closeConfirmModal);

            // Audio Input Listener muss hier bleiben, da er Fallback f√ºr Mobile ist
            const audioInput = document.getElementById('audioInput');
            audioInput.addEventListener('change', handleAudioFileSelection);
            
            // NEU: Image Input Listener und Button
            const imageInput = document.getElementById('imageInput');
            document.getElementById('imageUploadBtn').addEventListener('click', () => {
                resetForm(); // Formular zur√ºcksetzen, bevor ein neuer Prozess startet
                imageInput.click();
            });
            imageInput.addEventListener('change', handleImageFileSelection);
            
            // NEU: NFC Listener
            const nfcBtn = document.getElementById('nfcBtn');
            if (nfcBtn) nfcBtn.addEventListener('click', readNFC);
        }

        // Dummy-Funktion f√ºr SpeechRecognition (wird nicht mehr prim√§r genutzt, aber zur Sicherheit behalten)
        function initSpeechRecognition() {} 
        
        // NEU: NFC Button Logik (Anzeige)
        function updateNFCButton() {
            const nfcBtn = document.getElementById('nfcBtn');
            // Web NFC ist prim√§r auf Android/Chrome verf√ºgbar und sollte auf iOS/Safari ausgeblendet werden
            if (nfcBtn && ('NDEFReader' in window)) {
                nfcBtn.style.display = 'inline-flex';
            } else if (nfcBtn) {
                nfcBtn.style.display = 'none';
            }
        }
        
        // NEU: NFC Lese Logik
        async function readNFC() {
            if (!('NDEFReader' in window)) {
                showError('NFC-Lesen wird von diesem Ger√§t/Browser nicht unterst√ºtzt (Web NFC API fehlt).');
                return;
            }
            
            resetForm();
            updateRecordButton('NFC: Warte auf Tag-Scan...', 'processing');
            
            try {
                const ndef = new NDEFReader();
                
                // Der Scan-Vorgang beginnt hier.
                await ndef.scan();
                
                // Listener f√ºr den Lese-Fehler
                ndef.onreadingerror = (e) => {
                    // Stellt sicher, dass wir nur Fehler behandeln, wenn wir aktiv scannen
                    if (document.getElementById('status').textContent.includes('NFC')) {
                        showError('NFC Lese-Fehler: Tag ung√ºltig, leer, oder Scan abgebrochen.');
                        try { if(window.__memotag?.diag) __memotag.diag.diagError('NFC Lese-Fehler: ' + (e.message || 'Unknown error')); } catch(_) {}
                        updateRecordButton('Bereit zur Aufnahme');
                    }
                };

                // Listener f√ºr erfolgreiches Lesen
                ndef.onreading = (e) => {
                    // NFC-Reader stoppen, um Mehrfachlesungen zu vermeiden
                    try { ndef.cancelScan(); } catch (_) {}
                    
                    const record = e.message.records.find(r => r.recordType === 'text');
                    
                    if (record) {
                        const decoder = new TextDecoder(record.encoding);
                        const text = decoder.decode(record.data);
                        processNFCReadout(text);
                    } else {
                        showError('NFC-Tag enth√§lt keinen lesbaren Text-Eintrag (NDEF-Text-Record fehlt).');
                        try { if(window.__memotag?.diag) __memotag.diag.diagError('NFC: Kein Text-Record gefunden.'); } catch(_) {}
                        updateRecordButton('Bereit zur Aufnahme');
                    }
                };
                
                // Setze einen Timeout, falls der Nutzer den Vorgang nicht abschlie√üt
                setTimeout(() => {
                    if (document.getElementById('status').textContent.includes('Warte auf Tag-Scan')) {
                        showError('NFC-Scan-Timeout: Tag nicht innerhalb von 20 Sekunden erkannt.');
                        updateRecordButton('Bereit zur Aufnahme');
                        try { ndef.cancelScan(); } catch (_) {}
                    }
                }, 20000); 

            } catch (error) {
                const errMsg = error.name === 'NotAllowedError' 
                    ? 'NFC-Zugriff verweigert. Bitte pr√ºfen Sie die Browser- und Systemberechtigungen.' 
                    : error.message.includes('No such device') 
                        ? 'NFC ist m√∂glicherweise deaktiviert oder nicht verf√ºgbar.'
                        : `NFC-Fehler: ${error.message}`;
                        
                showError(errMsg);
                try { if(window.__memotag?.diag) __memotag.diag.diagError(`NFC Scan Fehler: ${error.message}`); } catch(_) {}
                updateRecordButton('Bereit zur Aufnahme');
            }
        }
        
        // NEU: Verarbeitet den gelesenen Text
        async function processNFCReadout(text) {
             currentTranscript = text;
             const t = document.getElementById('transcript');
             if (t) t.value = currentTranscript;
             
             // Beim NFC-Scan wird die Transkript-Sektion als tempor√§rer Speicher verwendet, aber der Titel √§ndert sich
             document.getElementById('transcriptTitle').textContent = 'NFC-Text (Wird automatisch verarbeitet...)';
             const ts = document.getElementById('transcriptSection');
             if (ts) ts.classList.add('show');
             
             document.getElementById('status').textContent = 'NFC-Inhalt erfasst. Erstelle Zusammenfassung...';
             await summarize(currentTranscript, null); // Kein Bild
        }

        // --- BILD-UPLOAD LOGIK ---
        // NEUE FUNKTION: Bild ausgew√§hlt
        async function handleImageFileSelection(e) {
            const file = e.target.files && e.target.files[0];
            if (!file) return;

            // currentImageBase64 wird TEMPOR√ÑR F√úR DEN KI-CALL gesetzt.
            // Es wird auf NULL gesetzt, sobald die KI-Analyse fertig ist (siehe reader.onload -> finally block).

            // Optional: kleine Vorschau zeigen (kannst du auch weglassen)
            const imagePreview = document.getElementById('imagePreview');
            const reader = new FileReader();

            reader.onload = async (event) => {
                imagePreview.src = event.target.result;
                imagePreview.style.display = 'block';
                
                // Base64 URI tempor√§r speichern, falls f√ºr OpenAI ben√∂tigt (wird nach KI-Call gel√∂scht)
                currentImageBase64 = event.target.result; 
                
                // KI-Beschreibung holen
                document.getElementById('transcriptTitle').textContent = 'Bild-Beschreibung (Wird automatisch verarbeitet...)';
                document.getElementById('transcriptSection').classList.add('show');
                document.getElementById('status').textContent = 'Bild hochgeladen. Erstelle Beschreibung...';
                document.getElementById('status').classList.add('processing');
                
                try {
                    await summarize(null, file); // nutzt dein vorhandenes image->text
                } finally {
                    document.getElementById('status').classList.remove('processing');
                    // Vorschau leeren, damit Speicher frei wird
                    imagePreview.src = '';
                    imagePreview.style.display = 'none';
                    // WICHTIG: currentImageBase64 IMMER nach der Verarbeitung l√∂schen!
                    currentImageBase64 = null; 
                }
                
                document.getElementById('transcriptSection').classList.remove('show'); // Transkript/Beschreibung ist nur ein Zwischenschritt
            };

            reader.onerror = () => {
                showError('Fehler beim Lesen der Datei.');
                resetForm();
            };

            reader.readAsDataURL(file); // Liest das Bild als Base64-String
        }

        // NEUE FUNKTION: Image-to-Text
        async function imageToText(file, apiKey, provider) {
            const maxMB = 5;
            if (file.size > maxMB * 1024 * 1024) {
                throw new Error(`Bilddatei ist gr√∂√üer als ${maxMB} MB.`);
            }

            // Sicherstellen, dass nur Multimodale Modelle verwendet werden
            if (provider === 'openai') {
                // GPT-4o oder gpt-4-turbo
                return callLLMAPI('Beschreibe dieses Bild detailliert.', apiKey, provider, 0, file);
            } else if (provider === 'anthropic') {
                 // claude-3-5-sonnet oder claude-3-haiku
                return callLLMAPI('Beschreibe dieses Bild detailliert.', apiKey, provider, 0, file);
            } else if (provider === 'gemini') {
                // gemini-2.5-flash
                return callLLMAPI('Beschreibe dieses Bild detailliert.', apiKey, provider, 0, file);
            }

            throw new Error('Der ausgew√§hlte KI-Anbieter unterst√ºtzt m√∂glicherweise keine Bildanalyse (Multimodalit√§t).');
        }


        // NEU: Zentrale Umschaltfunktion f√ºr die Aufnahme
        function toggleRecording() {
            const hasMediaRecorder = !!(navigator.mediaDevices && window.MediaRecorder);

            if (isRecording) {
                // Aufnahme stoppen (MediaRecorder)
                if (hasMediaRecorder && __mrRecording) {
                    stopMediaRecorder();
                }
                // Wenn MediaRecorder nicht aktiv, aber isRecording true (Sicherheits-Reset)
                else {
                    resetForm();
                }

            } else {
                resetForm();
                // Wenn MediaRecorder verf√ºgbar (PC/Android), starte MediaRecorder
                if (hasMediaRecorder) {
                    startMediaRecorder();
                } 
                // Wenn MediaRecorder NICHT verf√ºgbar (z.B. iOS Safari), nutze den Audio-Upload-Fallback
                else {
                    // Startet den nativen Dialog zur Aufnahme/Auswahl
                    const audioInput = document.getElementById('audioInput');
                    if (audioInput) {
                        try {
                            // Diagnose-Log hinzuf√ºgen
                            if(window.__memotag?.diag) __memotag.diag.diagLog('Klick: Mobile Fallback (Audio Upload)'); 
                            audioInput.click();
                        } catch (e) {
                            showError('Mikrofonzugriff nicht m√∂glich. Bitte Audio direkt hochladen.');
                        }
                    }
                }
            }
        }
        
        // NEU: MediaRecorder Start/Stop Logik
        async function startMediaRecorder() {
            try{
                const btn = document.getElementById('recordBtn');
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                __mrStream = stream;
                
                // W√§hle den besten MIME-Type
                const mime = MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' :
                             (MediaRecorder.isTypeSupported('audio/ogg') ? 'audio/ogg' : 
                             (MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4' : ''));

                if (!mime) {
                    showError('Ihr Browser unterst√ºtzt keine MediaRecorder-Formate f√ºr Audio.');
                    stopStream(__mrStream);
                    return;
                }

                __mr = new MediaRecorder(stream, { mimeType: mime });
                __mrChunks = [];
                __mr.ondataavailable = e => { 
                    if(e.data && e.data.size > 0) {
                        __mrChunks.push(e.data); 
                        try { if(window.__memotag?.diag) __memotag.diag.diagLog(`Recorder: Chunk (${e.data.size} Bytes)`); } catch(_) {}
                    }
                };
                
                __mr.onerror = (e) => {
                    showError('Aufnahmefehler: ' + e.error.name);
                    try { if(window.__memotag?.diag) __memotag.diag.diagError('MediaRecorder Fehler: ' + e.error.name); } catch(_) {}
                    stopStream(__mrStream);
                    __mrRecording = false;
                    isRecording = false;
                    updateRecordButton('Fehler.');
                };

                __mr.onstop = processAudioRecording;

                __mr.start(500); 
                __mrRecording = true;
                isRecording = true;
                updateRecordButton('Aufnahme l√§uft...');
                
                if (document.getElementById('locationPermission')?.checked) {
                    getCurrentLocation();
                }

                try { if(window.__memotag?.diag) __memotag.diag.diagLog('Recorder gestartet: ' + mime); } catch(_) {}
                
                // Starte Mic Meter f√ºr Diagnose
                try { if(window.__memotag?.diag) __memotag.diag.startMicMeter(); } catch(_) {}


            }catch(err){
                const errMsg = err.name === 'NotAllowedError' ? 'Mikrofonzugriff verweigert.' : (err.message || err);
                showError('Zugriff auf Mikrofon fehlgeschlagen: ' + errMsg);
                try { if(window.__memotag?.diag) window.__memotag.diag.diagError('Mic-Zugriff Fehler: ' + errMsg); } catch(_) {}
                updateRecordButton('Bereit zur Aufnahme');
            }
        }
        
        function stopMediaRecorder() {
            try{ 
                __mr.stop(); 
                try { if(window.__memotag?.diag) __memotag.diag.diagLog('Recorder Stopp-Kommando gesendet. Warte auf onstop Event...'); } catch(_) {}
                try { if(window.__memotag?.diag) __memotag.diag.stopMicMeter(); } catch(_) {} // Mic Meter stoppen
                updateRecordButton('Verarbeite...');
            }catch(_){}
            stopStream(__mrStream);
            isRecording = false;
        }

        async function processAudioRecording() {
            try{
                const btn = document.getElementById('recordBtn');
                const blobType = __mr && __mr.mimeType ? __mr.mimeType : 'audio/webm';
                const blob = new Blob(__mrChunks, { type: blobType });
                const file = new File([blob], 'aufnahme.' + (blobType.includes('ogg') ? 'ogg' : 'webm'), { type: blobType });
                
                try { if(window.__memotag?.diag) __memotag.diag.diagLog(`Recorder Stopp: Datei (${file.name}) bereit. Gr√∂√üe: ${(file.size / 1024 / 1024).toFixed(2)} MB`); } catch(_) {}

                await processAudioFile(file);

            }catch(err){
                const errorMessage = 'Verarbeitung fehlgeschlagen: ' + (err.message || err);
                showError(errorMessage);
                try { if(window.__memotag?.diag) window.__memotag.diag.diagError(errorMessage); } catch(_) {}
                resetForm();
            } finally {
                __mrRecording = false;
            }
        }
        
        // NEU: Allgemeine Funktion zum Verarbeiten der Audio-Datei (Upload oder MediaRecorder)
        async function processAudioFile(file) {
             // 1. Transkription starten
            document.getElementById('status').textContent = 'Audio-Datei gesendet. Warte auf KI-Transkription...';
            document.getElementById('status').classList.add('processing');
            document.getElementById('transcriptTitle').textContent = 'Transkription (Wird automatisch verarbeitet...)'; // Setze Titel zur√ºck
            
            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            if(!apiKey){ 
                showError('Bitte gib einen API-Schl√ºssel ein.'); 
                resetForm();
                return; 
            }
            
            let transcript;
            try {
                transcript = await transcribeAudio(file, apiKey, provider);
                currentTranscript = transcript || '';
                
                try { if(window.__memotag?.diag) __memotag.diag.diagLog('Transkription erfolgreich abgeschlossen.'); } catch(_) {}

                const t = document.getElementById('transcript');
                if (t) t.value = currentTranscript;
                const ts = document.getElementById('transcriptSection');
                if (ts) ts.classList.add('show');

            } catch(err) {
                 const errorMessage = 'Transkription fehlgeschlagen: ' + (err.message || err);
                showError(errorMessage);
                try { if(window.__memotag?.diag) window.__memotag.diag.diagError(errorMessage); } catch(_) {}
                resetForm();
                return;
            }

            // 2. Transkription fertig - Automatische Zusammenfassung starten
            document.getElementById('status').textContent = 'Transkription abgeschlossen. Erstelle Zusammenfassung...';
            await summarize(currentTranscript, null); // Jetzt mit transcript, kein Bild
            document.getElementById('status').classList.remove('processing');
        }


        // NEU: Transkriptions-Logik f√ºr Upload-Fallback
        async function handleAudioFileSelection(e) {
            const file = e.target.files && e.target.files[0];
            if (!file) return;

            try { if(window.__memotag?.diag) __memotag.diag.diagLog('Audio-Datei ausgew√§hlt (' + file.name + ')'); } catch(_) {}

            await processAudioFile(file);

        }

        // HILFSFUNKTION: MediaRecorder Fallback Logik (Initialisierung)
        function initMediaRecorderFallback(){
             try { if(window.__memotag?.diag) window.__memotag.diag.diagLog('Init: MediaRecorder Fallback'); } catch(_) {}
            // Der Haupt-Button-Klick-Handler ist jetzt toggleRecording
        }

        // HILFSFUNKTION: iOS Fallback Logik (Initialisierung)
        function initIOSFallback() {
             try { if(window.__memotag?.diag) __memotag.diag.diagLog('Init: iOS Fallback (Status-Hinweis)'); } catch(_) {}
            // Zeige Hinweis f√ºr mobile Ger√§te
            const iosHint = document.getElementById('iosHint');
            if (iosHint) {
                // Wir nutzen die Tatsache aus, dass MediaRecorder auf iOS Safari nicht geht
                const hasMediaRecorder = !!(navigator.mediaDevices && window.MediaRecorder);
                if (!hasMediaRecorder) {
                    iosHint.style.display = 'block';
                }
            }
        }
        
        function stopStream(stream){ 
            try{ if(stream) stream.getTracks().forEach(t=>t.stop()); }catch(_){} 
        }
        
        function updateRecordButton(statusText) {
            const btn = document.getElementById('recordBtn');
            const status = document.getElementById('status');
            const imgBtn = document.getElementById('imageUploadBtn');
            const nfcBtn = document.getElementById('nfcBtn');

            if (status) status.textContent = statusText;

            // Mikrofon-Button Zustand
            if (statusText.includes('Aufnahme l√§uft')) {
                if (btn) {
                    btn.classList.add('recording');
                    btn.textContent = '‚èπÔ∏è';
                    btn.setAttribute('aria-label', 'Aufnahme stoppen');
                }
            } else {
                 if (btn) {
                    btn.classList.remove('recording');
                    btn.textContent = 'üé§';
                    btn.setAttribute('aria-label', 'Aufnahme starten');
                }
            }

            // Deaktivierung f√ºr alle Buttons w√§hrend der Verarbeitung
            const isProcessing = statusText.includes('Warte auf KI') || 
                                 statusText.includes('Erstelle Zusammenfassung') || 
                                 statusText.includes('Verarbeite') || 
                                 statusText.includes('NFC') || 
                                 statusText.includes('Beschreibung');

            if (isProcessing) {
                 if (status) status.classList.add('processing');
                 if (btn) btn.disabled = true;
                 if (imgBtn) imgBtn.disabled = true;
                 if (nfcBtn) nfcBtn.disabled = true;

            } else {
                 if (status) status.classList.remove('processing');
                 if (btn) btn.disabled = false;
                 if (imgBtn) imgBtn.disabled = false;
                 if (nfcBtn) nfcBtn.disabled = false;
            }

        }


        function getCurrentLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        currentLocation = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude
                        };
                    },
                    (error) => {
                        console.error('Location error:', error);
                        currentLocation = null;
                    }
                );
            }
        }

        function saveLocationPermission(isChecked) {
            localStorage.setItem('location_permission', isChecked ? 'true' : 'false');
        }

        function loadLocationPermission() {
            const permissionCheckbox = document.getElementById('locationPermission');
            const storedValue = localStorage.getItem('location_permission');
            
            // Standardm√§√üig ist es nicht gesetzt (null) oder 'false'
            if (storedValue === 'true') {
                permissionCheckbox.checked = true;
                // Optional: Hier k√∂nnte man direkt die Berechtigung anfordern, 
                // aber der Browser macht das wahrscheinlich automatisch, sobald man die Checkbox anklickt.
            } else {
                permissionCheckbox.checked = false;
            }
        }
        
        function handleLocationPermission() {
            const permissionCheckbox = document.getElementById('locationPermission');
            const isChecked = permissionCheckbox.checked;

            // 1. Speichere die Pr√§ferenz
            saveLocationPermission(isChecked);

            // 2. Frage die Berechtigung an, wenn sie aktiviert wurde
            if (isChecked) {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        () => {
                            console.log('Location permission granted');
                            // Keine Fehlermeldung, da die Berechtigung erfolgreich ist.
                        },
                        (error) => {
                            console.error('Location permission denied:', error);
                            // Wenn der Nutzer die Berechtigung verweigert hat, setzen wir die Checkbox zur√ºck
                            // und zeigen eine Meldung, speichern aber die Pr√§ferenz, dass er es wollte.
                            permissionCheckbox.checked = false;
                            saveLocationPermission(false);
                            showError('Standort-Berechtigung wurde verweigert oder ist nicht verf√ºgbar.');
                        }
                    );
                } else {
                    showError('Geolocation wird von diesem Browser nicht unterst√ºtzt.');
                    permissionCheckbox.checked = false;
                    saveLocationPermission(false);
                }
            }
            // Wenn es deaktiviert wird, muss nichts weiter passieren, au√üer der Speicherung
        }

        // NEU: Summarize-Funktion akzeptiert jetzt Transkript ODER Datei
        async function summarize(transcript, imageFile) {
            
            if (!transcript && !imageFile) { 
                showError('Kein Transkript oder Bild vorhanden, kann nicht zusammenfassen/beschreiben.'); 
                resetForm();
                return; 
            }

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { 
                showError('Bitte gib einen API-Schl√ºssel ein.'); 
                resetForm();
                return; 
            }

            document.getElementById('loading').classList.add('show');
            document.getElementById('error').classList.remove('show');
            document.getElementById('summarySection').classList.add('show');
            
            // Setze den Status-Text entsprechend
            if (imageFile) {
                 document.getElementById('status').textContent = 'KI erstellt Bildbeschreibung...';
            } else if (transcript) {
                 document.getElementById('status').textContent = 'KI erstellt Zusammenfassung...';
            }


            try {
                let summary = '';
                if (imageFile) {
                    summary = await imageToText(imageFile, apiKey, provider);
                } else if (transcript) {
                    summary = await callLLMAPI(transcript, apiKey, provider);
                }

                document.getElementById('summary').value = summary;
                document.getElementById('loading').classList.remove('show');
                
                // setze Status zur√ºck, damit der Button wieder klickbar ist
                updateRecordButton(imageFile ? 'Bildbeschreibung fertig!' : 'Zusammenfassung fertig!');
                
                currentTags = [];
                updateCurrentTags();
            } catch (error) {
                showError('Fehler beim Erstellen der Notiz: ' + error.message);
                document.getElementById('loading').classList.remove('show');
                resetForm();
            }
        }

        async function reformulate(style) {
            const summary = document.getElementById('summary').value.trim();
            if (!summary) { showError('Keine Zusammenfassung vorhanden.'); return; }

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { showError('Bitte gib einen API-Schl√ºssel ein.'); return; }

            document.getElementById('reformulateLoading').classList.add('show');
            document.getElementById('success').classList.remove('show');

            try {
                let prompt = '';
                if (style === 'k√ºrzer') {
                    prompt = `Formuliere den folgenden Text deutlich k√ºrzer (max. 50% der Originall√§nge), aber behalte alle wichtigen Informationen:\n\n${summary}`;
                } else if (style === 'formeller') {
                    prompt = `Formuliere den folgenden Text formeller und professioneller:\n\n${summary}`;
                } else if (style === 'lockerer') {
                    prompt = `Formuliere den folgenden Text lockerer und umgangssprachlicher:\n\n${summary}`;
                }

                let reformulated = await callLLMAPI(prompt, apiKey, provider, 0, null); // Kein Bild
                document.getElementById('summary').value = reformulated;
                document.getElementById('reformulateLoading').classList.remove('show');
                showSuccess('Erfolgreich neu formuliert!');
            } catch (error) {
                showError('Fehler beim Neu-Formulieren: ' + error.message);
                document.getElementById('reformulateLoading').classList.remove('show');
            }
        }

        function addCurrentTag() {
            const tagInput = document.getElementById('newTag');
            const tag = tagInput.value.trim();
            if (tag && !currentTags.includes(tag)) {
                currentTags.push(tag);
                updateCurrentTags();
                tagInput.value = '';
            }
        }

        function updateCurrentTags() {
            const container = document.getElementById('currentTags');
            container.innerHTML = '';
            currentTags.forEach(tag => {
                const wrap = document.createElement('div');
                wrap.className = 'tag';
                const txt = document.createElement('span');
                txt.textContent = tag;
                const btn = document.createElement('button');
                btn.className = 'tag-remove';
                btn.textContent = '√ó';
                btn.setAttribute('aria-label', `Tag ${tag} entfernen`);
                btn.addEventListener('click', () => removeCurrentTag(tag));
                wrap.appendChild(txt);
                wrap.appendChild(btn);
                container.appendChild(wrap);
            });
            updateAvailableTags();
        }

        function removeCurrentTag(tag) {
            currentTags = currentTags.filter(t => t !== tag);
            updateCurrentTags();
        }
        
        // NEUE FUNKTION: Tags sammeln und anzeigen
        function updateAvailableTags() {
            const allEntries = getEntries();
            const allTags = new Set();
            allEntries.forEach(entry => {
                if (entry.tags) entry.tags.forEach(tag => allTags.add(tag));
            });

            // Tags f√ºr den Haupt-Tag-Bereich (Neue Notiz)
            const container = document.getElementById('availableTags');
            renderTagSuggestions(container, allTags, tag => {
                if (!currentTags.includes(tag)) {
                    currentTags.push(tag);
                } else {
                    currentTags = currentTags.filter(t => t !== tag);
                }
                updateCurrentTags();
            }, currentTags);
            
            // Tags f√ºr den Edit-Modal-Bereich
            const editContainer = document.getElementById('editAvailableTags');
            // Stelle sicher, dass `currentTags` im Edit Modal die Tags des Eintrags reflektieren, wenn es offen ist
            const tagsForEditModal = editingEntryId ? getEntries().find(e => e.id === editingEntryId)?.tags || [] : currentTags;
            renderTagSuggestions(editContainer, allTags, tag => {
                if (!currentTags.includes(tag)) {
                    currentTags.push(tag);
                } else {
                    currentTags = currentTags.filter(t => t !== tag);
                }
                updateEditTags();
            }, tagsForEditModal);

            // Tags f√ºr den Filter-Bereich
            updateTagFilter(allEntries);
        }

        // Hilfsfunktion zum Rendern der klickbaren Tag-Vorschl√§ge
        function renderTagSuggestions(container, tags, clickHandler, activeTags) {
            container.innerHTML = '';
            Array.from(tags).sort().forEach(tag => {
                const tagEl = document.createElement('div');
                tagEl.className = `tag-suggestion ${activeTags.includes(tag) ? 'active' : ''}`;
                tagEl.textContent = tag;
                tagEl.addEventListener('click', () => clickHandler(tag));
                container.appendChild(tagEl);
            });
        }


        function addEditTag() {
            const tagInput = document.getElementById('editNewTag');
            const tag = tagInput.value.trim();
            if (tag && !currentTags.includes(tag)) {
                currentTags.push(tag);
                updateEditTags();
                tagInput.value = '';
            }
        }

        function updateEditTags() {
            const container = document.getElementById('editTags');
            container.innerHTML = '';
            currentTags.forEach(tag => {
                const wrap = document.createElement('div');
                wrap.className = 'tag';
                const txt = document.createElement('span');
                txt.textContent = tag;
                const btn = document.createElement('button');
                btn.className = 'tag-remove';
                btn.textContent = '√ó';
                btn.setAttribute('aria-label', `Tag ${tag} entfernen`);
                btn.addEventListener('click', () => removeEditTag(tag));
                wrap.appendChild(txt);
                wrap.appendChild(btn);
                container.appendChild(wrap);
            });
            updateAvailableTags(); // Tags im Modal nach dem Editieren aktualisieren
        }

        function removeEditTag(tag) {
            currentTags = currentTags.filter(t => t !== tag);
            updateEditTags();
        }

        // KORRIGIERTE saveEntry Funktion
        function saveEntry() {
            const summary = document.getElementById('summary').value.trim();

            // Prueft, ob Text zum Speichern vorhanden ist (da Bilder nicht mehr gespeichert werden)
            if (!summary) { 
                showError('Bitte gib Text ein (Zusammenfassung).');
                return;
            }

            const entries = getEntries();
            const newEntry = {
                id: Date.now().toString(),
                text: summary || '',
                image: null, // BILD WIRD NICHT MEHR GESPEICHERT
                tags: [...currentTags], 
                location: currentLocation,
                timestamp: new Date().toISOString(),
                transcript: currentTranscript || '' 
            };

            entries.unshift(newEntry); // Neue Eintr√§ge vorne einf√ºgen
            saveEntries(entries);

            showSuccess('Notiz gespeichert!');
            resetForm(); 
        }

        function deleteEntry(id) {
            showConfirmModal('Eintrag wirklich l√∂schen?', () => {
                const entries = getEntries().filter(e => e.id !== id);
                saveEntries(entries);
                showSuccess('Eintrag gel√∂scht!');
            });
        }

        function editEntry(id) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry) return;

            editingEntryId = id;
            document.getElementById('editText').value = entry.text;
            document.getElementById('editModal').classList.add('show');
            document.getElementById('editError').classList.remove('show');
            document.getElementById('editSuccess').classList.remove('show');
            
            currentTags = entry.tags ? [...entry.tags] : [];
            updateEditTags();
            updateAvailableTags(); // Wichtig, um die Tags im Modal neu zu rendern
        }

        function saveEditedEntry() {
            const text = document.getElementById('editText').value.trim();
            if (!text) { showError('Text darf nicht leer sein.', 'editError'); return; }

            const entries = getEntries();
            const entryIndex = entries.findIndex(e => e.id === editingEntryId);

            if (entryIndex > -1) {
                entries[entryIndex].text = text;
                entries[entryIndex].tags = [...currentTags];
                // Bild bleibt unver√§ndert, da es im Bearbeitungsmodal nicht ge√§ndert werden kann
                saveEntries(entries);
                
                showSuccess('Eintrag aktualisiert!', 'editSuccess');
                setTimeout(() => closeEditModal(), 1000);
            }
        }

        function closeEditModal() {
            document.getElementById('editModal').classList.remove('show');
            editingEntryId = null;
            currentTags = [];
        }

        async function reformulateEntry(id) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry) return;

            const style = prompt('Wie soll neu formuliert werden? (k√ºrzer/formeller/lockerer)');
            if (!style || !['k√ºrzer', 'formeller', 'lockerer'].includes(style.toLowerCase())) return;

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { showError('Bitte gib einen API-Schl√ºssel ein.'); return; }

            showSuccess('Formuliere um...');

            try {
                let prompt = '';
                if (style.toLowerCase() === 'k√ºrzer') {
                    prompt = `Formuliere den folgenden Text deutlich k√ºrzer (max. 50% der Originall√§nge), aber behalte alle wichtigen Informationen:\n\n${entry.text}`;
                } else if (style.toLowerCase() === 'formeller') {
                    prompt = `Formuliere den folgenden Text formeller und professioneller:\n\n${entry.text}`;
                } else if (style.toLowerCase() === 'lockerer') {
                    prompt = `Formuliere den folgenden Text lockerer und umgangssprachlicher:\n\n${entry.text}`;
                }

                let reformulated = await callLLMAPI(prompt, apiKey, provider, 0, null); // Kein Bild

                const entries = getEntries();
                const entryIndex = entries.findIndex(e => e.id === id);
                if (entryIndex > -1) {
                    entries[entryIndex].text = reformulated;
                    saveEntries(entries);
                    showSuccess('Erfolgreich neu formuliert!');
                }
            } catch (error) {
                showError('Fehler beim Neu-Formulieren: ' + error.message);
            }
        }

        async function copyEntry(id) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry) return;

            // Bild-Hinweis bleibt f√ºr alte Eintr√§ge, aber neue haben kein Bild mehr
            let textToCopy = entry.text;
            if (entry.image) {
                textToCopy = `[Bild-Notiz]\n${textToCopy}`;
            }

            try {
                await navigator.clipboard.writeText(textToCopy);
                showSuccess('In Zwischenablage kopiert!');
            } catch (error) {
                showError('Fehler beim Kopieren: ' + error.message);
            }
        }

        async function shareEntry(id) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry) return;
            
            // Bild-Hinweis bleibt f√ºr alte Eintr√§ge, aber neue haben kein Bild mehr
            let textToShare = entry.text;
            if (entry.image) {
                textToShare = `[Bild-Notiz]\n${textToShare}`;
            }

            if (navigator.share) {
                try {
                    await navigator.share({ title: 'Sprach-Tagebuch Notiz', text: textToShare });
                } catch (error) {
                    console.log('Sharing cancelled');
                }
            } else {
                showError('Teilen wird in diesem Browser nicht unterst√ºtzt.');
            }
        }

        function loadEntries() {
            let entries = getEntries();
            
            if (activeTagFilter) {
                entries = entries.filter(e => e.tags && e.tags.includes(activeTagFilter));
            }

            renderEntries(entries);
            // updateTagFilter wird in updateAvailableTags aufgerufen.
        }

        function renderEntries(entries) {
            const container = document.getElementById('entries');
            container.innerHTML = '';
            
            if (entries.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'empty-state';
                empty.textContent = 'Noch keine Eintr√§ge vorhanden.\nNimm deine erste Notiz auf!';
                container.appendChild(empty);
                return;
            }

            entries.forEach(entry => {
                const entryDiv = document.createElement('div');
                entryDiv.className = `entry ${selectionMode ? 'selection-mode' : ''}`;

                if (selectionMode) {
                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.className = 'entry-checkbox';
                    cb.checked = selectedEntries.has(entry.id);
                    cb.setAttribute('aria-label', `Notiz vom ${new Date(entry.timestamp).toLocaleDateString('de-DE')} ausw√§hlen`);
                    cb.addEventListener('change', e => {
                        if (e.target.checked) selectedEntries.add(entry.id);
                        else selectedEntries.delete(e.target.id);
                        updateBatchActionsVisibility();
                    });
                    entryDiv.appendChild(cb);
                }

                const header = document.createElement('div');
                header.className = 'entry-header';
                const dateDiv = document.createElement('div');
                const dateEl = document.createElement('div');
                dateEl.className = 'entry-date';
                dateEl.textContent = new Date(entry.timestamp).toLocaleDateString('de-DE', {
                    day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit'
                });
                dateDiv.appendChild(dateEl);

                if (entry.location) {
                    const locEl = document.createElement('div');
                    locEl.className = 'entry-location';
                    locEl.textContent = `üìç ${entry.location.latitude.toFixed(4)}, ${entry.location.longitude.toFixed(4)}`;
                    dateDiv.appendChild(locEl);
                }
                header.appendChild(dateDiv);
                entryDiv.appendChild(header);
                
                // NEU: Bild-Vorschau hinzuf√ºgen (wird nur f√ºr ALTE Eintr√§ge gerendert, da neue kein Bild mehr speichern)
                if (entry.image) {
                     const img = document.createElement('img');
                     img.className = 'entry-image';
                     img.src = entry.image;
                     img.alt = entry.text.substring(0, 50) + '...'; // Nutze den Text als Alt-Text
                     entryDiv.appendChild(img);
                }


                if (entry.tags && entry.tags.length > 0) {
                    const tagsDiv = document.createElement('div');
                    tagsDiv.className = 'entry-tags';
                    entry.tags.forEach(tag => {
                        const tagEl = document.createElement('div');
                        tagEl.className = 'tag';
                        tagEl.textContent = tag;
                        tagsDiv.appendChild(tagEl);
                    });
                    entryDiv.appendChild(tagsDiv);
                }

                const textEl = document.createElement('div');
                textEl.className = 'entry-text';
                textEl.textContent = entry.text;
                entryDiv.appendChild(textEl);

                const actions = document.createElement('div');
                actions.className = 'entry-actions';
                
                const btnConfigs = [
                    ['Bearbeiten', 'btn-icon', () => editEntry(entry.id)],
                    ['Neu formulieren', 'btn-icon', () => reformulateEntry(entry.id)],
                    ['Kopieren', 'btn-icon', () => copyEntry(entry.id)],
                    ['Teilen', 'btn-icon', () => shareEntry(entry.id)],
                    ['L√∂schen', 'delete-btn', () => deleteEntry(entry.id)]
                ];

                btnConfigs.forEach(([label, className, handler]) => {
                    const btn = document.createElement('button');
                    btn.className = className;
                    btn.textContent = label;
                    btn.addEventListener('click', handler);
                    actions.appendChild(btn);
                });

                entryDiv.appendChild(actions);
                container.appendChild(entryDiv);
            });
        }

        function updateTagFilter(allEntries) {
            const allTags = new Set();
            allEntries.forEach(entry => {
                if (entry.tags) entry.tags.forEach(tag => allTags.add(tag));
            });

            const container = document.getElementById('tagFilter');
            container.innerHTML = '';
            
            if (allTags.size === 0 && !activeTagFilter) return;

            const allBtn = document.createElement('div');
            // NEU: Aktive Klasse basierend auf activeTagFilter
            allBtn.className = `filter-tag ${!activeTagFilter ? 'active' : ''}`;
            allBtn.textContent = 'Alle';
            allBtn.addEventListener('click', () => filterByTag(null));
            container.appendChild(allBtn);

            Array.from(allTags).forEach(tag => {
                const tagBtn = document.createElement('div');
                // NEU: Aktive Klasse basierend auf activeTagFilter
            tagBtn.className = `filter-tag ${activeTagFilter === tag ? 'active' : ''}`;
                tagBtn.textContent = tag;
                tagBtn.addEventListener('click', () => filterByTag(tag));
                container.appendChild(tagBtn);
            });
        }

        function filterByTag(tag) {
            // NEU: activeTagFilter setzen/zur√ºcksetzen und dann Eintr√§ge neu laden
            activeTagFilter = tag;
            loadEntries();
            updateTagFilter(getEntries()); // Wichtig: Filter-Buttons aktualisieren
        }

        function toggleSelectionMode() {
            selectionMode = !selectionMode;
            selectedEntries.clear();
            
            const btn = document.getElementById('toggleSelectionBtn');
            btn.textContent = selectionMode ? 'Fertig' : 'Ausw√§hlen';
            
            loadEntries();
            updateBatchActionsVisibility();
        }

        function updateBatchActionsVisibility() {
            const batchActions = document.getElementById('batchActions');
            if (selectionMode && selectedEntries.size > 0) {
                batchActions.classList.add('show');
            } else {
                batchActions.classList.remove('show');
            }
        }

        async function summarizeSelected() {
            const allEntries = getEntries();
            const entries = allEntries.filter(e => selectedEntries.has(e.id));
            if (entries.length === 0) return;

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { showError('Bitte gib einen API-Schl√ºssel ein.'); return; }
            
            document.getElementById('batchSummaryTitle').textContent = 'Gesamt-Zusammenfassung';
            document.getElementById('batchSummaryModal').classList.add('show');
            document.getElementById('batchSummaryText').style.display = 'none';
            document.getElementById('batchSummaryActions').style.display = 'none';
            document.getElementById('batchSummaryLoading').classList.add('show');
            document.getElementById('batchSummarySuccess').classList.remove('show');

            try {
                // Ber√ºcksichtige Bilder in der zusammengefassten Notiz
                const combinedText = entries.map((e, i) => {
                    const imgNote = e.image ? ' [Bild-Notiz enthalten]' : '';
                    return `Notiz ${i + 1} (${new Date(e.timestamp).toLocaleDateString('de-DE')})${imgNote}:\n${e.text}`;
                }).join('\n\n---\n\n');
                
                const prompt = `Erstelle eine pr√§gnante Gesamt-Zusammenfassung der folgenden ${entries.length} Notizen. Identifiziere gemeinsame Themen und wichtige Erkenntnisse:\n\n${combinedText}`;

                let summary = await callLLMAPI(prompt, apiKey, provider, 0, null); // Kein Bild

                document.getElementById('batchSummaryLoading').classList.remove('show');
                document.getElementById('batchSummaryText').value = summary;
                document.getElementById('batchSummaryText').style.display = 'block';
                document.getElementById('batchSummaryActions').style.display = 'flex';
            } catch (error) {
                document.getElementById('batchSummaryLoading').classList.remove('show');
                showError('Fehler beim Zusammenfassen: ' + error.message, 'batchSummarySuccess');
            }
        }
        
        // NEU: Funktion zum Zusammenf√ºhren von Eintr√§gen ohne Informationsverlust
        async function mergeSelected() {
            const allEntries = getEntries();
            const entries = allEntries.filter(e => selectedEntries.has(e.id));
            if (entries.length === 0) return;

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { showError('Bitte gib einen API-Schl√ºssel ein.'); return; }
            
            document.getElementById('batchSummaryTitle').textContent = 'Zusammenf√ºhrung (Daten-Kompilation)';
            document.getElementById('batchSummaryModal').classList.add('show');
            document.getElementById('batchSummaryText').style.display = 'none';
            document.getElementById('batchSummaryActions').style.display = 'none';
            document.getElementById('batchSummaryLoading').classList.add('show');
            document.getElementById('batchSummarySuccess').classList.remove('show');
            document.getElementById('batchSummaryLoading').textContent = 'KI f√ºhrt Eintr√§ge zusammen...';


            try {
                // Ber√ºcksichtige Bilder in der zusammengefassten Notiz
                const combinedText = entries.map((e, i) => {
                    const imgNote = e.image ? ' [Bild-Notiz enthalten]' : '';
                    return `--- Eintrag ${i + 1}${imgNote} ---\n${e.text}`;
                }).join('\n\n');
                
                // Strenger Prompt zur Kompilation von Daten und Listen
                const prompt = `F√ºhre die folgenden ${entries.length} Notizen zusammen, ohne Informationen zu verlieren oder zu verallgemeinern. Deine Aufgabe ist die detailgetreue Kompilation.
                
                Wichtige Regeln:
                1. KEINE Zusammenfassung, KEINE Verallgemeinerung.
                2. Wenn es sich um Listen (z.B. Einkaufslisten, To-Do-Listen) handelt, kompiliere diese direkt in EINE EINZIGE, VOLLST√ÑNDIGE Liste.
                3. Erhalte alle spezifischen Details (z.B. genaue Produktnamen, Zahlen, Adressen).
                
                Texte zum Zusammenf√ºhren:
                
                ${combinedText}`;

                let result = await callLLMAPI(prompt, apiKey, provider, 0, null); // Kein Bild

                document.getElementById('batchSummaryLoading').classList.remove('show');
                document.getElementById('batchSummaryText').value = result;
                document.getElementById('batchSummaryText').style.display = 'block';
                document.getElementById('batchSummaryActions').style.display = 'flex';
            } catch (error) {
                document.getElementById('batchSummaryLoading').classList.remove('show');
                showError('Fehler beim Zusammenf√ºhren: ' + error.message, 'batchSummarySuccess');
            }
        }


        function saveBatchSummary() {
            const summary = document.getElementById('batchSummaryText').value.trim();
            if (!summary) return;

            const entry = {
                id: Date.now().toString(),
                text: summary,
                timestamp: new Date().toISOString(),
                location: null,
                // Tag anpassen, je nachdem, welche Aktion zuletzt ausgef√ºhrt wurde
                tags: [document.getElementById('batchSummaryTitle').textContent.includes('Zusammenfassung') ? 'Zusammenfassung' : 'Kompilation'],
                transcript: `${document.getElementById('batchSummaryTitle').textContent} von ${selectedEntries.size} Notizen`,
                image: null // Bei Zusammenfassungen wird kein Bild gespeichert
            };

            const entries = getEntries();
            entries.unshift(entry);
            saveEntries(entries);

            showSuccess('Ergebnis gespeichert!', 'batchSummarySuccess');
            setTimeout(() => closeBatchSummaryModal(), 1000);
        }

        function closeBatchSummaryModal() {
            document.getElementById('batchSummaryModal').classList.remove('show');
            document.getElementById('batchSummaryText').value = '';
            document.getElementById('batchSummaryText').style.display = 'none';
            document.getElementById('batchSummaryActions').style.display = 'none';
            document.getElementById('batchSummaryLoading').classList.add('show');
            // Titel f√ºr das n√§chste Mal zur√ºcksetzen
            document.getElementById('batchSummaryTitle').textContent = 'Ergebnis der Stapelaktion';
            document.getElementById('batchSummaryLoading').textContent = 'KI erstellt Gesamt-Zusammenfassung...';
        }

        function copyBatchSummary() {
            const text = document.getElementById('batchSummaryText').value;
            if (!text) return;
            navigator.clipboard.writeText(text).then(() => {
                showSuccess('In Zwischenablage kopiert!', 'batchSummarySuccess');
            }).catch(() => {
                showError('Fehler beim Kopieren.', 'batchSummarySuccess');
            });
        }

        function deleteSelected() {
            if (selectedEntries.size === 0) return;

            showConfirmModal(`${selectedEntries.size} Eintr√§ge wirklich l√∂schen?`, () => {
                const entries = getEntries().filter(e => !selectedEntries.has(e.id));
                saveEntries(entries);
                
                selectedEntries.clear();
                toggleSelectionMode();
                showSuccess('Ausgew√§hlte Eintr√§ge gel√∂scht!');
            });
        }

        function tagSelected() {
            const tag = prompt('Tag f√ºr ausgew√§hlte Eintr√§ge:');
            if (!tag || selectedEntries.size === 0) return;

            const entries = getEntries();
            let changed = false;
            entries.forEach(entry => {
                if (selectedEntries.has(entry.id)) {
                    if (!entry.tags) entry.tags = [];
                    if (!entry.tags.includes(tag)) {
                        entry.tags.push(tag);
                        changed = true;
                    }
                }
            });
            
            if (changed) {
                saveEntries(entries);
                showSuccess('Tags hinzugef√ºgt!');
            }
        }

        function exportSelected() {
            const allEntries = getEntries();
            const entries = allEntries.filter(e => selectedEntries.has(e.id));
            if (entries.length === 0) return;

            const text = entries.map(e => {
                const date = new Date(e.timestamp).toLocaleString('de-DE');
                const tags = e.tags ? `\nTags: ${e.tags.join(', ')}` : '';
                const location = e.location ? `\nStandort: ${e.location.latitude}, ${e.location.longitude}` : '';
                const image = e.image ? `\n[Bild-Notiz enthalten]` : '';
                return `=== ${date} ===${image}${tags}${location}\n\n${e.text}`;
            }).join('\n\n' + '='.repeat(50) + '\n\n');

            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `notizen_${new Date().toISOString().split('T')[0]}.txt`;
            a.click();
            URL.revokeObjectURL(url);

            showSuccess('Exportiert!');
        }

        async function shareSelected() {
            const allEntries = getEntries();
            const entries = allEntries.filter(e => selectedEntries.has(e.id));
            if (entries.length === 0) return;

            const text = entries.map(e => {
                const date = new Date(e.timestamp).toLocaleDateString('de-DE');
                const image = e.image ? '[Bild-Notiz] ' : '';
                return `${date}: ${image}\n${e.text}`;
            }).join('\n\n---\n\n');

            if (navigator.share) {
                try {
                    await navigator.share({ title: 'Meine Notizen', text: text });
                } catch (error) {
                    console.log('Sharing cancelled');
                }
            } else {
                showError('Teilen wird in diesem Browser nicht unterst√ºtzt.');
            }
        }

        function saveAPIKey() {
            localStorage.setItem('api_key', document.getElementById('apiKey').value);
            localStorage.setItem('api_provider', document.getElementById('apiProvider').value);
            // NEU: Status nach dem Speichern der API-Schl√ºssel √ºberpr√ºfen und zuklappen
            checkAndSetApiSetupState();
        }

        function loadAPIKey() {
            const apiKey = localStorage.getItem('api_key');
            const provider = localStorage.getItem('api_provider');
            if (apiKey) document.getElementById('apiKey').value = apiKey;
            if (provider) document.getElementById('apiProvider').value = provider;
            
            // WICHTIG: API Setup Zustand erst NACHDEM die Werte geladen sind pr√ºfen!
            checkAndSetApiSetupState();
        }

        function showError(message, targetId = 'error') {
            const errorEl = document.getElementById(targetId);
            errorEl.textContent = message;
            errorEl.classList.add('show');
            setTimeout(() => errorEl.classList.remove('show'), 5000);
        }

        function showSuccess(message, targetId = 'success') {
            const successEl = document.getElementById(targetId);
            successEl.textContent = message;
            successEl.classList.add('show');
            setTimeout(() => successEl.classList.remove('show'), 3000);
        }

        function showConfirmModal(message, callback) {
            document.getElementById('confirmMessage').textContent = message;
            document.getElementById('confirmModal').classList.add('show');
            confirmCallback = callback;
        }

        function closeConfirmModal() {
            document.getElementById('confirmModal').classList.remove('show');
            confirmCallback = null;
        }

        async function copyToClipboard() {
            const text = document.getElementById('summary').value;
            try {
                await navigator.clipboard.writeText(text);
                showSuccess('In Zwischenablage kopiert!');
            } catch (error) {
                showError('Fehler beim Kopieren: ' + error.message);
            }
        }

        async function shareContent() {
            const text = document.getElementById('summary').value;
            if (navigator.share) {
                try {
                    await navigator.share({ title: 'Sprach-Tagebuch Notiz', text: text });
                } catch (error) {
                    console.log('Sharing cancelled');
                }
            } else {
                showError('Teilen wird in diesem Browser nicht unterst√ºtzt.');
            }
        }

        function resetForm() {
            currentTranscript = '';
            currentLocation = null;
            currentTags = [];
            currentImageBase64 = null; // ZUR√úCKSETZEN
            document.getElementById('transcript').value = '';
            document.getElementById('summary').value = '';
            document.getElementById('newTag').value = '';
            document.getElementById('transcriptSection').classList.remove('show');
            document.getElementById('summarySection').classList.remove('show');
            
            // Bild-Vorschau zur√ºcksetzen
            const imagePreview = document.getElementById('imagePreview');
            imagePreview.src = '';
            imagePreview.style.display = 'none';
            
            // Setze den Status zur√ºck
            updateRecordButton('Bereit zur Aufnahme');
            
            updateCurrentTags();
            document.getElementById('error').classList.remove('show');
            document.getElementById('success').classList.remove('show');
        }

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                
navigator.serviceWorker.register('./sw.js').then(reg => {
    console.log('Service Worker registriert', reg);
    // Wenn bereits ein wartender Worker existiert: sofort aktivieren
    if (reg.waiting) { reg.waiting.postMessage('SKIP_WAITING'); }
    // Bei Updates
    reg.addEventListener('updatefound', () => {
        const nw = reg.installing;
        if (nw) {
            nw.addEventListener('statechange', () => {
                if (nw.state === 'installed' && reg.waiting) {
                    reg.waiting.postMessage('SKIP_WAITING');
                }
            });
        }
    });
}).catch(err => console.log('SW registration failed:', err));

// Neu laden, wenn der Controller wechselt (App-Update)
navigator.serviceWorker.addEventListener('controllerchange', () => {
    console.log('Neue Version aktiv ‚Äì Seite wird aktualisiert‚Ä¶');
    window.location.reload();
});

            });
        }
    </script>

    <!-- KI API Logik -->
    <script>
        // Funktion zum Extrahieren der KI-Antwort basierend auf dem Anbieter
        function handleAPIResponse(provider, data) {
            if (provider === 'anthropic') {
                // Anthropic (Claude) Antwortstruktur
                const textBlock = data.content?.find(block => block.type === 'text');
                return textBlock?.text || 'Fehler beim Parsen der Anthropic-Antwort.';
            } else if (provider === 'openai') {
                // OpenAI (GPT) Antwortstruktur
                return data.choices?.[0]?.message?.content || 'Fehler beim Parsen der OpenAI-Antwort.';
            } else if (provider === 'gemini') {
                // Google (Gemini) Antwortstruktur
                return data.candidates?.[0]?.content?.parts?.[0]?.text || 'Fehler beim Parsen der Gemini-Antwort.';
            }
            return 'Unbekannter KI-Anbieter.';
        }
        
        // Hilfsfunktion: Konvertiert Data URL zu Base64 und MimeType
        function dataURLtoParts(dataURL) {
            const parts = dataURL.split(';base64,');
            if (parts.length < 2) throw new Error("Ung√ºltiges Data-URL-Format.");
            const mime = parts[0].split(':')[1];
            const base64 = parts[1];
            return { mimeType: mime, data: base64 };
        }


        // Hauptfunktion f√ºr den KI-API-Aufruf (jetzt mit optionalem File-Parameter)
        async function callLLMAPI(userPrompt, apiKey, provider, retryCount = 0, imageFile = null) {
            let url = '';
            let headers = {};
            let body = {};
            let model = '';
            let systemInstruction = 'Du bist ein freundlicher, pr√§gnanter Assistent, der Notizen zusammenfasst, umformuliert oder Bilder detailliert beschreibt. Deine Antwort soll nur die gew√ºnschte Ausgabe enthalten, ohne einleitenden Text wie "Hier ist die Zusammenfassung". Antworte auf Deutsch.';
            
            // Konvertierung f√ºr Multimodal-Payloads
            let imageParts = null;
            if (imageFile) {
                // Konvertiere die File-API-Datei in Base64 (wird im anderen Script erledigt)
                // HINWEIS: Bei der Bildanalyse ist imageFile eine File-Objekt, 
                // beim Speichern verwenden wir currentImageBase64 (Data-URL).
                // Da wir callLLMAPI nur direkt nach dem Upload (mit imageFile) 
                // oder beim Reformulieren/Zusammenfassen (ohne Bild) aufrufen, 
                // ist die Logik hier konsistent.
                
                // F√ºr Gemini und Claude wird die Base64-Version ben√∂tigt
                const base64Url = await new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.readAsDataURL(imageFile);
                });
                imageParts = dataURLtoParts(base64Url);
            }


            // API Konfiguration basierend auf Anbieter
            if (provider === 'anthropic') {
                url = 'https://api.anthropic.com/v1/messages';
                model = 'claude-3-5-sonnet-20240620'; // Nutze ein besseres Multimodal-Modell
                
                // Aufbau der Nachrichten-Inhalte
                let content = [{ type: 'text', text: userPrompt }];
                if (imageParts) {
                    content.unshift({
                        type: 'image',
                        source: {
                            type: 'base64',
                            media_type: imageParts.mimeType,
                            data: imageParts.data
                        }
                    });
                }
                
                headers = {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01'
                };
                body = {
                    model: model,
                    max_tokens: 2000,
                    system: systemInstruction,
                    messages: [
                        { role: 'user', content: content }
                    ]
                };
                
            } else if (provider === 'openai') {
                url = 'https://api.openai.com/v1/chat/completions';
                model = 'gpt-4o'; // Nutze gpt-4o f√ºr Multimodalit√§t
                
                let content = [{ type: 'text', text: userPrompt }];
                // Wichtig: Nur Base64 in den Content, wenn currentImageBase64 (Data URL) gesetzt ist.
                if (currentImageBase64) {
                    // Da das Bild nur tempor√§r gehalten wird, MUSS es f√ºr OpenAI hier aus dem State kommen.
                    content.push({
                        type: 'image_url',
                        image_url: {
                            url: currentImageBase64,
                            detail: "low" 
                        }
                    });
                }

                headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                };
                body = {
                    model: model,
                    messages: [
                        { role: 'system', content: systemInstruction },
                        { role: 'user', content: content }
                    ],
                    max_tokens: 2000
                };
            } else if (provider === 'gemini') {
                // Gemini verwendet den Canvas-Proxy, daher kein API-Key im Header, sondern in der URL
                url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`; // flash unterst√ºtzt Multimodalit√§t
                headers = {
                    'Content-Type': 'application/json'
                };
                
                let parts = [{ text: userPrompt }];
                // Wenn imageFile √ºbergeben wurde (beim initialen summarize-Call), dann Base64-Parts hinzuf√ºgen
                if (imageParts) {
                     parts.push({
                         inlineData: { mimeType: imageParts.mimeType, data: imageParts.data }
                     });
                }

                body = {
                    contents: [{ parts: parts }],
                    systemInstruction: { parts: [{ text: systemInstruction }] },
                    generationConfig: { maxOutputTokens: 2000 }
                };
            } else {
                throw new Error('Unbekannter KI-Anbieter ausgew√§hlt.');
            }
            
            // Wenn eine Bilddatei vorhanden ist, setze den Modellnamen f√ºr die Diagnose
            if (imageFile) {
                 try { if(window.__memotag?.diag) window.__memotag.diag.diagLog(`Multimodal-Aufruf gestartet: ${model}`); } catch(_) {}
            }


            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(body)
                });

                const data = await response.json();

                if (!response.ok) {
                    const errorMsg = data.error?.message || data.error?.type || 'Unbekannter Fehler';
                    throw new Error(`API-Fehler (${response.status}): ${errorMsg}`);
                }

                // Fehlerbehandlung f√ºr unvollst√§ndige Antworten
                const resultText = handleAPIResponse(provider, data);
                if (resultText.startsWith('Fehler beim Parsen')) {
                     throw new Error(resultText);
                }
                
                return resultText;

            } catch (error) {
                // Exponential Backoff f√ºr Netzwerkfehler oder Timeout
                if (retryCount < 3 && (error.message.includes('Failed to fetch') || error.message.includes('Timeout'))) {
                    const delay = Math.pow(2, retryCount) * 1000;
                    console.warn(`API-Aufruf fehlgeschlagen. Versuche es in ${delay}ms erneut...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return callLLMAPI(userPrompt, apiKey, provider, retryCount + 1, imageFile);
                }
                throw error;
            }
        }
    </script>
    
<section class="diag-card collapsed" id="diagnostics"> <!-- NEU: 'collapsed' als Standard -->
  <h3 style="margin-top:0" id="diagHeader">Diagnose <span class="toggle-icon">‚ñº</span></h3> <!-- NEU: ID und Icon -->
  <div class="diag-content" id="diagContent"> <!-- NEU: Content Wrapper -->
      <div class="diag-grid">
        <div>Zustand</div>
        <div><span id="diag-state" class="state-badge state-warn">bereit</span></div>

        <div>Mikrofon-Pegel</div>
        <div class="level-wrap"><div id="diag-level" class="level-bar anim"></div></div>

        <div>Letzter Fehler</div>
        <div id="diag-last-error">‚Äì</div>

        <div>Ereignis-Log</div>
        <div id="diag-log" aria-live="polite"></div>
        <div style="grid-column:1 / span 2; display:flex; gap:8px; margin-top:8px;"><button id="diagStart" type="button">Diagnose starten</button><button id="diagStop" type="button">Diagnose stoppen</button></div>
      </div>
  </div>
</section>


<script id="diag-script">
  (function(){
    const $state = () => document.getElementById('diag-state');
    const $log = () => document.getElementById('diag-log');
    const $err = () => document.getElementById('diag-last-error');
    const $lvl = () => document.getElementById('diag-level');

    window.__memotag = window.__memotag || {};
    let audioCtx, analyser, micStream, rafId;
    let lowLevelStart = null;

    function ts(){
      const d = new Date();
      return d.toLocaleTimeString();
    }

    window.diagSetState = function(text, cls){
      const el = $state();
      if(!el) return;
      el.textContent = text;
      el.classList.remove('state-ok','state-warn','state-err');
      el.classList.add(cls || 'state-warn');
    }

    window.diagLog = function(msg){
      const el = $log();
      if(!el) return;
      const line = document.createElement('div');
      line.className = 'line';
      line.textContent = `[${ts()}] ${msg}`;
      el.prepend(line);
      const nodes = el.querySelectorAll('.line');
      if(nodes.length > 60) el.removeChild(nodes[nodes.length-1]);
    }

    window.diagError = function(msg){
      const el = $err();
      if(el) el.textContent = msg || '‚Äì';
      diagSetState('Fehler', 'state-err');
      diagLog('ERROR: ' + msg);
    }

    window.startMicMeter = async function(){
      try{
        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
          diagLog('getUserMedia nicht verf√ºgbar');
          return;
        }
        micStream = await navigator.mediaDevices.getUserMedia({audio:true});
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        const source = audioCtx.createMediaStreamSource(micStream);
        source.connect(analyser);
        const data = new Uint8Array(analyser.fftSize);

        function tick(){
          analyser.getByteTimeDomainData(data);
          let sum = 0;
          for(let i=0;i<data.length;i++){ const v = (data[i]-128)/128; sum += v*v; }
          const rms = Math.sqrt(sum/data.length);
          const pct = Math.min(100, Math.max(0, Math.round(rms*180)));
          const bar = $lvl();
          if(bar){ bar.style.width = pct + '%'; }
          if(pct < 5){
            if(!lowLevelStart) lowLevelStart = performance.now();
            else if(performance.now() - lowLevelStart > 3000){
              diagLog('Hinweis: Sehr niedriger Pegel erkannt (Mikro weit weg? stumm?)');
              lowLevelStart = null;
            }
          } else {
            lowLevelStart = null;
          }
          rafId = requestAnimationFrame(tick);
        }
        tick();
        diagLog('Mic-Meter gestartet');
      }catch(e){
        diagError('Mic-Meter Fehler: ' + e.message);
      }
    }

    window.stopMicMeter = function(){
      if(rafId) cancelAnimationFrame(rafId);
      rafId = null;
      try { if(micStream){ micStream.getTracks().forEach(t=>t.stop()); } } catch(e){}
      try { if(audioCtx){ audioCtx.close(); } } catch(e){}
      const bar = $lvl();
      if(bar){ bar.style.width = '0%'; }
      diagLog('Mic-Meter gestoppt');
    }

    const _origInit = window.initSpeechRecognition;
    window.initSpeechRecognition = function(){
      if(typeof _origInit === 'function'){
        _origInit();
      }
      try{
        if(window.recognition){
          const r = window.recognition;
          r.onstart = ()=>{ diagSetState('l√§uft', 'state-ok'); diagLog('onstart'); };
          r.onaudiostart = ()=>{ diagLog('onaudiostart'); };
          r.onsoundstart = ()=>{ diagLog('onsoundstart'); };
          r.onspeechstart = ()=>{ diagSetState('Sprache erkannt', 'state-ok'); diagLog('onspeechstart'); };
          r.onspeechend = ()=>{ diagLog('onspeechend'); };
          r.onsoundend = ()=>{ diagLog('onsoundend'); };
          r.onaudioend = ()=>{ diagLog('onaudioend'); };
          const prevOnResult = r.onresult;
          r.onresult = (ev)=>{ diagLog('onresult (' + ev.results.length + ' Segmente)'); if(prevOnResult) prevOnResult(ev); };
          r.onerror = (ev)=>{ diagError(ev.error || 'Unbekannter Fehler'); try{ if(window.stopRecording) window.stopRecording(); }catch(e){} };
          r.onend = ()=>{
            diagLog('onend');
            if(window.isRecording){
              diagSetState('automatischer Neustart...', 'state-warn');
              try { r.start(); } catch(e) { diagLog('Restart Fehler: ' + e.message); }
            } else {
              diagSetState('beendet', 'state-warn');
            }
          };
        }
      }catch(e){
        diagError('Init-Hook Fehler: ' + e.message);
      }
    }

    window.__memotag.diag = { diagSetState, diagLog, diagError, startMicMeter, stopMicMeter };
  })();
</script>


<script id="override-start-stop">
// --- Override start/stop for Mic-Meter (wird jetzt nur von MediaRecorder benutzt) ---
// Die Logik in dieser Sektion wurde in die main-script Bl√∂cke verschoben, um sie zu vereinfachen.
// Die urspr√ºnglichen Funktionen 'startRecording' und 'stopRecording' im Haupt-Script wurden 
// durch die neuen MediaRecorder-Funktionen ersetzt. Diese Sektion wird nun entfernt, um 
// Redundanz zu vermeiden.
</script>

<script>

document.addEventListener('DOMContentLoaded', () => {
    const hash = location.hash;
    if (hash === '#new') {
        const b = document.getElementById('recordBtn');
        if (b) { b.scrollIntoView({behavior:'smooth', block:'center'}); b.focus(); }
    } else if (hash === '#entries') {
        const e = document.querySelector('.entries-section');
        if (e) e.scrollIntoView({behavior:'smooth', block:'start'});
    }
});

</script>
<script>

// ---- iOS Fallback: Audioaufnahme/-Upload + Transkription ----
function isIOS() {
    return /iPhone|iPad|iPod/i.test(navigator.userAgent);
}

// NOTE: Die Funktion fileToBase64 wurde optimiert und in die callLLMAPI Logik integriert.
// Wir behalten die Helper-Funktionen bei, um sie im Hauptscript zu verwenden.

// Konvertiert File Blob zu Base64 String
async function fileToBase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result.split(',')[1]); // Nur Base64-Teil
        reader.onerror = error => reject(error);
        reader.readAsDataURL(file);
    });
}


function normalizeMime(file) {
    const t = (file.type || '').toLowerCase();
    if (t) return t;
    const name = (file.name || '').toLowerCase();
    if (name.endsWith('.m4a')) return 'audio/mp4';
    if (name.endsWith('.mp3')) return 'audio/mpeg';
    if (name.endsWith('.wav')) return 'audio/wav';
    if (name.endsWith('.ogg')) return 'audio/ogg';
    if (name.endsWith('.webm')) return 'audio/webm';
    if (name.endsWith('.png')) return 'image/png'; // NEU: Image Mime
    if (name.endsWith('.jpg') || name.endsWith('.jpeg')) return 'image/jpeg'; // NEU: Image Mime
    return 'application/octet-stream';
}


async function transcribeAudio(file, apiKey, provider) {
    // Size guard (most APIs support at least ~20-25MB; keep it conservative)
    const maxMB = 20;
    if (file.size > maxMB * 1024 * 1024) {
        throw new Error(`Audiodatei ist gr√∂√üer als ${maxMB} MB.`);
    }

    if (provider === 'openai') {
        const url = 'https://api.openai.com/v1/audio/transcriptions';
        const form = new FormData();
        form.append('file', file, file.name || 'audio.m4a');
        form.append('model', 'whisper-1');
        form.append('language', 'de');
        const resp = await fetch(url, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${apiKey}` },
            body: form
        });
        const data = await resp.json();
        if (!resp.ok) {
            const msg = data.error?.message || 'Unbekannter Fehler';
            throw new Error(`OpenAI-Fehler (${resp.status}): ${msg}`);
        }
        return data.text || '';
    }

    if (provider === 'anthropic') {
        // Claude Messages API mit input_audio Block
        const url = 'https://api.anthropic.com/v1/messages';
        const b64 = await fileToBase64(file);
        const mime = normalizeMime(file);
        const body = {
            model: 'claude-3-5-haiku-latest',
            max_tokens: 2000,
            system: 'Du bist ein pr√§ziser Transkriptionsassistent. Transkribiere nur den gesprochenen deutschen Text, ohne Zusatz.',
            messages: [{
                role: 'user',
                content: [
                    { type: 'text', text: 'Transkribiere dieses Audio auf Deutsch.' },
                    { type: 'image', source: { type: 'base64', data: b64, media_type: mime } } // Anthropic verwendet 'image' f√ºr alle Bin√§rdaten in diesem Kontext
                ]
            }]
        };
        const resp = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': apiKey,
                'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify(body)
        });
        const data = await resp.json();
        if (!resp.ok) {
            const msg = data.error?.message || data.error?.type || 'Unbekannter Fehler';
            throw new Error(`Anthropic-Fehler (${resp.status}): ${msg}`);
        }
        // Response: content is an array of blocks; find text
        const block = (data.content || []).find(b => b.type === 'text');
        return (block && block.text) || '';
    }

    if (provider === 'gemini') {
        // Gemini: generateContent mit inlineData
        const mime = normalizeMime(file);
        const b64 = await fileToBase64(file);
        // Modell auf ein unterst√ºtztes Multimodal-Modell aktualisiert (gemini-2.5-flash)
        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
        const body = {
            contents: [{
                parts: [
                    { text: 'Transkribiere dieses Audio auf Deutsch. Antworte nur mit dem reinen Transkript.' },
                    { inlineData: { mimeType: mime, data: b64 } }
                ]
            }],
            generationConfig: { maxOutputTokens: 2000 }
        };
        const resp = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });
        const data = await resp.json();
        if (!resp.ok) {
            const msg = data.error?.message || 'Unbekannter Fehler';
            throw new Error(`Gemini-Fehler (${resp.status}): ${msg}`);
        }
        const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
        return text;
    }

    throw new Error('Unbekannter KI-Anbieter f√ºr Audio-Transkription.');
}
// 
// 


// Hook in nach DOMContentLoaded (wurde in main-script verschoben)
// document.addEventListener('DOMContentLoaded', initIOSFallback);

</script>
<script>

// ---- MediaRecorder Fallback (Desktop): Direktaufnahme am PC ----
// Entfernte die Deklaration von __mr, __mrStream, __mrChunks, __mrRecording, da sie im Hauptskript deklariert sind.
function stopStream(stream){ try{ if(stream) stream.getTracks().forEach(t=>t.stop()); }catch(_){} }

function initMediaRecorderFallback(){
    // Diagnose-Log hinzuf√ºgen, um zu sehen, ob die Funktion aufgerufen wird
    try { if(window.__memotag?.diag) window.__memotag.diag.diagLog('Init: MediaRecorder Fallback (PC Aufnahme)'); } catch(_) {}

    // Die Logik f√ºr den Klick wird jetzt direkt in toggleRecording behandelt
}

// Hook in nach DOMContentLoaded (wurde in main-script verschoben)
// document.addEventListener('DOMContentLoaded', initMediaRecorderFallback);

</script>
</body>
</html>
